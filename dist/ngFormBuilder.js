(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
"use strict";
/*! ng-formio-builder v2.18.1 | https://unpkg.com/ng-formio-builder@2.18.1/LICENSE.txt */
/*global window: false, console: false, jQuery: false */
/*jshint browser: true */


var app = angular.module('ngFormBuilder', [
  'formio',
  'dndLists',
  'ngDialog',
  'ui.bootstrap.accordion',
  'ckeditor'
]);

app.constant('FORM_OPTIONS', _dereq_('./constants/formOptions'));

app.constant('COMMON_OPTIONS', _dereq_('./constants/commonOptions'));

app.factory('debounce', _dereq_('./factories/debounce'));

app.directive('formBuilderDraggable', function() {
  return {
    restrict: 'A',
    scope: {
      'formBuilderDraggable': '='
    },
    link: function(scope, element) {
      var el = element[0];
      el.draggable = true;
      el.addEventListener('dragstart', function(event) {
        var dragData = scope.formBuilderDraggable;
        var dropZone = document.getElementById('fb-drop-zone');
        if (dropZone) {
          dropZone.style.zIndex = 10;
        }
        event.dataTransfer.setData('Text', JSON.stringify(dragData));
        return false;
      }, false);
    }
  };
});

app.directive('formBuilderDroppable', function() {
  return {
    restrict: 'A',
    link: function(scope, element) {
      var el = element[0];
      el.addEventListener('dragover', function(event) {
        event.preventDefault();
        return false;
      }, false);
      el.addEventListener('drop', function(event) {
        event.stopPropagation();
        var dragData = JSON.parse(event.dataTransfer.getData('text/plain'));
        var dropOffset = jQuery(el).offset();
        el.style.zIndex = 0;
        dragData.fbDropX = event.pageX - dropOffset.left;
        dragData.fbDropY = event.pageY - dropOffset.top;
        scope.$emit('fbDragDrop', dragData);
        return false;
      }, false);
    }
  };
});

app.factory('BuilderUtils', _dereq_('./factories/BuilderUtils'));

app.directive('formBuilder', _dereq_('./directives/formBuilder'));

app.directive('formBuilderComponent', _dereq_('./directives/formBuilderComponent'));

app.directive('formBuilderElement', _dereq_('./directives/formBuilderElement'));

app.controller('formBuilderDnd', _dereq_('./directives/formBuilderDnd'));

app.directive('formBuilderList', _dereq_('./directives/formBuilderList'));

app.directive('formBuilderRow', _dereq_('./directives/formBuilderRow'));

app.directive('jsonInput', _dereq_('./directives/jsonInput'));

app.directive('formBuilderOption', _dereq_('./directives/formBuilderOption'));

app.directive('formBuilderTable', _dereq_('./directives/formBuilderTable'));

app.directive('formBuilderOptionKey', _dereq_('./directives/formBuilderOptionKey'));

app.directive('formBuilderOptionTags', _dereq_('./directives/formBuilderOptionTags'));

app.directive('validApiKey', _dereq_('./directives/validApiKey'));

app.directive('formBuilderOptionCustomValidation', _dereq_('./directives/formBuilderOptionCustomValidation'));

app.directive('formBuilderTooltip', _dereq_('./directives/formBuilderTooltip'));

app.directive('valueBuilder', _dereq_('./directives/valueBuilder'));

app.directive('formBuilderConditional', _dereq_('./directives/formBuilderConditional'));

/**
 * This workaround handles the fact that iframes capture mouse drag
 * events. This interferes with dragging over components like the
 * Content component. As a workaround, we keep track of the isDragging
 * flag here to overlay iframes with a div while dragging.
 */
app.value('dndDragIframeWorkaround', {
  isDragging: false
});

app.run([
  '$templateCache',
  '$rootScope',
  'ngDialog',
  function(
    $templateCache,
    $rootScope,
    ngDialog
  ) {
    // Close all open dialogs on state change.
    $rootScope.$on('$stateChangeStart', function() {
      ngDialog.closeAll(false);
    });

    $templateCache.put('formio/formbuilder/editbuttons.html',
      "<div class=\"component-btn-group\">\r\n  <div class=\"btn btn-xxs btn-danger component-settings-button component-settings-button-remove\" style=\"z-index: 1000\" ng-click=\"removeComponent(component, formComponent.confirmRemove)\"><span class=\"glyphicon glyphicon-remove\"></span></div>\r\n  <div ng-if=\"::formComponent.views && !component.lockConfiguration\" class=\"btn btn-xxs btn-default component-settings-button component-settings-button-clone\" style=\"z-index: 1000\" ng-click=\"cloneComponent(component)\"><span class=\"glyphicon glyphicon-new-window\"></span></div>\r\n  <div ng-if=\"::!hideMoveButton\" class=\"btn btn-xxs btn-default component-settings-button component-settings-button-move\" style=\"z-index: 1000\"><span class=\"glyphicon glyphicon glyphicon-move\"></span></div>\r\n  <div ng-if=\"::formComponent.views && !component.lockConfiguration\" class=\"btn btn-xxs btn-default component-settings-button component-settings-button-edit\" style=\"z-index: 1000\" ng-click=\"editComponent(component)\"><span class=\"glyphicon glyphicon-cog\"></span></div>\r\n</div>\r\n"
    );

    $templateCache.put('formio/formbuilder/component.html',
      "<div class=\"component-form-group component-type-{{ component.type }} form-builder-component\">\r\n  <div ng-if=\"::!hideButtons\" ng-include=\"'formio/formbuilder/editbuttons.html'\"></div>\r\n  <div class=\"form-group has-feedback form-field-type-{{ component.type }} {{component.customClass}}\" id=\"form-group-{{ component.key }}\" style=\"position:inherit\" ng-style=\"component.style\">\r\n    <form-builder-element></form-builder-element>\r\n  </div>\r\n</div>\r\n"
    );

    $templateCache.put('formio/formbuilder/list.html',
      "<ul class=\"component-list\"\r\n    dnd-list=\"component.components\"\r\n    dnd-drop=\"addComponent(item, index)\">\r\n  <li ng-if=\"component.components.length < hideCount\">\r\n    <div class=\"alert alert-info\" style=\"text-align:center; margin-bottom: 5px;\" role=\"alert\">\r\n      Drag and Drop a form component\r\n    </div>\r\n  </li>\r\n  <!-- DO NOT PUT \"track by $index\" HERE SINCE DYNAMICALLY ADDING/REMOVING COMPONENTS WILL BREAK -->\r\n  <li ng-repeat=\"component in component.components\"\r\n      ng-if=\"!rootList || !form.display || (form.display === 'form') || (form.page === $index)\"\r\n      dnd-draggable=\"component\"\r\n      dnd-effect-allowed=\"move\"\r\n      dnd-dragstart=\"dndDragIframeWorkaround.isDragging = true\"\r\n      dnd-dragend=\"dndDragIframeWorkaround.isDragging = false\"\r\n      dnd-moved=\"removeComponent(component, false)\">\r\n    <form-builder-component ng-if=\"!component.hideBuilder\"></form-builder-component>\r\n    <div ng-if=\"dndDragIframeWorkaround.isDragging && !formComponent.noDndOverlay\" class=\"dndOverlay\"></div>\r\n  </li>\r\n</ul>\r\n"
    );

    $templateCache.put('formio/formbuilder/row.html',
      "<div class=\"formbuilder-row\">\r\n  <label ng-if=\"component.label\" class=\"control-label\">{{ component.label }}</label>\r\n  <ul class=\"component-row formbuilder-group\"\r\n      dnd-list=\"component.components\"\r\n      dnd-drop=\"addComponent(item, index)\"\r\n      dnd-horizontal-list=\"true\">\r\n    <li ng-repeat=\"component in component.components\"\r\n        class=\"formbuilder-group-row pull-left\"\r\n        dnd-draggable=\"component\"\r\n        dnd-effect-allowed=\"move\"\r\n        dnd-dragstart=\"dndDragIframeWorkaround.isDragging = true\"\r\n        dnd-dragend=\"dndDragIframeWorkaround.isDragging = false\"\r\n        dnd-moved=\"removeComponent(component, false)\">\r\n      <form-builder-component></form-builder-component>\r\n      <div ng-if=\"dndDragIframeWorkaround.isDragging && !formComponent.noDndOverlay\" class=\"dndOverlay\"></div>\r\n    </li>\r\n    <li class=\"formbuilder-group-row form-builder-drop\" ng-if=\"component.components.length < hideCount\">\r\n      <div class=\"alert alert-info\" role=\"alert\">\r\n        Drag and Drop a form component\r\n      </div>\r\n    </li>\r\n  </ul>\r\n  <div style=\"clear:both;\"></div>\r\n</div>\r\n"
    );

    $templateCache.put('formio/formbuilder/builder.html',
      "<div class=\"row formbuilder\">\r\n  <div class=\"col-xs-4 col-sm-3 col-md-2 formcomponents\" ng-if=\"form && form.display\">\r\n    <uib-accordion close-others=\"true\" ng-if=\"form.display !== 'pdf'\">\r\n      <div uib-accordion-group ng-repeat=\"(groupName, group) in formComponentGroups\" heading=\"{{ group.title }}\" is-open=\"$first\" class=\"panel panel-default form-builder-panel {{ group.panelClass }}\">\r\n        <uib-accordion close-others=\"true\" ng-if=\"group.subgroups\">\r\n          <div uib-accordion-group ng-repeat=\"(subgroupName, subgroup) in group.subgroups\" heading=\"{{ subgroup.title }}\" is-open=\"$first\" class=\"panel panel-default form-builder-panel subgroup-accordion\">\r\n            <div ng-repeat=\"component in formComponentsByGroup[groupName][subgroupName]\" ng-if=\"component.title\"\r\n                dnd-draggable=\"component.settings\"\r\n                dnd-dragstart=\"dndDragIframeWorkaround.isDragging = true\"\r\n                dnd-dragend=\"dndDragIframeWorkaround.isDragging = false\"\r\n                dnd-effect-allowed=\"copy\"\r\n                class=\"formcomponentcontainer\">\r\n              <span class=\"btn btn-primary btn-xs btn-block formcomponent\" title=\"{{component.title}}\" style=\"overflow: hidden; text-overflow: ellipsis;\">\r\n                <i ng-if=\"component.icon\" class=\"{{ component.icon }}\"></i> {{ component.title }}\r\n              </span>\r\n            </div>\r\n          </div>\r\n        </uib-accordion>\r\n        <div ng-repeat=\"component in formComponentsByGroup[groupName]\" ng-if=\"!group.subgroup && component.title\"\r\n            dnd-draggable=\"component.settings\"\r\n            dnd-dragstart=\"dndDragIframeWorkaround.isDragging = true\"\r\n            dnd-dragend=\"dndDragIframeWorkaround.isDragging = false\"\r\n            dnd-effect-allowed=\"copy\"\r\n            class=\"formcomponentcontainer\">\r\n          <span class=\"btn btn-primary btn-xs btn-block formcomponent\" title=\"{{component.title}}\" style=\"overflow: hidden; text-overflow: ellipsis;\">\r\n            <i ng-if=\"component.icon\" class=\"{{ component.icon }}\"></i> {{ component.title }}\r\n          </span>\r\n        </div>\r\n      </div>\r\n    </uib-accordion>\r\n    <uib-accordion close-others=\"true\" ng-if=\"form.display === 'pdf'\">\r\n      <div uib-accordion-group heading=\"PDF Fields\" is-open=\"true\" class=\"panel panel-default form-builder-panel\">\r\n        <div class=\"formcomponentcontainer\" ng-repeat=\"pdftype in pdftypes\">\r\n          <span class=\"btn btn-primary btn-xs btn-block formcomponent\" title=\"{{ pdftype.title }}\" style=\"overflow: hidden; text-overflow: ellipsis;\" form-builder-draggable=\"pdftype\">\r\n            <i ng-if=\"pdftype.icon\" class=\"{{ pdftype.icon }}\"></i> {{ pdftype.title }}\r\n          </span>\r\n        </div>\r\n      </div>\r\n    </uib-accordion>\r\n  </div>\r\n  <div class=\"col-xs-8 col-sm-9 col-md-10 formarea\" ng-if=\"form && form.display\">\r\n    <ol class=\"breadcrumb\" ng-if=\"form.display === 'wizard'\">\r\n      <li ng-repeat=\"title in pages() track by $index\"><a class=\"label\" style=\"font-size:1em;\" ng-class=\"{'label-info': ($index === getPage()), 'label-primary': ($index !== getPage())}\" ng-click=\"showPage($index)\">{{ title }}</a></li>\r\n      <li><a class=\"label label-success\" style=\"font-size:1em;\" ng-click=\"newPage()\" data-toggle=\"tooltip\" title=\"Create Page\"><span class=\"glyphicon glyphicon-plus\" aria-hidden=\"true\"></span> page</a></li>\r\n    </ol>\r\n    <div class=\"dropzone\">\r\n      <div ng-if=\"form.display === 'pdf'\" ng-controller=\"formBuilderDnd\">\r\n        <div form-builder-droppable style=\"width:100%;height:2000px;position:absolute;\" id=\"fb-drop-zone\"></div>\r\n        <formio form=\"form\" ng-init=\"form.builder = true;\"></formio>\r\n      </div>\r\n      <form-builder-list ng-if=\"form.display !== 'pdf'\" component=\"form\" form=\"form\" formio=\"::formio\" hide-dnd-box-count=\"hideCount\" root-list=\"true\" class=\"rootlist\" options=\"options\"></form-builder-list>\r\n    </div>\r\n  </div>\r\n</div>\r\n"
    );

    $templateCache.put('formio/formbuilder/datagrid.html',
      "<div class=\"datagrid-dnd dropzone\" ng-controller=\"formBuilderDnd\">\r\n  <label ng-if=\"component.label\" class=\"control-label\">{{ component.label }}</label>\r\n  <table class=\"table datagrid-table\" ng-class=\"{'table-striped': component.striped, 'table-bordered': component.bordered, 'table-hover': component.hover, 'table-condensed': component.condensed}\">\r\n    <tr>\r\n      <th style=\"padding:30px 0 10px 0\" ng-repeat=\"component in component.components\" ng-class=\"{'field-required': component.validate.required}\">\r\n        {{ (component.label || '') | formioTranslate:null:builder }}\r\n        <div ng-if=\"dndDragIframeWorkaround.isDragging && !formComponent.noDndOverlay\" class=\"dndOverlay\"></div>\r\n      </th>\r\n    </tr>\r\n    <tr\r\n      class=\"component-list\"\r\n      dnd-list=\"component.components\"\r\n      dnd-drop=\"addComponent(item, index)\"\r\n    >\r\n      <td\r\n        ng-repeat=\"component in component.components\"\r\n        ng-init=\"hideMoveButton = true; component.hideLabel = true\"\r\n        dnd-draggable=\"component\"\r\n        dnd-effect-allowed=\"move\"\r\n        dnd-dragstart=\"dndDragIframeWorkaround.isDragging = true\"\r\n        dnd-dragend=\"dndDragIframeWorkaround.isDragging = false\"\r\n        dnd-moved=\"removeComponent(component, false)\"\r\n      >\r\n        <div class=\"component-form-group component-type-{{ component.type }} form-builder-component\">\r\n          <div class=\"has-feedback form-field-type-{{ component.type }} {{component.customClass}}\" id=\"form-group-{{ component.key }}\" style=\"position:inherit\" ng-style=\"component.style\">\r\n            <div class=\"input-group\">\r\n              <form-builder-component></form-builder-component>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </td>\r\n      <td ng-if=\"component.components.length === 0\">\r\n        <div class=\"alert alert-info\" role=\"alert\">\r\n          Datagrid Components\r\n        </div>\r\n      </td>\r\n    </tr>\r\n  </table>\r\n  <div style=\"clear:both;\"></div>\r\n</div>\r\n"
    );

    $templateCache.put('formio/components/confirm-remove.html',
      "<form id=\"confirm-remove-dialog\">\r\n  <p>Removing this component will also <strong>remove all of its children</strong>! Are you sure you want to do this?</p>\r\n  <div>\r\n    <div class=\"form-group\">\r\n      <button type=\"submit\" class=\"btn btn-danger pull-right\" ng-click=\"closeThisDialog(true)\">Remove</button>&nbsp;\r\n      <button type=\"button\" class=\"btn btn-default pull-right\" style=\"margin-right: 5px;\" ng-click=\"closeThisDialog(false)\">Cancel</button>&nbsp;\r\n    </div>\r\n  </div>\r\n</form>\r\n"
    );
  }
]);

_dereq_('./components');

},{"./components":228,"./constants/commonOptions":244,"./constants/formOptions":245,"./directives/formBuilder":246,"./directives/formBuilderComponent":247,"./directives/formBuilderConditional":248,"./directives/formBuilderDnd":249,"./directives/formBuilderElement":250,"./directives/formBuilderList":251,"./directives/formBuilderOption":252,"./directives/formBuilderOptionCustomValidation":253,"./directives/formBuilderOptionKey":254,"./directives/formBuilderOptionTags":255,"./directives/formBuilderRow":256,"./directives/formBuilderTable":257,"./directives/formBuilderTooltip":258,"./directives/jsonInput":259,"./directives/validApiKey":260,"./directives/valueBuilder":261,"./factories/BuilderUtils":262,"./factories/debounce":263}],2:[function(_dereq_,module,exports){
'use strict';

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var _jsonLogicJs = _dereq_('json-logic-js');

var _jsonLogicJs2 = _interopRequireDefault(_jsonLogicJs);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _get = _dereq_('lodash/get');

module.exports = {
  /**
   * Determine if a component is a layout component or not.
   *
   * @param {Object} component
   *   The component to check.
   *
   * @returns {Boolean}
   *   Whether or not the component is a layout component.
   */
  isLayoutComponent: function isLayoutComponent(component) {
    return component.columns && Array.isArray(component.columns) || component.rows && Array.isArray(component.rows) || component.components && Array.isArray(component.components) ? true : false;
  },

  /**
   * Iterate through each component within a form.
   *
   * @param {Object} components
   *   The components to iterate.
   * @param {Function} fn
   *   The iteration function to invoke for each component.
   * @param {Boolean} includeAll
   *   Whether or not to include layout components.
   * @param {String} path
   *   The current data path of the element. Example: data.user.firstName
   */
  eachComponent: function eachComponent(components, fn, includeAll, path) {
    if (!components) return;
    path = path || '';
    components.forEach(function (component) {
      var hasColumns = component.columns && Array.isArray(component.columns);
      var hasRows = component.rows && Array.isArray(component.rows);
      var hasComps = component.components && Array.isArray(component.components);
      var noRecurse = false;
      var newPath = component.key ? path ? path + '.' + component.key : component.key : '';

      if (includeAll || component.tree || !hasColumns && !hasRows && !hasComps) {
        noRecurse = fn(component, newPath);
      }

      var subPath = function subPath() {
        if (component.key && (component.type === 'datagrid' || component.type === 'container')) {
          return newPath;
        }
        return path;
      };

      if (!noRecurse) {
        if (hasColumns) {
          component.columns.forEach(function (column) {
            eachComponent(column.components, fn, includeAll, subPath());
          });
        } else if (hasRows) {
          [].concat.apply([], component.rows).forEach(function (row) {
            eachComponent(row.components, fn, includeAll, subPath());
          });
        } else if (hasComps) {
          eachComponent(component.components, fn, includeAll, subPath());
        }
      }
    });
  },

  /**
   * Get a component by its key
   *
   * @param {Object} components
   *   The components to iterate.
   * @param {String} key
   *   The key of the component to get.
   *
   * @returns {Object}
   *   The component that matches the given key, or undefined if not found.
   */
  getComponent: function getComponent(components, key) {
    var result;
    module.exports.eachComponent(components, function (component) {
      if (component.key === key) {
        result = component;
      }
    });
    return result;
  },

  /**
   * Flatten the form components for data manipulation.
   *
   * @param {Object} components
   *   The components to iterate.
   * @param {Boolean} includeAll
   *   Whether or not to include layout components.
   *
   * @returns {Object}
   *   The flattened components map.
   */
  flattenComponents: function flattenComponents(components, includeAll) {
    var flattened = {};
    module.exports.eachComponent(components, function (component, path) {
      flattened[path] = component;
    }, includeAll);
    return flattened;
  },

  /**
   * Returns if this component has a conditional statement.
   *
   * @param component - The component JSON schema.
   *
   * @returns {boolean} - TRUE - This component has a conditional, FALSE - No conditional provided.
   */
  hasCondition: function hasCondition(component) {
    return component.hasOwnProperty('customConditional') && component.customConditional || component.hasOwnProperty('conditional') && component.conditional && component.conditional.when || component.hasOwnProperty('conditional') && component.conditional && component.conditional.json;
  },

  /**
   * Checks the conditions for a provided component and data.
   *
   * @param component
   *   The component to check for the condition.
   * @param row
   *   The data within a row
   * @param data
   *   The full submission data.
   *
   * @returns {boolean}
   */
  checkCondition: function checkCondition(component, row, data) {
    if (component.hasOwnProperty('customConditional') && component.customConditional) {
      try {
        var script = '(function() { var show = true;';
        script += component.customConditional.toString();
        script += '; return show; })()';
        var result = eval(script);
        return result.toString() === 'true';
      } catch (e) {
        console.warn('An error occurred in a custom conditional statement for component ' + component.key, e);
        return true;
      }
    } else if (component.hasOwnProperty('conditional') && component.conditional && component.conditional.when) {
      var cond = component.conditional;
      var value = null;
      if (row) {
        value = this.getValue({ data: row }, cond.when);
      }
      if (data && (value === null || typeof value === 'undefined')) {
        value = this.getValue({ data: data }, cond.when);
      }
      // FOR-400 - Fix issue where falsey values were being evaluated as show=true
      if (value === null || typeof value === 'undefined') {
        return false;
      }
      // Special check for selectboxes component.
      if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.hasOwnProperty(cond.eq)) {
        return value[cond.eq].toString() === cond.show.toString();
      }
      // FOR-179 - Check for multiple values.
      if (value instanceof Array && value.indexOf(cond.eq) !== -1) {
        return cond.show.toString() === 'true';
      }

      return value.toString() === cond.eq.toString() === (cond.show.toString() === 'true');
    } else if (component.hasOwnProperty('conditional') && component.conditional && component.conditional.json) {
      return _jsonLogicJs2.default.apply(component.conditional.json, {
        data: data,
        row: row
      });
    }

    // Default to show.
    return true;
  },

  /**
   * Get the value for a component key, in the given submission.
   *
   * @param {Object} submission
   *   A submission object to search.
   * @param {String} key
   *   A for components API key to search for.
   */
  getValue: function getValue(submission, key) {
    var data = submission.data || {};

    var search = function search(data) {
      var i;
      var value;

      if (!data) {
        return null;
      }

      if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' && !(data instanceof Array)) {
        if (data.hasOwnProperty(key)) {
          return data[key];
        }

        var keys = Object.keys(data);
        for (i = 0; i < keys.length; i++) {
          if (_typeof(data[keys[i]]) === 'object') {
            value = search(data[keys[i]]);
          }

          if (value) {
            return value;
          }
        }
      }
    };

    return search(data);
  },

  /**
   * Interpolate a string and add data replacements.
   *
   * @param string
   * @param data
   * @returns {XML|string|*|void}
   */
  interpolate: function interpolate(string, data) {
    return string.replace(/\{\{\s*([^\s]*)\s*\}\}/g, function (match, token) {
      return _get(data, token);
    });
  }
};

},{"json-logic-js":4,"lodash/get":177}],3:[function(_dereq_,module,exports){
'use strict';

module.exports = _dereq_('./build/utils');

},{"./build/utils":2}],4:[function(_dereq_,module,exports){
/* globals define,module */
/*
Using a Universal Module Loader that should be browser, require, and AMD friendly
http://ricostacruz.com/cheatsheets/umdjs.html
*/
;(function(root, factory) {
  if (typeof define === "function" && define.amd) {
    define(factory);
  } else if (typeof exports === "object") {
    module.exports = factory();
  } else {
    root.jsonLogic = factory();
  }
}(this, function() {
  "use strict";
  /* globals console:false */

  if ( ! Array.isArray) {
    Array.isArray = function(arg) {
      return Object.prototype.toString.call(arg) === "[object Array]";
    };
  }

  function arrayUnique(array) {
    var a = [];
    for (var i=0, l=array.length; i<l; i++) {
      if (a.indexOf(array[i]) === -1) {
        a.push(array[i]);
      }
    }
    return a;
  }

  var jsonLogic = {};
  var operations = {
    "==": function(a, b) {
      return a == b;
    },
    "===": function(a, b) {
      return a === b;
    },
    "!=": function(a, b) {
      return a != b;
    },
    "!==": function(a, b) {
      return a !== b;
    },
    ">": function(a, b) {
      return a > b;
    },
    ">=": function(a, b) {
      return a >= b;
    },
    "<": function(a, b, c) {
      return (c === undefined) ? a < b : (a < b) && (b < c);
    },
    "<=": function(a, b, c) {
      return (c === undefined) ? a <= b : (a <= b) && (b <= c);
    },
    "!!": function(a) {
      return jsonLogic.truthy(a);
    },
    "!": function(a) {
      return !jsonLogic.truthy(a);
    },
    "%": function(a, b) {
      return a % b;
    },
    "log": function(a) {
      console.log(a); return a;
    },
    "in": function(a, b) {
      if(typeof b.indexOf === "undefined") return false;
      return (b.indexOf(a) !== -1);
    },
    "cat": function() {
      return Array.prototype.join.call(arguments, "");
    },
    "+": function() {
      return Array.prototype.reduce.call(arguments, function(a, b) {
        return parseFloat(a, 10) + parseFloat(b, 10);
      }, 0);
    },
    "*": function() {
      return Array.prototype.reduce.call(arguments, function(a, b) {
        return parseFloat(a, 10) * parseFloat(b, 10);
      });
    },
    "-": function(a, b) {
      if(b === undefined) {
        return -a;
      }else{
        return a - b;
      }
    },
    "/": function(a, b) { return a / b; },
    "min": function() {
      return Math.min.apply(this, arguments);
    },
    "max": function() {
      return Math.max.apply(this, arguments);
    },
    "merge": function() {
      return Array.prototype.reduce.call(arguments, function(a, b) {
        return a.concat(b);
      }, []);
    },
    "var": function(a, b) {
      var not_found = (b === undefined) ? null : b;
      var sub_props = String(a).split(".");
      var data = this;
      for(var i = 0; i < sub_props.length; i++) {
        // Descending into data
        data = data[sub_props[i]];
        if(data === undefined) {
          return not_found;
        }
      }
      return data;
    },
    "missing": function() {
      /*
      Missing can receive many keys as many arguments, like {"missing:[1,2]}
      Missing can also receive *one* argument that is an array of keys,
      which typically happens if it's actually acting on the output of another command
      (like 'if' or 'merge')
      */

      var missing = [];
      var keys = Array.isArray(arguments[0]) ? arguments[0] : arguments;

      for(var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = jsonLogic.apply({"var": key}, this);
        if(value === null || value === "") {
          missing.push(key);
        }
      }

      return missing;
    },
    "missing_some": function(need_count, options) {
      // missing_some takes two arguments, how many (minimum) items must be present, and an array of keys (just like 'missing') to check for presence.
      var are_missing = jsonLogic.apply({"missing": options}, this);

      if(options.length - are_missing.length >= need_count) {
        return [];
      }else{
        return are_missing;
      }
    },
    "method": function(obj, method, args) {
      return obj[method].apply(obj, args);
    },

  };

  jsonLogic.is_logic = function(logic) {
    return (
      logic !== null && typeof logic === "object" && ! Array.isArray(logic)
    );
  };

  /*
  This helper will defer to the JsonLogic spec as a tie-breaker when different language interpreters define different behavior for the truthiness of primitives.  E.g., PHP considers empty arrays to be falsy, but Javascript considers them to be truthy. JsonLogic, as an ecosystem, needs one consistent answer.

  Literal | JS    |  PHP  |  JsonLogic
  --------+-------+-------+---------------
  []      | true  | false | false
  "0"     | true  | false | true
  */
  jsonLogic.truthy = function(value) {
    if(Array.isArray(value) && value.length === 0) {
      return false;
    }
    return !! value;
  };


  jsonLogic.get_operator = function(logic){
    return Object.keys(logic)[0];
  };

  jsonLogic.get_values = function(logic){
    return logic[ jsonLogic.get_operator(logic) ];
  };

  jsonLogic.apply = function(logic, data) {
    // Does this array contain logic? Only one way to find out.
    if(Array.isArray(logic)) {
      return logic.map(function(l) {
        return jsonLogic.apply(l, data);
      });
    }
    // You've recursed to a primitive, stop!
    if( ! jsonLogic.is_logic(logic) ) {
      return logic;
    }

    data = data || {};

    var op = jsonLogic.get_operator(logic);
    var values = logic[op];
    var i;
    var current;

    // easy syntax for unary operators, like {"var" : "x"} instead of strict {"var" : ["x"]}
    if( ! Array.isArray(values)) {
      values = [values];
    }

    // 'if', 'and', and 'or' violate the normal rule of depth-first calculating consequents, let each manage recursion as needed.
    if(op === "if" || op == "?:") {
      /* 'if' should be called with a odd number of parameters, 3 or greater
      This works on the pattern:
      if( 0 ){ 1 }else{ 2 };
      if( 0 ){ 1 }else if( 2 ){ 3 }else{ 4 };
      if( 0 ){ 1 }else if( 2 ){ 3 }else if( 4 ){ 5 }else{ 6 };

      The implementation is:
      For pairs of values (0,1 then 2,3 then 4,5 etc)
      If the first evaluates truthy, evaluate and return the second
      If the first evaluates falsy, jump to the next pair (e.g, 0,1 to 2,3)
      given one parameter, evaluate and return it. (it's an Else and all the If/ElseIf were false)
      given 0 parameters, return NULL (not great practice, but there was no Else)
      */
      for(i = 0; i < values.length - 1; i += 2) {
        if( jsonLogic.truthy( jsonLogic.apply(values[i], data) ) ) {
          return jsonLogic.apply(values[i+1], data);
        }
      }
      if(values.length === i+1) return jsonLogic.apply(values[i], data);
      return null;
    }else if(op === "and") { // Return first falsy, or last
      for(i=0; i < values.length; i+=1) {
        current = jsonLogic.apply(values[i], data);
        if( ! jsonLogic.truthy(current)) {
          return current;
        }
      }
      return current; // Last
    }else if(op === "or") {// Return first truthy, or last
      for(i=0; i < values.length; i+=1) {
        current = jsonLogic.apply(values[i], data);
        if( jsonLogic.truthy(current) ) {
          return current;
        }
      }
      return current; // Last
    }


    // Everyone else gets immediate depth-first recursion
    values = values.map(function(val) {
      return jsonLogic.apply(val, data);
    });


    // The operation is called with "data" bound to its "this" and "values" passed as arguments.
    // Structured commands like % or > can name formal arguments while flexible commands (like missing or merge) can operate on the pseudo-array arguments
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments
    if(typeof operations[op] === "function") {
      return operations[op].apply(data, values);
    }else if(op.indexOf(".") > 0) { // Contains a dot, and not in the 0th position
      var sub_ops = String(op).split(".");
      var operation = operations;
      for(i = 0; i < sub_ops.length; i++) {
        // Descending into operations
        operation = operation[sub_ops[i]];
        if(operation === undefined) {
          throw new Error("Unrecognized operation " + op +
          " (failed at " + sub_ops.slice(0, i+1).join(".") + ")");
        }
      }

      return operation.apply(data, values);
    }

    throw new Error("Unrecognized operation " + op );
  };

  jsonLogic.uses_data = function(logic) {
    var collection = [];

    if( jsonLogic.is_logic(logic) ) {
      var op = jsonLogic.get_operator(logic);
      var values = logic[op];

      if( ! Array.isArray(values)) {
        values = [values];
      }

      if(op === "var") {
        // This doesn't cover the case where the arg to var is itself a rule.
        collection.push(values[0]);
      }else{
        // Recursion!
        values.map(function(val) {
          collection.push.apply(collection, jsonLogic.uses_data(val) );
        });
      }
    }

    return arrayUnique(collection);
  };

  jsonLogic.add_operation = function(name, code) {
    operations[name] = code;
  };


  jsonLogic.rule_like = function(rule, pattern){
		//console.log("Is ". JSON.stringify(rule) . " like " . JSON.stringify(pattern) . "?");
	  if(pattern === rule){ return true; } //TODO : Deep object equivalency?
	  if(pattern === "@"){ return true; } //Wildcard!
	  if(pattern === "number"){ return (typeof rule === 'number'); }
	  if(pattern === "string"){ return (typeof rule === 'string'); }
	  if(pattern === "array"){
      //!logic test might be superfluous in JavaScript
      return Array.isArray(rule) && ! jsonLogic.is_logic(rule);
    }

	  if(jsonLogic.is_logic(pattern)){
	    if(jsonLogic.is_logic(rule)){
	      var pattern_op = jsonLogic.get_operator(pattern);
        var rule_op = jsonLogic.get_operator(rule);

	      if(pattern_op === "@" || pattern_op === rule_op){
					//echo "\nOperators match, go deeper\n";
	        return jsonLogic.rule_like(
						jsonLogic.get_values(rule, false),
						jsonLogic.get_values(pattern, false)
					);
	      }

	    }
	    return false; //pattern is logic, rule isn't, can't be eq
	  }

	  if(Array.isArray(pattern)){
	    if(Array.isArray(rule)){
	      if(pattern.length !== rule.length){ return false; }
				/*
					Note, array order MATTERS, because we're using this array test logic to consider arguments, where order can matter. (e.g., + is commutative, but '-' or 'if' or 'var' are NOT)
				*/
	      for(var i = 0 ; i < pattern.length ; i += 1){
	        //If any fail, we fail
	        if( ! jsonLogic.rule_like(rule[i], pattern[i])){ return false; }
	      }
	      return true; //If they *all* passed, we pass
	    }else{
	      return false; //Pattern is array, rule isn't
	    }

	  }

		//Not logic, not array, not a === match for rule.
		return false;
	};



  return jsonLogic;
}));

},{}],5:[function(_dereq_,module,exports){
var getNative = _dereq_('./_getNative'),
    root = _dereq_('./_root');

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;

},{"./_getNative":105,"./_root":150}],6:[function(_dereq_,module,exports){
var hashClear = _dereq_('./_hashClear'),
    hashDelete = _dereq_('./_hashDelete'),
    hashGet = _dereq_('./_hashGet'),
    hashHas = _dereq_('./_hashHas'),
    hashSet = _dereq_('./_hashSet');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;

},{"./_hashClear":115,"./_hashDelete":116,"./_hashGet":117,"./_hashHas":118,"./_hashSet":119}],7:[function(_dereq_,module,exports){
var listCacheClear = _dereq_('./_listCacheClear'),
    listCacheDelete = _dereq_('./_listCacheDelete'),
    listCacheGet = _dereq_('./_listCacheGet'),
    listCacheHas = _dereq_('./_listCacheHas'),
    listCacheSet = _dereq_('./_listCacheSet');

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;

},{"./_listCacheClear":130,"./_listCacheDelete":131,"./_listCacheGet":132,"./_listCacheHas":133,"./_listCacheSet":134}],8:[function(_dereq_,module,exports){
var getNative = _dereq_('./_getNative'),
    root = _dereq_('./_root');

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;

},{"./_getNative":105,"./_root":150}],9:[function(_dereq_,module,exports){
var mapCacheClear = _dereq_('./_mapCacheClear'),
    mapCacheDelete = _dereq_('./_mapCacheDelete'),
    mapCacheGet = _dereq_('./_mapCacheGet'),
    mapCacheHas = _dereq_('./_mapCacheHas'),
    mapCacheSet = _dereq_('./_mapCacheSet');

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;

},{"./_mapCacheClear":135,"./_mapCacheDelete":136,"./_mapCacheGet":137,"./_mapCacheHas":138,"./_mapCacheSet":139}],10:[function(_dereq_,module,exports){
var getNative = _dereq_('./_getNative'),
    root = _dereq_('./_root');

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;

},{"./_getNative":105,"./_root":150}],11:[function(_dereq_,module,exports){
var getNative = _dereq_('./_getNative'),
    root = _dereq_('./_root');

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;

},{"./_getNative":105,"./_root":150}],12:[function(_dereq_,module,exports){
var MapCache = _dereq_('./_MapCache'),
    setCacheAdd = _dereq_('./_setCacheAdd'),
    setCacheHas = _dereq_('./_setCacheHas');

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;

},{"./_MapCache":9,"./_setCacheAdd":151,"./_setCacheHas":152}],13:[function(_dereq_,module,exports){
var ListCache = _dereq_('./_ListCache'),
    stackClear = _dereq_('./_stackClear'),
    stackDelete = _dereq_('./_stackDelete'),
    stackGet = _dereq_('./_stackGet'),
    stackHas = _dereq_('./_stackHas'),
    stackSet = _dereq_('./_stackSet');

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;

},{"./_ListCache":7,"./_stackClear":156,"./_stackDelete":157,"./_stackGet":158,"./_stackHas":159,"./_stackSet":160}],14:[function(_dereq_,module,exports){
var root = _dereq_('./_root');

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;

},{"./_root":150}],15:[function(_dereq_,module,exports){
var root = _dereq_('./_root');

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;

},{"./_root":150}],16:[function(_dereq_,module,exports){
var getNative = _dereq_('./_getNative'),
    root = _dereq_('./_root');

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;

},{"./_getNative":105,"./_root":150}],17:[function(_dereq_,module,exports){
/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
function addMapEntry(map, pair) {
  // Don't return `map.set` because it's not chainable in IE 11.
  map.set(pair[0], pair[1]);
  return map;
}

module.exports = addMapEntry;

},{}],18:[function(_dereq_,module,exports){
/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
function addSetEntry(set, value) {
  // Don't return `set.add` because it's not chainable in IE 11.
  set.add(value);
  return set;
}

module.exports = addSetEntry;

},{}],19:[function(_dereq_,module,exports){
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;

},{}],20:[function(_dereq_,module,exports){
/**
 * A specialized version of `baseAggregator` for arrays.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */
function arrayAggregator(array, setter, iteratee, accumulator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    var value = array[index];
    setter(accumulator, value, iteratee(value), array);
  }
  return accumulator;
}

module.exports = arrayAggregator;

},{}],21:[function(_dereq_,module,exports){
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;

},{}],22:[function(_dereq_,module,exports){
/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;

},{}],23:[function(_dereq_,module,exports){
var baseTimes = _dereq_('./_baseTimes'),
    isArguments = _dereq_('./isArguments'),
    isArray = _dereq_('./isArray'),
    isBuffer = _dereq_('./isBuffer'),
    isIndex = _dereq_('./_isIndex'),
    isTypedArray = _dereq_('./isTypedArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;

},{"./_baseTimes":69,"./_isIndex":123,"./isArguments":181,"./isArray":182,"./isBuffer":185,"./isTypedArray":193}],24:[function(_dereq_,module,exports){
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;

},{}],25:[function(_dereq_,module,exports){
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;

},{}],26:[function(_dereq_,module,exports){
/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

module.exports = arrayReduce;

},{}],27:[function(_dereq_,module,exports){
/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;

},{}],28:[function(_dereq_,module,exports){
/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string) {
  return string.split('');
}

module.exports = asciiToArray;

},{}],29:[function(_dereq_,module,exports){
/** Used to match words composed of alphanumeric characters. */
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

/**
 * Splits an ASCII `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}

module.exports = asciiWords;

},{}],30:[function(_dereq_,module,exports){
var baseAssignValue = _dereq_('./_baseAssignValue'),
    eq = _dereq_('./eq');

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;

},{"./_baseAssignValue":36,"./eq":175}],31:[function(_dereq_,module,exports){
var baseAssignValue = _dereq_('./_baseAssignValue'),
    eq = _dereq_('./eq');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

},{"./_baseAssignValue":36,"./eq":175}],32:[function(_dereq_,module,exports){
var eq = _dereq_('./eq');

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;

},{"./eq":175}],33:[function(_dereq_,module,exports){
var baseEach = _dereq_('./_baseEach');

/**
 * Aggregates elements of `collection` on `accumulator` with keys transformed
 * by `iteratee` and values set by `setter`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */
function baseAggregator(collection, setter, iteratee, accumulator) {
  baseEach(collection, function(value, key, collection) {
    setter(accumulator, value, iteratee(value), collection);
  });
  return accumulator;
}

module.exports = baseAggregator;

},{"./_baseEach":39}],34:[function(_dereq_,module,exports){
var copyObject = _dereq_('./_copyObject'),
    keys = _dereq_('./keys');

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;

},{"./_copyObject":85,"./keys":194}],35:[function(_dereq_,module,exports){
var copyObject = _dereq_('./_copyObject'),
    keysIn = _dereq_('./keysIn');

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;

},{"./_copyObject":85,"./keysIn":195}],36:[function(_dereq_,module,exports){
var defineProperty = _dereq_('./_defineProperty');

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

},{"./_defineProperty":96}],37:[function(_dereq_,module,exports){
var Stack = _dereq_('./_Stack'),
    arrayEach = _dereq_('./_arrayEach'),
    assignValue = _dereq_('./_assignValue'),
    baseAssign = _dereq_('./_baseAssign'),
    baseAssignIn = _dereq_('./_baseAssignIn'),
    cloneBuffer = _dereq_('./_cloneBuffer'),
    copyArray = _dereq_('./_copyArray'),
    copySymbols = _dereq_('./_copySymbols'),
    copySymbolsIn = _dereq_('./_copySymbolsIn'),
    getAllKeys = _dereq_('./_getAllKeys'),
    getAllKeysIn = _dereq_('./_getAllKeysIn'),
    getTag = _dereq_('./_getTag'),
    initCloneArray = _dereq_('./_initCloneArray'),
    initCloneByTag = _dereq_('./_initCloneByTag'),
    initCloneObject = _dereq_('./_initCloneObject'),
    isArray = _dereq_('./isArray'),
    isBuffer = _dereq_('./isBuffer'),
    isObject = _dereq_('./isObject'),
    keys = _dereq_('./keys');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, baseClone, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;

},{"./_Stack":13,"./_arrayEach":21,"./_assignValue":31,"./_baseAssign":34,"./_baseAssignIn":35,"./_cloneBuffer":77,"./_copyArray":84,"./_copySymbols":86,"./_copySymbolsIn":87,"./_getAllKeys":101,"./_getAllKeysIn":102,"./_getTag":110,"./_initCloneArray":120,"./_initCloneByTag":121,"./_initCloneObject":122,"./isArray":182,"./isBuffer":185,"./isObject":189,"./keys":194}],38:[function(_dereq_,module,exports){
var isObject = _dereq_('./isObject');

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;

},{"./isObject":189}],39:[function(_dereq_,module,exports){
var baseForOwn = _dereq_('./_baseForOwn'),
    createBaseEach = _dereq_('./_createBaseEach');

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;

},{"./_baseForOwn":42,"./_createBaseEach":91}],40:[function(_dereq_,module,exports){
var baseEach = _dereq_('./_baseEach');

/**
 * The base implementation of `_.filter` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function baseFilter(collection, predicate) {
  var result = [];
  baseEach(collection, function(value, index, collection) {
    if (predicate(value, index, collection)) {
      result.push(value);
    }
  });
  return result;
}

module.exports = baseFilter;

},{"./_baseEach":39}],41:[function(_dereq_,module,exports){
var createBaseFor = _dereq_('./_createBaseFor');

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;

},{"./_createBaseFor":92}],42:[function(_dereq_,module,exports){
var baseFor = _dereq_('./_baseFor'),
    keys = _dereq_('./keys');

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;

},{"./_baseFor":41,"./keys":194}],43:[function(_dereq_,module,exports){
var castPath = _dereq_('./_castPath'),
    toKey = _dereq_('./_toKey');

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;

},{"./_castPath":74,"./_toKey":163}],44:[function(_dereq_,module,exports){
var arrayPush = _dereq_('./_arrayPush'),
    isArray = _dereq_('./isArray');

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;

},{"./_arrayPush":25,"./isArray":182}],45:[function(_dereq_,module,exports){
var Symbol = _dereq_('./_Symbol'),
    getRawTag = _dereq_('./_getRawTag'),
    objectToString = _dereq_('./_objectToString');

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;

},{"./_Symbol":14,"./_getRawTag":107,"./_objectToString":147}],46:[function(_dereq_,module,exports){
/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;

},{}],47:[function(_dereq_,module,exports){
var baseGetTag = _dereq_('./_baseGetTag'),
    isObjectLike = _dereq_('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

},{"./_baseGetTag":45,"./isObjectLike":190}],48:[function(_dereq_,module,exports){
var baseIsEqualDeep = _dereq_('./_baseIsEqualDeep'),
    isObjectLike = _dereq_('./isObjectLike');

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;

},{"./_baseIsEqualDeep":49,"./isObjectLike":190}],49:[function(_dereq_,module,exports){
var Stack = _dereq_('./_Stack'),
    equalArrays = _dereq_('./_equalArrays'),
    equalByTag = _dereq_('./_equalByTag'),
    equalObjects = _dereq_('./_equalObjects'),
    getTag = _dereq_('./_getTag'),
    isArray = _dereq_('./isArray'),
    isBuffer = _dereq_('./isBuffer'),
    isTypedArray = _dereq_('./isTypedArray');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;

},{"./_Stack":13,"./_equalArrays":97,"./_equalByTag":98,"./_equalObjects":99,"./_getTag":110,"./isArray":182,"./isBuffer":185,"./isTypedArray":193}],50:[function(_dereq_,module,exports){
var Stack = _dereq_('./_Stack'),
    baseIsEqual = _dereq_('./_baseIsEqual');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;

},{"./_Stack":13,"./_baseIsEqual":48}],51:[function(_dereq_,module,exports){
var isFunction = _dereq_('./isFunction'),
    isMasked = _dereq_('./_isMasked'),
    isObject = _dereq_('./isObject'),
    toSource = _dereq_('./_toSource');

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

},{"./_isMasked":127,"./_toSource":164,"./isFunction":186,"./isObject":189}],52:[function(_dereq_,module,exports){
var baseGetTag = _dereq_('./_baseGetTag'),
    isLength = _dereq_('./isLength'),
    isObjectLike = _dereq_('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

},{"./_baseGetTag":45,"./isLength":187,"./isObjectLike":190}],53:[function(_dereq_,module,exports){
var baseMatches = _dereq_('./_baseMatches'),
    baseMatchesProperty = _dereq_('./_baseMatchesProperty'),
    identity = _dereq_('./identity'),
    isArray = _dereq_('./isArray'),
    property = _dereq_('./property');

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;

},{"./_baseMatches":57,"./_baseMatchesProperty":58,"./identity":180,"./isArray":182,"./property":202}],54:[function(_dereq_,module,exports){
var isPrototype = _dereq_('./_isPrototype'),
    nativeKeys = _dereq_('./_nativeKeys');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;

},{"./_isPrototype":128,"./_nativeKeys":144}],55:[function(_dereq_,module,exports){
var isObject = _dereq_('./isObject'),
    isPrototype = _dereq_('./_isPrototype'),
    nativeKeysIn = _dereq_('./_nativeKeysIn');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;

},{"./_isPrototype":128,"./_nativeKeysIn":145,"./isObject":189}],56:[function(_dereq_,module,exports){
var baseEach = _dereq_('./_baseEach'),
    isArrayLike = _dereq_('./isArrayLike');

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

module.exports = baseMap;

},{"./_baseEach":39,"./isArrayLike":183}],57:[function(_dereq_,module,exports){
var baseIsMatch = _dereq_('./_baseIsMatch'),
    getMatchData = _dereq_('./_getMatchData'),
    matchesStrictComparable = _dereq_('./_matchesStrictComparable');

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;

},{"./_baseIsMatch":50,"./_getMatchData":104,"./_matchesStrictComparable":141}],58:[function(_dereq_,module,exports){
var baseIsEqual = _dereq_('./_baseIsEqual'),
    get = _dereq_('./get'),
    hasIn = _dereq_('./hasIn'),
    isKey = _dereq_('./_isKey'),
    isStrictComparable = _dereq_('./_isStrictComparable'),
    matchesStrictComparable = _dereq_('./_matchesStrictComparable'),
    toKey = _dereq_('./_toKey');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;

},{"./_baseIsEqual":48,"./_isKey":125,"./_isStrictComparable":129,"./_matchesStrictComparable":141,"./_toKey":163,"./get":177,"./hasIn":179}],59:[function(_dereq_,module,exports){
var Stack = _dereq_('./_Stack'),
    assignMergeValue = _dereq_('./_assignMergeValue'),
    baseFor = _dereq_('./_baseFor'),
    baseMergeDeep = _dereq_('./_baseMergeDeep'),
    isObject = _dereq_('./isObject'),
    keysIn = _dereq_('./keysIn');

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    if (isObject(srcValue)) {
      stack || (stack = new Stack);
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(object[key], srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;

},{"./_Stack":13,"./_assignMergeValue":30,"./_baseFor":41,"./_baseMergeDeep":60,"./isObject":189,"./keysIn":195}],60:[function(_dereq_,module,exports){
var assignMergeValue = _dereq_('./_assignMergeValue'),
    cloneBuffer = _dereq_('./_cloneBuffer'),
    cloneTypedArray = _dereq_('./_cloneTypedArray'),
    copyArray = _dereq_('./_copyArray'),
    initCloneObject = _dereq_('./_initCloneObject'),
    isArguments = _dereq_('./isArguments'),
    isArray = _dereq_('./isArray'),
    isArrayLikeObject = _dereq_('./isArrayLikeObject'),
    isBuffer = _dereq_('./isBuffer'),
    isFunction = _dereq_('./isFunction'),
    isObject = _dereq_('./isObject'),
    isPlainObject = _dereq_('./isPlainObject'),
    isTypedArray = _dereq_('./isTypedArray'),
    toPlainObject = _dereq_('./toPlainObject');

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = object[key],
      srcValue = source[key],
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;

},{"./_assignMergeValue":30,"./_cloneBuffer":77,"./_cloneTypedArray":83,"./_copyArray":84,"./_initCloneObject":122,"./isArguments":181,"./isArray":182,"./isArrayLikeObject":184,"./isBuffer":185,"./isFunction":186,"./isObject":189,"./isPlainObject":191,"./isTypedArray":193,"./toPlainObject":206}],61:[function(_dereq_,module,exports){
var baseGet = _dereq_('./_baseGet'),
    baseSet = _dereq_('./_baseSet'),
    castPath = _dereq_('./_castPath');

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}

module.exports = basePickBy;

},{"./_baseGet":43,"./_baseSet":66,"./_castPath":74}],62:[function(_dereq_,module,exports){
/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;

},{}],63:[function(_dereq_,module,exports){
var baseGet = _dereq_('./_baseGet');

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;

},{"./_baseGet":43}],64:[function(_dereq_,module,exports){
/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

module.exports = basePropertyOf;

},{}],65:[function(_dereq_,module,exports){
var identity = _dereq_('./identity'),
    overRest = _dereq_('./_overRest'),
    setToString = _dereq_('./_setToString');

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;

},{"./_overRest":149,"./_setToString":154,"./identity":180}],66:[function(_dereq_,module,exports){
var assignValue = _dereq_('./_assignValue'),
    castPath = _dereq_('./_castPath'),
    isIndex = _dereq_('./_isIndex'),
    isObject = _dereq_('./isObject'),
    toKey = _dereq_('./_toKey');

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

module.exports = baseSet;

},{"./_assignValue":31,"./_castPath":74,"./_isIndex":123,"./_toKey":163,"./isObject":189}],67:[function(_dereq_,module,exports){
var constant = _dereq_('./constant'),
    defineProperty = _dereq_('./_defineProperty'),
    identity = _dereq_('./identity');

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;

},{"./_defineProperty":96,"./constant":172,"./identity":180}],68:[function(_dereq_,module,exports){
/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

module.exports = baseSlice;

},{}],69:[function(_dereq_,module,exports){
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

},{}],70:[function(_dereq_,module,exports){
var Symbol = _dereq_('./_Symbol'),
    arrayMap = _dereq_('./_arrayMap'),
    isArray = _dereq_('./isArray'),
    isSymbol = _dereq_('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;

},{"./_Symbol":14,"./_arrayMap":24,"./isArray":182,"./isSymbol":192}],71:[function(_dereq_,module,exports){
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;

},{}],72:[function(_dereq_,module,exports){
/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;

},{}],73:[function(_dereq_,module,exports){
var identity = _dereq_('./identity');

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */
function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

module.exports = castFunction;

},{"./identity":180}],74:[function(_dereq_,module,exports){
var isArray = _dereq_('./isArray'),
    isKey = _dereq_('./_isKey'),
    stringToPath = _dereq_('./_stringToPath'),
    toString = _dereq_('./toString');

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;

},{"./_isKey":125,"./_stringToPath":162,"./isArray":182,"./toString":207}],75:[function(_dereq_,module,exports){
var baseSlice = _dereq_('./_baseSlice');

/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : baseSlice(array, start, end);
}

module.exports = castSlice;

},{"./_baseSlice":68}],76:[function(_dereq_,module,exports){
var Uint8Array = _dereq_('./_Uint8Array');

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

},{"./_Uint8Array":15}],77:[function(_dereq_,module,exports){
var root = _dereq_('./_root');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

},{"./_root":150}],78:[function(_dereq_,module,exports){
var cloneArrayBuffer = _dereq_('./_cloneArrayBuffer');

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;

},{"./_cloneArrayBuffer":76}],79:[function(_dereq_,module,exports){
var addMapEntry = _dereq_('./_addMapEntry'),
    arrayReduce = _dereq_('./_arrayReduce'),
    mapToArray = _dereq_('./_mapToArray');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1;

/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */
function cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map);
  return arrayReduce(array, addMapEntry, new map.constructor);
}

module.exports = cloneMap;

},{"./_addMapEntry":17,"./_arrayReduce":26,"./_mapToArray":140}],80:[function(_dereq_,module,exports){
/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;

},{}],81:[function(_dereq_,module,exports){
var addSetEntry = _dereq_('./_addSetEntry'),
    arrayReduce = _dereq_('./_arrayReduce'),
    setToArray = _dereq_('./_setToArray');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1;

/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */
function cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set);
  return arrayReduce(array, addSetEntry, new set.constructor);
}

module.exports = cloneSet;

},{"./_addSetEntry":18,"./_arrayReduce":26,"./_setToArray":153}],82:[function(_dereq_,module,exports){
var Symbol = _dereq_('./_Symbol');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;

},{"./_Symbol":14}],83:[function(_dereq_,module,exports){
var cloneArrayBuffer = _dereq_('./_cloneArrayBuffer');

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

},{"./_cloneArrayBuffer":76}],84:[function(_dereq_,module,exports){
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;

},{}],85:[function(_dereq_,module,exports){
var assignValue = _dereq_('./_assignValue'),
    baseAssignValue = _dereq_('./_baseAssignValue');

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;

},{"./_assignValue":31,"./_baseAssignValue":36}],86:[function(_dereq_,module,exports){
var copyObject = _dereq_('./_copyObject'),
    getSymbols = _dereq_('./_getSymbols');

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;

},{"./_copyObject":85,"./_getSymbols":108}],87:[function(_dereq_,module,exports){
var copyObject = _dereq_('./_copyObject'),
    getSymbolsIn = _dereq_('./_getSymbolsIn');

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;

},{"./_copyObject":85,"./_getSymbolsIn":109}],88:[function(_dereq_,module,exports){
var root = _dereq_('./_root');

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;

},{"./_root":150}],89:[function(_dereq_,module,exports){
var arrayAggregator = _dereq_('./_arrayAggregator'),
    baseAggregator = _dereq_('./_baseAggregator'),
    baseIteratee = _dereq_('./_baseIteratee'),
    isArray = _dereq_('./isArray');

/**
 * Creates a function like `_.groupBy`.
 *
 * @private
 * @param {Function} setter The function to set accumulator values.
 * @param {Function} [initializer] The accumulator object initializer.
 * @returns {Function} Returns the new aggregator function.
 */
function createAggregator(setter, initializer) {
  return function(collection, iteratee) {
    var func = isArray(collection) ? arrayAggregator : baseAggregator,
        accumulator = initializer ? initializer() : {};

    return func(collection, setter, baseIteratee(iteratee, 2), accumulator);
  };
}

module.exports = createAggregator;

},{"./_arrayAggregator":20,"./_baseAggregator":33,"./_baseIteratee":53,"./isArray":182}],90:[function(_dereq_,module,exports){
var baseRest = _dereq_('./_baseRest'),
    isIterateeCall = _dereq_('./_isIterateeCall');

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;

},{"./_baseRest":65,"./_isIterateeCall":124}],91:[function(_dereq_,module,exports){
var isArrayLike = _dereq_('./isArrayLike');

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;

},{"./isArrayLike":183}],92:[function(_dereq_,module,exports){
/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;

},{}],93:[function(_dereq_,module,exports){
var castSlice = _dereq_('./_castSlice'),
    hasUnicode = _dereq_('./_hasUnicode'),
    stringToArray = _dereq_('./_stringToArray'),
    toString = _dereq_('./toString');

/**
 * Creates a function like `_.lowerFirst`.
 *
 * @private
 * @param {string} methodName The name of the `String` case method to use.
 * @returns {Function} Returns the new case function.
 */
function createCaseFirst(methodName) {
  return function(string) {
    string = toString(string);

    var strSymbols = hasUnicode(string)
      ? stringToArray(string)
      : undefined;

    var chr = strSymbols
      ? strSymbols[0]
      : string.charAt(0);

    var trailing = strSymbols
      ? castSlice(strSymbols, 1).join('')
      : string.slice(1);

    return chr[methodName]() + trailing;
  };
}

module.exports = createCaseFirst;

},{"./_castSlice":75,"./_hasUnicode":113,"./_stringToArray":161,"./toString":207}],94:[function(_dereq_,module,exports){
var arrayReduce = _dereq_('./_arrayReduce'),
    deburr = _dereq_('./deburr'),
    words = _dereq_('./words');

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]";

/** Used to match apostrophes. */
var reApos = RegExp(rsApos, 'g');

/**
 * Creates a function like `_.camelCase`.
 *
 * @private
 * @param {Function} callback The function to combine each word.
 * @returns {Function} Returns the new compounder function.
 */
function createCompounder(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
  };
}

module.exports = createCompounder;

},{"./_arrayReduce":26,"./deburr":173,"./words":209}],95:[function(_dereq_,module,exports){
var basePropertyOf = _dereq_('./_basePropertyOf');

/** Used to map Latin Unicode letters to basic Latin letters. */
var deburredLetters = {
  // Latin-1 Supplement block.
  '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
  '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
  '\xc7': 'C',  '\xe7': 'c',
  '\xd0': 'D',  '\xf0': 'd',
  '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
  '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
  '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
  '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
  '\xd1': 'N',  '\xf1': 'n',
  '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
  '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
  '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
  '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
  '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
  '\xc6': 'Ae', '\xe6': 'ae',
  '\xde': 'Th', '\xfe': 'th',
  '\xdf': 'ss',
  // Latin Extended-A block.
  '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
  '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
  '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
  '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
  '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
  '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
  '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
  '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
  '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
  '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
  '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
  '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
  '\u0134': 'J',  '\u0135': 'j',
  '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
  '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
  '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
  '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
  '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
  '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
  '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
  '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
  '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
  '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
  '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
  '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
  '\u0163': 't',  '\u0165': 't', '\u0167': 't',
  '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
  '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
  '\u0174': 'W',  '\u0175': 'w',
  '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
  '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
  '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
  '\u0132': 'IJ', '\u0133': 'ij',
  '\u0152': 'Oe', '\u0153': 'oe',
  '\u0149': "'n", '\u017f': 's'
};

/**
 * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
 * letters to basic Latin letters.
 *
 * @private
 * @param {string} letter The matched letter to deburr.
 * @returns {string} Returns the deburred letter.
 */
var deburrLetter = basePropertyOf(deburredLetters);

module.exports = deburrLetter;

},{"./_basePropertyOf":64}],96:[function(_dereq_,module,exports){
var getNative = _dereq_('./_getNative');

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;

},{"./_getNative":105}],97:[function(_dereq_,module,exports){
var SetCache = _dereq_('./_SetCache'),
    arraySome = _dereq_('./_arraySome'),
    cacheHas = _dereq_('./_cacheHas');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;

},{"./_SetCache":12,"./_arraySome":27,"./_cacheHas":72}],98:[function(_dereq_,module,exports){
var Symbol = _dereq_('./_Symbol'),
    Uint8Array = _dereq_('./_Uint8Array'),
    eq = _dereq_('./eq'),
    equalArrays = _dereq_('./_equalArrays'),
    mapToArray = _dereq_('./_mapToArray'),
    setToArray = _dereq_('./_setToArray');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;

},{"./_Symbol":14,"./_Uint8Array":15,"./_equalArrays":97,"./_mapToArray":140,"./_setToArray":153,"./eq":175}],99:[function(_dereq_,module,exports){
var getAllKeys = _dereq_('./_getAllKeys');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;

},{"./_getAllKeys":101}],100:[function(_dereq_,module,exports){
(function (global){
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],101:[function(_dereq_,module,exports){
var baseGetAllKeys = _dereq_('./_baseGetAllKeys'),
    getSymbols = _dereq_('./_getSymbols'),
    keys = _dereq_('./keys');

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;

},{"./_baseGetAllKeys":44,"./_getSymbols":108,"./keys":194}],102:[function(_dereq_,module,exports){
var baseGetAllKeys = _dereq_('./_baseGetAllKeys'),
    getSymbolsIn = _dereq_('./_getSymbolsIn'),
    keysIn = _dereq_('./keysIn');

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;

},{"./_baseGetAllKeys":44,"./_getSymbolsIn":109,"./keysIn":195}],103:[function(_dereq_,module,exports){
var isKeyable = _dereq_('./_isKeyable');

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;

},{"./_isKeyable":126}],104:[function(_dereq_,module,exports){
var isStrictComparable = _dereq_('./_isStrictComparable'),
    keys = _dereq_('./keys');

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;

},{"./_isStrictComparable":129,"./keys":194}],105:[function(_dereq_,module,exports){
var baseIsNative = _dereq_('./_baseIsNative'),
    getValue = _dereq_('./_getValue');

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

},{"./_baseIsNative":51,"./_getValue":111}],106:[function(_dereq_,module,exports){
var overArg = _dereq_('./_overArg');

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;

},{"./_overArg":148}],107:[function(_dereq_,module,exports){
var Symbol = _dereq_('./_Symbol');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

},{"./_Symbol":14}],108:[function(_dereq_,module,exports){
var arrayFilter = _dereq_('./_arrayFilter'),
    stubArray = _dereq_('./stubArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;

},{"./_arrayFilter":22,"./stubArray":204}],109:[function(_dereq_,module,exports){
var arrayPush = _dereq_('./_arrayPush'),
    getPrototype = _dereq_('./_getPrototype'),
    getSymbols = _dereq_('./_getSymbols'),
    stubArray = _dereq_('./stubArray');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;

},{"./_arrayPush":25,"./_getPrototype":106,"./_getSymbols":108,"./stubArray":204}],110:[function(_dereq_,module,exports){
var DataView = _dereq_('./_DataView'),
    Map = _dereq_('./_Map'),
    Promise = _dereq_('./_Promise'),
    Set = _dereq_('./_Set'),
    WeakMap = _dereq_('./_WeakMap'),
    baseGetTag = _dereq_('./_baseGetTag'),
    toSource = _dereq_('./_toSource');

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;

},{"./_DataView":5,"./_Map":8,"./_Promise":10,"./_Set":11,"./_WeakMap":16,"./_baseGetTag":45,"./_toSource":164}],111:[function(_dereq_,module,exports){
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

},{}],112:[function(_dereq_,module,exports){
var castPath = _dereq_('./_castPath'),
    isArguments = _dereq_('./isArguments'),
    isArray = _dereq_('./isArray'),
    isIndex = _dereq_('./_isIndex'),
    isLength = _dereq_('./isLength'),
    toKey = _dereq_('./_toKey');

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;

},{"./_castPath":74,"./_isIndex":123,"./_toKey":163,"./isArguments":181,"./isArray":182,"./isLength":187}],113:[function(_dereq_,module,exports){
/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

module.exports = hasUnicode;

},{}],114:[function(_dereq_,module,exports){
/** Used to detect strings that need a more robust regexp to match words. */
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

/**
 * Checks if `string` contains a word composed of Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a word is found, else `false`.
 */
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}

module.exports = hasUnicodeWord;

},{}],115:[function(_dereq_,module,exports){
var nativeCreate = _dereq_('./_nativeCreate');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

},{"./_nativeCreate":143}],116:[function(_dereq_,module,exports){
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

},{}],117:[function(_dereq_,module,exports){
var nativeCreate = _dereq_('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

},{"./_nativeCreate":143}],118:[function(_dereq_,module,exports){
var nativeCreate = _dereq_('./_nativeCreate');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

},{"./_nativeCreate":143}],119:[function(_dereq_,module,exports){
var nativeCreate = _dereq_('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

},{"./_nativeCreate":143}],120:[function(_dereq_,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;

},{}],121:[function(_dereq_,module,exports){
var cloneArrayBuffer = _dereq_('./_cloneArrayBuffer'),
    cloneDataView = _dereq_('./_cloneDataView'),
    cloneMap = _dereq_('./_cloneMap'),
    cloneRegExp = _dereq_('./_cloneRegExp'),
    cloneSet = _dereq_('./_cloneSet'),
    cloneSymbol = _dereq_('./_cloneSymbol'),
    cloneTypedArray = _dereq_('./_cloneTypedArray');

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return cloneMap(object, isDeep, cloneFunc);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return cloneSet(object, isDeep, cloneFunc);

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;

},{"./_cloneArrayBuffer":76,"./_cloneDataView":78,"./_cloneMap":79,"./_cloneRegExp":80,"./_cloneSet":81,"./_cloneSymbol":82,"./_cloneTypedArray":83}],122:[function(_dereq_,module,exports){
var baseCreate = _dereq_('./_baseCreate'),
    getPrototype = _dereq_('./_getPrototype'),
    isPrototype = _dereq_('./_isPrototype');

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;

},{"./_baseCreate":38,"./_getPrototype":106,"./_isPrototype":128}],123:[function(_dereq_,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;

},{}],124:[function(_dereq_,module,exports){
var eq = _dereq_('./eq'),
    isArrayLike = _dereq_('./isArrayLike'),
    isIndex = _dereq_('./_isIndex'),
    isObject = _dereq_('./isObject');

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;

},{"./_isIndex":123,"./eq":175,"./isArrayLike":183,"./isObject":189}],125:[function(_dereq_,module,exports){
var isArray = _dereq_('./isArray'),
    isSymbol = _dereq_('./isSymbol');

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;

},{"./isArray":182,"./isSymbol":192}],126:[function(_dereq_,module,exports){
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;

},{}],127:[function(_dereq_,module,exports){
var coreJsData = _dereq_('./_coreJsData');

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;

},{"./_coreJsData":88}],128:[function(_dereq_,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;

},{}],129:[function(_dereq_,module,exports){
var isObject = _dereq_('./isObject');

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;

},{"./isObject":189}],130:[function(_dereq_,module,exports){
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

},{}],131:[function(_dereq_,module,exports){
var assocIndexOf = _dereq_('./_assocIndexOf');

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;

},{"./_assocIndexOf":32}],132:[function(_dereq_,module,exports){
var assocIndexOf = _dereq_('./_assocIndexOf');

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

},{"./_assocIndexOf":32}],133:[function(_dereq_,module,exports){
var assocIndexOf = _dereq_('./_assocIndexOf');

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

},{"./_assocIndexOf":32}],134:[function(_dereq_,module,exports){
var assocIndexOf = _dereq_('./_assocIndexOf');

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;

},{"./_assocIndexOf":32}],135:[function(_dereq_,module,exports){
var Hash = _dereq_('./_Hash'),
    ListCache = _dereq_('./_ListCache'),
    Map = _dereq_('./_Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;

},{"./_Hash":6,"./_ListCache":7,"./_Map":8}],136:[function(_dereq_,module,exports){
var getMapData = _dereq_('./_getMapData');

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

},{"./_getMapData":103}],137:[function(_dereq_,module,exports){
var getMapData = _dereq_('./_getMapData');

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

},{"./_getMapData":103}],138:[function(_dereq_,module,exports){
var getMapData = _dereq_('./_getMapData');

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

},{"./_getMapData":103}],139:[function(_dereq_,module,exports){
var getMapData = _dereq_('./_getMapData');

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

},{"./_getMapData":103}],140:[function(_dereq_,module,exports){
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;

},{}],141:[function(_dereq_,module,exports){
/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;

},{}],142:[function(_dereq_,module,exports){
var memoize = _dereq_('./memoize');

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;

},{"./memoize":197}],143:[function(_dereq_,module,exports){
var getNative = _dereq_('./_getNative');

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;

},{"./_getNative":105}],144:[function(_dereq_,module,exports){
var overArg = _dereq_('./_overArg');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;

},{"./_overArg":148}],145:[function(_dereq_,module,exports){
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;

},{}],146:[function(_dereq_,module,exports){
var freeGlobal = _dereq_('./_freeGlobal');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

},{"./_freeGlobal":100}],147:[function(_dereq_,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

},{}],148:[function(_dereq_,module,exports){
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

},{}],149:[function(_dereq_,module,exports){
var apply = _dereq_('./_apply');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

},{"./_apply":19}],150:[function(_dereq_,module,exports){
var freeGlobal = _dereq_('./_freeGlobal');

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

},{"./_freeGlobal":100}],151:[function(_dereq_,module,exports){
/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;

},{}],152:[function(_dereq_,module,exports){
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;

},{}],153:[function(_dereq_,module,exports){
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;

},{}],154:[function(_dereq_,module,exports){
var baseSetToString = _dereq_('./_baseSetToString'),
    shortOut = _dereq_('./_shortOut');

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;

},{"./_baseSetToString":67,"./_shortOut":155}],155:[function(_dereq_,module,exports){
/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

},{}],156:[function(_dereq_,module,exports){
var ListCache = _dereq_('./_ListCache');

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;

},{"./_ListCache":7}],157:[function(_dereq_,module,exports){
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;

},{}],158:[function(_dereq_,module,exports){
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

},{}],159:[function(_dereq_,module,exports){
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

},{}],160:[function(_dereq_,module,exports){
var ListCache = _dereq_('./_ListCache'),
    Map = _dereq_('./_Map'),
    MapCache = _dereq_('./_MapCache');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

},{"./_ListCache":7,"./_Map":8,"./_MapCache":9}],161:[function(_dereq_,module,exports){
var asciiToArray = _dereq_('./_asciiToArray'),
    hasUnicode = _dereq_('./_hasUnicode'),
    unicodeToArray = _dereq_('./_unicodeToArray');

/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray(string) {
  return hasUnicode(string)
    ? unicodeToArray(string)
    : asciiToArray(string);
}

module.exports = stringToArray;

},{"./_asciiToArray":28,"./_hasUnicode":113,"./_unicodeToArray":165}],162:[function(_dereq_,module,exports){
var memoizeCapped = _dereq_('./_memoizeCapped');

/** Used to match property names within property paths. */
var reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;

},{"./_memoizeCapped":142}],163:[function(_dereq_,module,exports){
var isSymbol = _dereq_('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;

},{"./isSymbol":192}],164:[function(_dereq_,module,exports){
/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;

},{}],165:[function(_dereq_,module,exports){
/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}

module.exports = unicodeToArray;

},{}],166:[function(_dereq_,module,exports){
/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsDingbatRange = '\\u2700-\\u27bf',
    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
    rsPunctuationRange = '\\u2000-\\u206f',
    rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
    rsVarRange = '\\ufe0e\\ufe0f',
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]",
    rsBreak = '[' + rsBreakRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsDigits = '\\d+',
    rsDingbat = '[' + rsDingbatRange + ']',
    rsLower = '[' + rsLowerRange + ']',
    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsUpper = '[' + rsUpperRange + ']',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
    rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
    rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
    rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
    reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsOrdLower = '\\d*(?:(?:1st|2nd|3rd|(?![123])\\dth)\\b)',
    rsOrdUpper = '\\d*(?:(?:1ST|2ND|3RD|(?![123])\\dTH)\\b)',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;

/** Used to match complex or compound words. */
var reUnicodeWord = RegExp([
  rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
  rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
  rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
  rsUpper + '+' + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join('|'), 'g');

/**
 * Splits a Unicode `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}

module.exports = unicodeWords;

},{}],167:[function(_dereq_,module,exports){
var assignValue = _dereq_('./_assignValue'),
    copyObject = _dereq_('./_copyObject'),
    createAssigner = _dereq_('./_createAssigner'),
    isArrayLike = _dereq_('./isArrayLike'),
    isPrototype = _dereq_('./_isPrototype'),
    keys = _dereq_('./keys');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns own enumerable string keyed properties of source objects to the
 * destination object. Source objects are applied from left to right.
 * Subsequent sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object` and is loosely based on
 * [`Object.assign`](https://mdn.io/Object/assign).
 *
 * @static
 * @memberOf _
 * @since 0.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.assignIn
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * function Bar() {
 *   this.c = 3;
 * }
 *
 * Foo.prototype.b = 2;
 * Bar.prototype.d = 4;
 *
 * _.assign({ 'a': 0 }, new Foo, new Bar);
 * // => { 'a': 1, 'c': 3 }
 */
var assign = createAssigner(function(object, source) {
  if (isPrototype(source) || isArrayLike(source)) {
    copyObject(source, keys(source), object);
    return;
  }
  for (var key in source) {
    if (hasOwnProperty.call(source, key)) {
      assignValue(object, key, source[key]);
    }
  }
});

module.exports = assign;

},{"./_assignValue":31,"./_copyObject":85,"./_createAssigner":90,"./_isPrototype":128,"./isArrayLike":183,"./keys":194}],168:[function(_dereq_,module,exports){
var capitalize = _dereq_('./capitalize'),
    createCompounder = _dereq_('./_createCompounder');

/**
 * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the camel cased string.
 * @example
 *
 * _.camelCase('Foo Bar');
 * // => 'fooBar'
 *
 * _.camelCase('--foo-bar--');
 * // => 'fooBar'
 *
 * _.camelCase('__FOO_BAR__');
 * // => 'fooBar'
 */
var camelCase = createCompounder(function(result, word, index) {
  word = word.toLowerCase();
  return result + (index ? capitalize(word) : word);
});

module.exports = camelCase;

},{"./_createCompounder":94,"./capitalize":169}],169:[function(_dereq_,module,exports){
var toString = _dereq_('./toString'),
    upperFirst = _dereq_('./upperFirst');

/**
 * Converts the first character of `string` to upper case and the remaining
 * to lower case.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to capitalize.
 * @returns {string} Returns the capitalized string.
 * @example
 *
 * _.capitalize('FRED');
 * // => 'Fred'
 */
function capitalize(string) {
  return upperFirst(toString(string).toLowerCase());
}

module.exports = capitalize;

},{"./toString":207,"./upperFirst":208}],170:[function(_dereq_,module,exports){
var baseClone = _dereq_('./_baseClone');

/** Used to compose bitmasks for cloning. */
var CLONE_SYMBOLS_FLAG = 4;

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG);
}

module.exports = clone;

},{"./_baseClone":37}],171:[function(_dereq_,module,exports){
var baseClone = _dereq_('./_baseClone');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;

},{"./_baseClone":37}],172:[function(_dereq_,module,exports){
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;

},{}],173:[function(_dereq_,module,exports){
var deburrLetter = _dereq_('./_deburrLetter'),
    toString = _dereq_('./toString');

/** Used to match Latin Unicode letters (excluding mathematical operators). */
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

/** Used to compose unicode character classes. */
var rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;

/** Used to compose unicode capture groups. */
var rsCombo = '[' + rsComboRange + ']';

/**
 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
 */
var reComboMark = RegExp(rsCombo, 'g');

/**
 * Deburrs `string` by converting
 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
 * letters to basic Latin letters and removing
 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to deburr.
 * @returns {string} Returns the deburred string.
 * @example
 *
 * _.deburr('dj vu');
 * // => 'deja vu'
 */
function deburr(string) {
  string = toString(string);
  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
}

module.exports = deburr;

},{"./_deburrLetter":95,"./toString":207}],174:[function(_dereq_,module,exports){
module.exports = _dereq_('./forEach');

},{"./forEach":176}],175:[function(_dereq_,module,exports){
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;

},{}],176:[function(_dereq_,module,exports){
var arrayEach = _dereq_('./_arrayEach'),
    baseEach = _dereq_('./_baseEach'),
    castFunction = _dereq_('./_castFunction'),
    isArray = _dereq_('./isArray');

/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}

module.exports = forEach;

},{"./_arrayEach":21,"./_baseEach":39,"./_castFunction":73,"./isArray":182}],177:[function(_dereq_,module,exports){
var baseGet = _dereq_('./_baseGet');

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;

},{"./_baseGet":43}],178:[function(_dereq_,module,exports){
var baseAssignValue = _dereq_('./_baseAssignValue'),
    createAggregator = _dereq_('./_createAggregator');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an object composed of keys generated from the results of running
 * each element of `collection` thru `iteratee`. The order of grouped values
 * is determined by the order they occur in `collection`. The corresponding
 * value of each key is an array of elements responsible for generating the
 * key. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
 * @returns {Object} Returns the composed aggregate object.
 * @example
 *
 * _.groupBy([6.1, 4.2, 6.3], Math.floor);
 * // => { '4': [4.2], '6': [6.1, 6.3] }
 *
 * // The `_.property` iteratee shorthand.
 * _.groupBy(['one', 'two', 'three'], 'length');
 * // => { '3': ['one', 'two'], '5': ['three'] }
 */
var groupBy = createAggregator(function(result, value, key) {
  if (hasOwnProperty.call(result, key)) {
    result[key].push(value);
  } else {
    baseAssignValue(result, key, [value]);
  }
});

module.exports = groupBy;

},{"./_baseAssignValue":36,"./_createAggregator":89}],179:[function(_dereq_,module,exports){
var baseHasIn = _dereq_('./_baseHasIn'),
    hasPath = _dereq_('./_hasPath');

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;

},{"./_baseHasIn":46,"./_hasPath":112}],180:[function(_dereq_,module,exports){
/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

},{}],181:[function(_dereq_,module,exports){
var baseIsArguments = _dereq_('./_baseIsArguments'),
    isObjectLike = _dereq_('./isObjectLike');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;

},{"./_baseIsArguments":47,"./isObjectLike":190}],182:[function(_dereq_,module,exports){
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

},{}],183:[function(_dereq_,module,exports){
var isFunction = _dereq_('./isFunction'),
    isLength = _dereq_('./isLength');

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

},{"./isFunction":186,"./isLength":187}],184:[function(_dereq_,module,exports){
var isArrayLike = _dereq_('./isArrayLike'),
    isObjectLike = _dereq_('./isObjectLike');

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;

},{"./isArrayLike":183,"./isObjectLike":190}],185:[function(_dereq_,module,exports){
var root = _dereq_('./_root'),
    stubFalse = _dereq_('./stubFalse');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

},{"./_root":150,"./stubFalse":205}],186:[function(_dereq_,module,exports){
var baseGetTag = _dereq_('./_baseGetTag'),
    isObject = _dereq_('./isObject');

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

},{"./_baseGetTag":45,"./isObject":189}],187:[function(_dereq_,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],188:[function(_dereq_,module,exports){
var baseGetTag = _dereq_('./_baseGetTag'),
    isObjectLike = _dereq_('./isObjectLike');

/** `Object#toString` result references. */
var numberTag = '[object Number]';

/**
 * Checks if `value` is classified as a `Number` primitive or object.
 *
 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
 * classified as numbers, use the `_.isFinite` method.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a number, else `false`.
 * @example
 *
 * _.isNumber(3);
 * // => true
 *
 * _.isNumber(Number.MIN_VALUE);
 * // => true
 *
 * _.isNumber(Infinity);
 * // => true
 *
 * _.isNumber('3');
 * // => false
 */
function isNumber(value) {
  return typeof value == 'number' ||
    (isObjectLike(value) && baseGetTag(value) == numberTag);
}

module.exports = isNumber;

},{"./_baseGetTag":45,"./isObjectLike":190}],189:[function(_dereq_,module,exports){
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],190:[function(_dereq_,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],191:[function(_dereq_,module,exports){
var baseGetTag = _dereq_('./_baseGetTag'),
    getPrototype = _dereq_('./_getPrototype'),
    isObjectLike = _dereq_('./isObjectLike');

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;

},{"./_baseGetTag":45,"./_getPrototype":106,"./isObjectLike":190}],192:[function(_dereq_,module,exports){
var baseGetTag = _dereq_('./_baseGetTag'),
    isObjectLike = _dereq_('./isObjectLike');

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;

},{"./_baseGetTag":45,"./isObjectLike":190}],193:[function(_dereq_,module,exports){
var baseIsTypedArray = _dereq_('./_baseIsTypedArray'),
    baseUnary = _dereq_('./_baseUnary'),
    nodeUtil = _dereq_('./_nodeUtil');

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;

},{"./_baseIsTypedArray":52,"./_baseUnary":71,"./_nodeUtil":146}],194:[function(_dereq_,module,exports){
var arrayLikeKeys = _dereq_('./_arrayLikeKeys'),
    baseKeys = _dereq_('./_baseKeys'),
    isArrayLike = _dereq_('./isArrayLike');

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

},{"./_arrayLikeKeys":23,"./_baseKeys":54,"./isArrayLike":183}],195:[function(_dereq_,module,exports){
var arrayLikeKeys = _dereq_('./_arrayLikeKeys'),
    baseKeysIn = _dereq_('./_baseKeysIn'),
    isArrayLike = _dereq_('./isArrayLike');

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

},{"./_arrayLikeKeys":23,"./_baseKeysIn":55,"./isArrayLike":183}],196:[function(_dereq_,module,exports){
var arrayMap = _dereq_('./_arrayMap'),
    baseIteratee = _dereq_('./_baseIteratee'),
    baseMap = _dereq_('./_baseMap'),
    isArray = _dereq_('./isArray');

/**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */
function map(collection, iteratee) {
  var func = isArray(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee, 3));
}

module.exports = map;

},{"./_arrayMap":24,"./_baseIteratee":53,"./_baseMap":56,"./isArray":182}],197:[function(_dereq_,module,exports){
var MapCache = _dereq_('./_MapCache');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;

},{"./_MapCache":9}],198:[function(_dereq_,module,exports){
var baseMerge = _dereq_('./_baseMerge'),
    createAssigner = _dereq_('./_createAssigner');

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

module.exports = merge;

},{"./_baseMerge":59,"./_createAssigner":90}],199:[function(_dereq_,module,exports){
/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that negates the result of the predicate `func`. The
 * `func` predicate is invoked with the `this` binding and arguments of the
 * created function.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {Function} predicate The predicate to negate.
 * @returns {Function} Returns the new negated function.
 * @example
 *
 * function isEven(n) {
 *   return n % 2 == 0;
 * }
 *
 * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
 * // => [1, 3, 5]
 */
function negate(predicate) {
  if (typeof predicate != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0: return !predicate.call(this);
      case 1: return !predicate.call(this, args[0]);
      case 2: return !predicate.call(this, args[0], args[1]);
      case 3: return !predicate.call(this, args[0], args[1], args[2]);
    }
    return !predicate.apply(this, args);
  };
}

module.exports = negate;

},{}],200:[function(_dereq_,module,exports){
var baseIteratee = _dereq_('./_baseIteratee'),
    negate = _dereq_('./negate'),
    pickBy = _dereq_('./pickBy');

/**
 * The opposite of `_.pickBy`; this method creates an object composed of
 * the own and inherited enumerable string keyed properties of `object` that
 * `predicate` doesn't return truthy for. The predicate is invoked with two
 * arguments: (value, key).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The source object.
 * @param {Function} [predicate=_.identity] The function invoked per property.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.omitBy(object, _.isNumber);
 * // => { 'b': '2' }
 */
function omitBy(object, predicate) {
  return pickBy(object, negate(baseIteratee(predicate)));
}

module.exports = omitBy;

},{"./_baseIteratee":53,"./negate":199,"./pickBy":201}],201:[function(_dereq_,module,exports){
var arrayMap = _dereq_('./_arrayMap'),
    baseIteratee = _dereq_('./_baseIteratee'),
    basePickBy = _dereq_('./_basePickBy'),
    getAllKeysIn = _dereq_('./_getAllKeysIn');

/**
 * Creates an object composed of the `object` properties `predicate` returns
 * truthy for. The predicate is invoked with two arguments: (value, key).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The source object.
 * @param {Function} [predicate=_.identity] The function invoked per property.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pickBy(object, _.isNumber);
 * // => { 'a': 1, 'c': 3 }
 */
function pickBy(object, predicate) {
  if (object == null) {
    return {};
  }
  var props = arrayMap(getAllKeysIn(object), function(prop) {
    return [prop];
  });
  predicate = baseIteratee(predicate);
  return basePickBy(object, props, function(value, path) {
    return predicate(value, path[0]);
  });
}

module.exports = pickBy;

},{"./_arrayMap":24,"./_baseIteratee":53,"./_basePickBy":61,"./_getAllKeysIn":102}],202:[function(_dereq_,module,exports){
var baseProperty = _dereq_('./_baseProperty'),
    basePropertyDeep = _dereq_('./_basePropertyDeep'),
    isKey = _dereq_('./_isKey'),
    toKey = _dereq_('./_toKey');

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;

},{"./_baseProperty":62,"./_basePropertyDeep":63,"./_isKey":125,"./_toKey":163}],203:[function(_dereq_,module,exports){
var arrayFilter = _dereq_('./_arrayFilter'),
    baseFilter = _dereq_('./_baseFilter'),
    baseIteratee = _dereq_('./_baseIteratee'),
    isArray = _dereq_('./isArray'),
    negate = _dereq_('./negate');

/**
 * The opposite of `_.filter`; this method returns the elements of `collection`
 * that `predicate` does **not** return truthy for.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see _.filter
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': false },
 *   { 'user': 'fred',   'age': 40, 'active': true }
 * ];
 *
 * _.reject(users, function(o) { return !o.active; });
 * // => objects for ['fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.reject(users, { 'age': 40, 'active': true });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.reject(users, ['active', false]);
 * // => objects for ['fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.reject(users, 'active');
 * // => objects for ['barney']
 */
function reject(collection, predicate) {
  var func = isArray(collection) ? arrayFilter : baseFilter;
  return func(collection, negate(baseIteratee(predicate, 3)));
}

module.exports = reject;

},{"./_arrayFilter":22,"./_baseFilter":40,"./_baseIteratee":53,"./isArray":182,"./negate":199}],204:[function(_dereq_,module,exports){
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;

},{}],205:[function(_dereq_,module,exports){
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

},{}],206:[function(_dereq_,module,exports){
var copyObject = _dereq_('./_copyObject'),
    keysIn = _dereq_('./keysIn');

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;

},{"./_copyObject":85,"./keysIn":195}],207:[function(_dereq_,module,exports){
var baseToString = _dereq_('./_baseToString');

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;

},{"./_baseToString":70}],208:[function(_dereq_,module,exports){
var createCaseFirst = _dereq_('./_createCaseFirst');

/**
 * Converts the first character of `string` to upper case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.upperFirst('fred');
 * // => 'Fred'
 *
 * _.upperFirst('FRED');
 * // => 'FRED'
 */
var upperFirst = createCaseFirst('toUpperCase');

module.exports = upperFirst;

},{"./_createCaseFirst":93}],209:[function(_dereq_,module,exports){
var asciiWords = _dereq_('./_asciiWords'),
    hasUnicodeWord = _dereq_('./_hasUnicodeWord'),
    toString = _dereq_('./toString'),
    unicodeWords = _dereq_('./_unicodeWords');

/**
 * Splits `string` into an array of its words.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {RegExp|string} [pattern] The pattern to match words.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the words of `string`.
 * @example
 *
 * _.words('fred, barney, & pebbles');
 * // => ['fred', 'barney', 'pebbles']
 *
 * _.words('fred, barney, & pebbles', /[^, ]+/g);
 * // => ['fred', 'barney', '&', 'pebbles']
 */
function words(string, pattern, guard) {
  string = toString(string);
  pattern = guard ? undefined : pattern;

  if (pattern === undefined) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}

module.exports = words;

},{"./_asciiWords":29,"./_hasUnicodeWord":114,"./_unicodeWords":166,"./toString":207}],210:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('address', {
        icon: 'fa fa-home',
        views: [
          {
            name: 'Display',
            template: 'formio/components/address/display.html'
          },
          {
            name: 'Validation',
            template: 'formio/components/address/validate.html'
          },
          {
            name: 'API',
            template: 'formio/components/common/api.html'
          },
          {
            name: 'Layout',
            template: 'formio/components/common/layout.html'
          },
          {
            name: 'Conditional',
            template: 'formio/components/common/conditional.html'
          }
        ],
        documentation: 'http://help.form.io/userguide/#address'
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      // Create the settings markup.
      $templateCache.put('formio/components/address/display.html',
        '<ng-form>' +
          '<form-builder-option property="label"></form-builder-option>' +
          '<form-builder-option property="placeholder"></form-builder-option>' +
          '<form-builder-option property="customClass"></form-builder-option>' +
          '<form-builder-option property="tabindex"></form-builder-option>' +
          '<div class="form-group">' +
            '<label for="mapRegion" form-builder-tooltip="The region bias to use for this search. See <a href=\'https://developers.google.com/maps/documentation/geocoding/intro#RegionCodes\' target=\'_blank\'>Region Biasing</a> for more information.">Region Bias</label>' +
            '<input type="text" class="form-control" id="mapRegion" name="mapRegion" ng-model="component.map.region" placeholder="Dallas" />' +
          '</div>' +
          '<div class="form-group">' +
            '<label for="mapKey" form-builder-tooltip="The API key for Google Maps. See <a href=\'https://developers.google.com/maps/documentation/geocoding/get-api-key\' target=\'_blank\'>Get an API Key</a> for more information.">Google Maps API Key</label>' +
            '<input type="text" class="form-control" id="mapKey" name="mapKey" ng-model="component.map.key" placeholder="xxxxxxxxxxxxxxxxxxx-xxxxxxxxxxxxxxxxxxx"/>' +
          '</div>' +
          '<form-builder-option property="multiple" label="Allow Multiple Addresses"></form-builder-option>' +
          '<form-builder-option property="clearOnHide"></form-builder-option>' +
          '<form-builder-option property="protected"></form-builder-option>' +
          '<form-builder-option property="persistent"></form-builder-option>' +
          '<form-builder-option property="hidden"></form-builder-option>' +
          '<form-builder-option property="disabled"></form-builder-option>' +
          '<form-builder-option property="tableView"></form-builder-option>' +
        '</ng-form>'
      );

      $templateCache.put('formio/components/address/validate.html',
        '<ng-form>' +
          '<form-builder-option property="validate.required"></form-builder-option>' +
          '<form-builder-option property="unique"></form-builder-option>' +
        '</ng-form>'
      );
    }
  ]);
};

},{}],211:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    'FORM_OPTIONS',
    function(
      formioComponentsProvider,
      FORM_OPTIONS
    ) {
      formioComponentsProvider.register('button', {
        onEdit: ['$scope', function($scope) {
          $scope.actions = FORM_OPTIONS.actions;
          $scope.sizes = FORM_OPTIONS.sizes;
          $scope.themes = FORM_OPTIONS.themes;
        }],
        icon: 'fa fa-stop',
        views: [
          {
            name: 'Display',
            template: 'formio/components/button/display.html'
          },
          {
            name: 'API',
            template: 'formio/components/common/api.html'
          },
          {
            name: 'Layout',
            template: 'formio/components/common/layout.html'
          },
          {
            name: 'Conditional',
            template: 'formio/components/common/conditional.html'
          }
        ],
        documentation: 'http://help.form.io/userguide/#button'
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      // Create the settings markup.
      $templateCache.put('formio/components/button/display.html',
        '<ng-form>' +
          '<form-builder-option property="label"></form-builder-option>' +
          '<div class="form-group">' +
            '<label for="action" form-builder-tooltip="This is the action to be performed by this button.">{{\'Action\' |formioTranslate}}</label>' +
            '<select class="form-control" id="action" name="action" ng-options="action.name as action.title for action in actions" ng-model="component.action"></select>' +
          '</div>' +
          '<div class="form-group" ng-if="component.action === \'event\'">' +
          '  <label for="event" form-builder-tooltip="The event to fire when the button is clicked.">{{\'Button Event\' |formioTranslate}}</label>' +
          '  <input type="text" class="form-control" id="event" name="event" ng-model="component.event" placeholder="event" />' +
          '</div>' +
          '<div class="form-group">' +
            '<label for="theme" form-builder-tooltip="The color theme of this panel.">{{\'Theme\' |formioTranslate}}</label>' +
            '<select class="form-control" id="theme" name="theme" ng-options="theme.name as theme.title for theme in themes" ng-model="component.theme"></select>' +
          '</div>' +
          '<div class="form-group">' +
            '<label for="size" form-builder-tooltip="The size of this button.">{{\'Size\' |formioTranslate}}</label>' +
            '<select class="form-control" id="size" name="size" ng-options="size.name as size.title for size in sizes" ng-model="component.size"></select>' +
          '</div>' +
          '<form-builder-option property="leftIcon"></form-builder-option>' +
          '<form-builder-option property="rightIcon"></form-builder-option>' +
          '<form-builder-option property="customClass"></form-builder-option>' +
          '<form-builder-option property="tabindex"></form-builder-option>' +
          '<form-builder-option property="block"></form-builder-option>' +
          '<form-builder-option property="disableOnInvalid"></form-builder-option>' +
        '</ng-form>'
      );
    }
  ]);
};

},{}],212:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('checkbox', {
        icon: 'fa fa-check-square',
        onEdit: ['$scope', function($scope) {
          $scope.inputTypes = [
            {
              name: 'checkbox',
              title: 'Checkbox'
            },
            {
              name: 'radio',
              title: 'Radio'
            }
          ];
        }],
        views: [
          {
            name: 'Display',
            template: 'formio/components/checkbox/display.html'
          },
          {
            name: 'Data',
            template: 'formio/components/common/data.html'
          },
          {
            name: 'Validation',
            template: 'formio/components/checkbox/validate.html'
          },
          {
            name: 'API',
            template: 'formio/components/common/api.html'
          },
          {
            name: 'Layout',
            template: 'formio/components/common/layout.html'
          },
          {
            name: 'Conditional',
            template: 'formio/components/common/conditional.html'
          }
        ],
        documentation: 'http://help.form.io/userguide/#checkbox'
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      // Create the settings markup.
      $templateCache.put('formio/components/checkbox/display.html',
        '<ng-form>' +
          '<form-builder-option property="label"></form-builder-option>' +
          '<div class="form-group">' +
            '<label for="inputType" form-builder-tooltip="This is the input type used for this checkbox.">Input Type</label>' +
            '<select class="form-control" id="inputType" name="inputType" ng-options="inputType.name as inputType.title for inputType in inputTypes" ng-model="component.inputType"></select>' +
          '</div>' +
          '<div class="form-group" ng-if="component.inputType === \'radio\'">' +
          '  <label for="name" form-builder-tooltip="The key used to trigger the radio button toggle.">Radio Key</label>' +
          '  <input type="text" class="form-control" id="name" name="name" ng-model="component.name" placeholder="{{ component.key }}" />' +
          '</div>' +
          '<div class="form-group" ng-if="component.inputType === \'radio\'">' +
          '  <label for="value" form-builder-tooltip="The value used with this radio button.">Radio Value</label>' +
          '  <input type="text" class="form-control" id="value" name="value" ng-model="component.value" placeholder="{{ component.value }}" />' +
          '</div>' +
          '<form-builder-option property="datagridLabel"></form-builder-option>' +
          '<form-builder-option property="customClass"></form-builder-option>' +
          '<form-builder-option property="tabindex"></form-builder-option>' +
          '<form-builder-option property="clearOnHide"></form-builder-option>' +
          '<form-builder-option property="protected"></form-builder-option>' +
          '<form-builder-option property="persistent"></form-builder-option>' +
          '<form-builder-option property="hidden"></form-builder-option>' +
          '<form-builder-option property="disabled"></form-builder-option>' +
          '<form-builder-option property="tableView"></form-builder-option>' +
        '</ng-form>'
      );

      $templateCache.put('formio/components/checkbox/validate.html',
        '<ng-form>' +
          '<form-builder-option property="validate.required"></form-builder-option>' +
          '<form-builder-option-custom-validation></form-builder-option-custom-validation>' +
        '</ng-form>'
      );
    }
  ]);
};

},{}],213:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('columns', {
        onEdit: ['$scope', function($scope) {
          $scope.removeColumn = function(index) {
            $scope.component.columns.splice(index, 1);
          };
          $scope.addColumn = function() {
            $scope.component.columns.push({components: [], width: 1, offset: 0, push: 0, pull: 0});
          };
        }],
        fbtemplate: 'formio/formbuilder/columns.html',
        icon: 'fa fa-columns',
        documentation: 'http://help.form.io/userguide/#columns',
        noDndOverlay: true,
        confirmRemove: true,
        views: [
          {
            name: 'Display',
            template: 'formio/components/columns/display.html'
          },
          {
            name: 'API',
            template: 'formio/components/common/api.html'
          },
          {
            name: 'Conditional',
            template: 'formio/components/common/conditional.html'
          }
        ]
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/formbuilder/columns.html',
        '<div class="row">' +
          '<div ng-show="column.width" ng-class="\'col-xs-\' + column.width + \' col-xs-offset-\' + column.offset + \' col-xs-push-\' + column.push + \' col-xs-pull-\' + column.pull" component-form-group" ng-repeat="column in component.columns">' +
            '<form-builder-list class="formio-column" component="column" form="form" formio="::formio"></form-builder-list>' +
          '</div>' +
        '</div>'
      );
      $templateCache.put('formio/components/columns/display.html',
        '<ng-form>' +
          '<form-builder-option property="customClass"></form-builder-option>' +
          '<div class="form-group">' +
            '<label form-builder-tooltip="The width, offset, push and pull settings for the columns">{{\'Column Properties\' |formioTranslate}}</label>' +
            '<table class="table table-condensed">' +
              '<thead>' +
                '<tr>' +
                  '<th class="col-xs-2">{{\'Column\' |formioTranslate}}</th>' +
                  '<th class="col-xs-2">{{\'Width\' |formioTranslate}}</th>' +
                  '<th class="col-xs-2">{{\'Offset\' |formioTranslate}}</th>' +
                  '<th class="col-xs-2">{{\'Push\' |formioTranslate}}</th>' +
                  '<th class="col-xs-2">{{\'Pull\' |formioTranslate}}</th>' +
                  '<th class="col-xs-1"></th>' +
                '</tr>' +
              '</thead>' +
              '<tbody>' +
                '<tr ng-repeat="column in component.columns track by $index">' +
                  '<td class="col-xs-2"><input type="number" class="form-control" ng-value="$index + 1" disabled/></td>' +
                  '<td class="col-xs-2"><input type="number" class="form-control" min="0" max="12" ng-model="column.width"/></td>' +
                  '<td class="col-xs-2"><input type="number" class="form-control" min="0" max="12" ng-model="column.offset"/></td>' +
                  '<td class="col-xs-2"><input type="number" class="form-control" min="0" max="12" ng-model="column.push"/></td>' +
                  '<td class="col-xs-2"><input type="number" class="form-control" min="0" max="12" ng-model="column.pull"/></td>' +
                  '<td class="col-xs-1"><button type="button" class="btn btn-danger btn-xs" ng-click="removeColumn($index)" tabindex="-1"><span class="glyphicon glyphicon-remove-circle"></span></button></td>' +
                '</tr>' +
              '</tbody>' +
            '</table>' +
            '<button type="button" class="btn" ng-click="addColumn()">{{\'Add Column\' |formioTranslate}}</button>' +
          '</div>' +
        '</ng-form>'
      );
    }
  ]);
};

},{}],214:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.run([
    '$templateCache',
    function($templateCache) {
      // Create the component markup.
      $templateCache.put('formio/components/settings.html',
        '<form id="component-settings" novalidate>' +
          '<div class="row">' +
            '<div class="col-md-6">' +
              '<p class="lead" ng-if="::formComponent.title" style="margin-top:10px;">{{::formComponent.title}} {{\'Component\' |formioTranslate}}</p>' +
            '</div>' +
            '<div class="col-md-6">' +
              '<div class="pull-right" ng-if="::formComponent.documentation" style="margin-top:10px; margin-right:20px;">' +
                '<a ng-href="{{ ::formComponent.documentation }}" target="_blank"><i class="glyphicon glyphicon-new-window"></i> {{\'Help!\' |formioTranslate}}</a>' +
              '</div>' +
            '</div>' +
          '</div>' +
          '<div class="row">' +
            '<div class="col-xs-6">' +
              '<uib-tabset>' +
                '<uib-tab ng-repeat="view in ::formComponent.views" heading="{{ ::view.name |formioTranslate }}"><ng-include src="::view.template"></ng-include></uib-tab>' +
              '</uib-tabset>' +
            '</div>' +
            '<div class="col-xs-6">' +
              '<div class="panel panel-default preview-panel" style="margin-top:44px;">' +
                '<div class="panel-heading">{{\'Preview\' |formioTranslate}}</div>' +
                '<div class="panel-body">' +
                  '<div class="form-group" ng-if="component.wysiwyg && editorVisible">' +
                    '<label for="editor-preview" class="control-label" ng-if="component.label">{{ component.label }}</label>' +
                    '<textarea class="form-control" id="editor-preview" ng-if="component.wysiwyg && editorVisible" ckeditor="component.wysiwyg"></textarea>' +
                  '</div>' +
                  '<formio-component ng-if="!component.wysiwyg" component="component" data="{}" formio="::formio"></formio-component>' +
                '</div>' +
              '</div>' +
              '<formio-settings-info component="component" data="{}" formio="::formio"></formio-settings-info>' +
              '<div class="form-group">' +
                '<button type="submit" class="btn btn-success" ng-click="closeThisDialog(true)">{{\'Save\' |formioTranslate}}</button>&nbsp;' +
                '<button type="button" class="btn btn-default" ng-click="closeThisDialog(false)" ng-if="!component.isNew">{{\'Cancel\' |formioTranslate}}</button>&nbsp;' +
                '<button type="button" class="btn btn-danger" ng-click="removeComponent(component, formComponents[component.type].confirmRemove); closeThisDialog(false)">{{\'Remove\' |formioTranslate}}</button>' +
              '</div>' +
            '</div>' +
          '</div>' +
        '</form>'
      );

      // Create the common API tab markup.
      $templateCache.put('formio/components/common/data.html',
        '<form-builder-option property="defaultValue"></form-builder-option>' +
        '<uib-accordion>' +
        '  <div uib-accordion-group heading="Custom Default Value" class="panel panel-default">' +
        '    <uib-accordion>' +
        '      <div uib-accordion-group heading="JavaScript Default" class="panel panel-default" is-open="true">' +
        '        <textarea class="form-control" rows="5" id="customDefaultValue" name="customDefaultValue" ng-model="component.customDefaultValue" placeholder="/*** Example Code ***/\nvalue = data[\'mykey\'] + data[\'anotherKey\'];"></textarea>' +
        '        <small>' +
        '          <p>Enter custom default value code.</p>' +
        '          <p>You must assign the <strong>value</strong> variable as the result you want for the default value.</p>' +
        '          <p>The global variable <strong>data</strong> is provided, and allows you to access the data of any form component, by using its API key.</p>' +
        '          <p>Default Values are only calculated on form load. Use Calculated Value for a value that will update with the form.</p>' +
        '        </small>' +
        '      </div>' +
        '      <div uib-accordion-group heading="JSONLogic Default" class="panel panel-default">' +
        '        <small>' +
        '          <p>Execute custom default value using <a href="http://jsonlogic.com/">JSONLogic</a>.</p>' +
        '          <p>Submission data is available as JsonLogic variables, with the same api key as your components.</p>' +
        '          <p><a href="http://formio.github.io/formio.js/app/examples/calculated.html" target="_blank">Click here for an example</a></p>' +
        '        </small>' +
        '        <textarea class="form-control" rows="5" id="json" name="json" json-input ng-model="component.customDefaultValue" placeholder=\'{ ... }\'></textarea>' +
        '      </div>' +
        '    </uib-accordion>' +
        '  </div>' +
        '  <div uib-accordion-group heading="Calculated Value" class="panel panel-default">' +
        '    <uib-accordion>' +
        '      <div uib-accordion-group heading="JavaScript Value" class="panel panel-default" is-open="true">' +
        '        <textarea class="form-control" rows="5" id="calculateValue" name="calculateValue" ng-model="component.calculateValue" placeholder="/*** Example Code ***/\nvalue = data[\'mykey\'] + data[\'anotherKey\'];"></textarea>' +
        '        <small>' +
        '          <p>Enter code to calculate a value.</p>' +
        '          <p>You must assign the <strong>value</strong> variable as the result you want for the default value.</p>' +
        '          <p>The global variable <strong>data</strong> is provided, and allows you to access the data of any form component, by using its API key.</p>' +
        '        </small>' +
        '      </div>' +
        '      <div uib-accordion-group heading="JSONLogic Value" class="panel panel-default">' +
        '        <small>' +
        '          <p>Execute custom calculation logic with JSON and <a href="http://jsonlogic.com/">JSONLogic</a>.</p>' +
        '          <p>Submission data is available as JsonLogic variables, with the same api key as your components.</p>' +
        '          <p><a href="http://formio.github.io/formio.js/app/examples/calculated.html" target="_blank">Click here for an example</a></p>' +
        '        </small>' +
        '        <textarea class="form-control" rows="5" id="json" name="json" json-input ng-model="component.calculateValue" placeholder=\'{ ... }\'></textarea>' +
        '      </div>' +
        '    </uib-accordion>' +
        '  </div>' +
        '</uib-accordion>'
      );

      // Create the common API tab markup.
      $templateCache.put('formio/components/common/api.html',
        '<ng-form>' +
          '<form-builder-option-key></form-builder-option-key>' +
          '<form-builder-option-tags></form-builder-option-tags>' +
        '</ng-form>'
      );

      // Create the common Layout tab markup.
      $templateCache.put('formio/components/common/layout.html',
        '<ng-form>' +
          // Need to use array notation to have dash in name
          '<form-builder-option property="style[\'margin-top\']"></form-builder-option>' +
          '<form-builder-option property="style[\'margin-right\']"></form-builder-option>' +
          '<form-builder-option property="style[\'margin-bottom\']"></form-builder-option>' +
          '<form-builder-option property="style[\'margin-left\']"></form-builder-option>' +
          '<uib-accordion>' +
          '  <div uib-accordion-group heading="Overlay" class="panel panel-default">' +
          '    <div class="form-group">' +
          '      <label for="overlay-style">Style</label>' +
          '      <input class="form-control" id="overlay-style" name="overlay-style" ng-model="component.overlay.style"></input>' +
          '    </div>' +
          '    <div class="form-group">' +
          '      <label for="overlay-left">Left</label>' +
          '      <input class="form-control" id="overlay-left" name="overlay-left" ng-model="component.overlay.left"></input>' +
          '    </div>' +
          '    <div class="form-group">' +
          '      <label for="overlay-right">Top</label>' +
          '      <input class="form-control" id="overlay-top" name="overlay-top" ng-model="component.overlay.top"></input>' +
          '    </div>' +
          '    <div class="form-group">' +
          '      <label for="overlay-width">Width</label>' +
          '      <input class="form-control" id="overlay-width" name="overlay-width" ng-model="component.overlay.width"></input>' +
          '    </div>' +
          '    <div class="form-group">' +
          '      <label for="overlay-height">Height</label>' +
          '      <input class="form-control" id="overlay-height" name="overlay-height" ng-model="component.overlay.height"></input>' +
          '    </div>' +
          '  </div>' +
          '</uib-accordion>' +
        '</ng-form>'
      );

      // Create the common Layout tab markup.
      $templateCache.put('formio/components/common/conditional.html',
        '<form-builder-conditional></form-builder-conditional>'
      );
    }
  ]);
};

},{}],215:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('container', {
        fbtemplate: 'formio/formbuilder/container.html',
        views: [
          {
            name: 'Display',
            template: 'formio/components/container/display.html'
          }, {
            name: 'API',
            template: 'formio/components/common/api.html'
          },
          {
            name: 'Conditional',
            template: 'formio/components/common/conditional.html'
          }
        ],
        documentation: 'http://help.form.io/userguide/#container',
        noDndOverlay: true,
        confirmRemove: true
      });
    }
  ]);

  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/components/container/display.html',
        '<ng-form>' +
        '<form-builder-option property="label"></form-builder-option>' +
        '<form-builder-option property="customClass"></form-builder-option>' +
        '<form-builder-option property="clearOnHide"></form-builder-option>' +
        '<form-builder-option property="protected"></form-builder-option>' +
        '<form-builder-option property="persistent"></form-builder-option>' +
        '<form-builder-option property="tableView"></form-builder-option>' +
        '</ng-form>'
      );

      $templateCache.put('formio/formbuilder/container.html',
        '<fieldset>' +
        '<label ng-if="component.label" class="control-label">{{ component.label }}</label>' +
        '<form-builder-list component="component" form="form" formio="::formio"></form-builder-list>' +
        '</fieldset>'
      );
    }
  ]);
};

},{}],216:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('content', {
        fbtemplate: 'formio/formbuilder/content.html',
        icon: 'fa fa-html5',
        documentation: 'http://help.form.io/userguide/#content-component',
        controller: function(settings, $scope) {
          $scope.ckeditorOptions = {
            allowedContent: true,
            toolbarGroups:  [
              {name: 'basicstyles', groups: ['basicstyles', 'cleanup']},
              {name: 'paragraph', groups: ['list', 'indent', 'blocks', 'align', 'bidi', 'paragraph', '-', 'JustifyLeft', 'JustifyCenter', 'JustifyRight', 'JustifyBlock']},
              {name: 'links', groups: ['links']},
              {name: 'insert', groups: ['insert']},
              '/',
              {name: 'styles', groups: ['Styles', 'Format', 'Font', 'FontSize']},
              {name: 'colors', groups: ['colors']},
              {name: 'clipboard', groups: ['clipboard', 'undo']},
              {name: 'editing', groups: ['find', 'selection', 'spellchecker', 'editing']},
              {name: 'document', groups: ['mode', 'document', 'doctools']},
              {name: 'others', groups: ['others']},
              {name: 'tools', groups: ['tools']}
            ],
            extraPlugins: 'justify,font',
            removeButtons: 'Cut,Copy,Paste,Underline,Subscript,Superscript,Scayt,About',
            uiColor: '#eeeeee',
            height: '400px',
            width: '100%'
          };
          $scope.$watch('component.html', function() {
            $scope.$emit('formBuilder:update');
          });
        },
        views: [
          {
            name: 'Display',
            template: 'formio/components/common/display.html'
          },
          {
            name: 'API',
            template: 'formio/components/common/api.html'
          },
          {
            name: 'Conditional',
            template: 'formio/components/common/conditional.html'
          }
        ]
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/formbuilder/content.html',
        '<div class="form-group">' +
          '<textarea ckeditor="ckeditorOptions" ng-model="component.html"><textarea>' +
        '</div>'
      );
      $templateCache.put('formio/components/common/display.html',
        '<ng-form>' +
          '<form-builder-option property="customClass"></form-builder-option>' +
        '</ng-form>'
      );
    }
  ]);
};

},{}],217:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('currency', {
        icon: 'fa fa-usd',
        views: [
          {
            name: 'Display',
            template: 'formio/components/currency/display.html'
          },
          {
            name: 'Data',
            template: 'formio/components/common/data.html'
          },
          {
            name: 'Validation',
            template: 'formio/components/currency/validate.html'
          },
          {
            name: 'API',
            template: 'formio/components/common/api.html'
          },
          {
            name: 'Layout',
            template: 'formio/components/common/layout.html'
          },
          {
            name: 'Conditional',
            template: 'formio/components/common/conditional.html'
          }
        ],
        documentation: 'http://help.form.io/userguide/#currency'
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      // Create the settings markup.
      $templateCache.put('formio/components/currency/display.html',
        '<ng-form>' +
          '<form-builder-option property="label"></form-builder-option>' +
          '<form-builder-option property="placeholder"></form-builder-option>' +
          '<form-builder-option property="description"></form-builder-option>' +
          '<form-builder-option property="prefix"></form-builder-option>' +
          '<form-builder-option property="suffix"></form-builder-option>' +
          '<form-builder-option property="customClass"></form-builder-option>' +
          '<form-builder-option property="tabindex"></form-builder-option>' +
          '<form-builder-option property="multiple"></form-builder-option>' +
          '<form-builder-option property="clearOnHide"></form-builder-option>' +
          '<form-builder-option property="disabled"></form-builder-option>' +
          '<form-builder-option property="hidden"></form-builder-option>' +
          '<form-builder-option property="tableView"></form-builder-option>' +
        '</ng-form>'
      );

      // Create the API markup.
      $templateCache.put('formio/components/currency/validate.html',
        '<ng-form>' +
          '<form-builder-option property="validate.required"></form-builder-option>' +
          '<form-builder-option-custom-validation></form-builder-option-custom-validation>' +
        '</ng-form>'
      );
    }
  ]);
};

},{}],218:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('custom', {
        icon: 'fa fa-cubes',
        views: [
          {
            name: 'Display',
            template: 'formio/components/custom/display.html'
          },
          {
            name: 'Conditional',
            template: 'formio/components/common/conditional.html'
          }
        ],
        documentation: 'http://help.form.io/userguide/#custom'
      });
    }
  ]);

  app.controller('customComponent', [
    '$scope',
    'formioComponents',
    function(
      $scope,
      formioComponents
    ) {
      // Because of the weirdnesses of prototype inheritence, components can't update themselves, only their properties.
      var currentKey = $scope.component.key;
      $scope.customComponent = angular.copy($scope.component);
      $scope.$watch('customComponent', function(newValue) {
        if (newValue) {
          // Don't allow a type of a real type.
          newValue.type = (formioComponents.components.hasOwnProperty(newValue.type) ? 'custom' : newValue.type);
          // Ensure some key settings are set.
          newValue.key = newValue.key || newValue.type;
          newValue.protected = (newValue.hasOwnProperty('protected') ? newValue.protected : false);
          newValue.persistent = (newValue.hasOwnProperty('persistent') ? newValue.persistent : true);
          $scope.updateComponent(newValue, currentKey);
          currentKey = newValue.key;
        }
      });
    }
  ]);

  app.run([
    '$templateCache',
    function($templateCache) {
      // Create the settings markup.
      $templateCache.put('formio/components/custom/display.html',
        '<ng-form>' +
        '<div class="form-group">' +
        '<p>Custom components can be used to render special fields or widgets inside your app. For information on how to display in an app, see <a href="http://help.form.io/userguide/#custom" target="_blank">custom component documentation</a>.</p>' +
        '<label for="json" form-builder-tooltip="Enter the JSON for this custom element.">Custom Element JSON</label>' +
        '<textarea ng-controller="customComponent" class="form-control" id="json" name="json" json-input ng-model="customComponent" placeholder="{}" rows="10"></textarea>' +
        '</div>' +
        '</ng-form>'
      );
    }
  ]);
};

},{}],219:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('datagrid', {
        fbtemplate: 'formio/formbuilder/datagrid.html',
        icon: 'fa fa-th',
        views: [
          {
            name: 'Display',
            template: 'formio/components/datagrid/display.html'
          },
          {
            name: 'Validation',
            template: 'formio/components/datagrid/validate.html'
          },
          {
            name: 'API',
            template: 'formio/components/common/api.html'
          },
          {
            name: 'Conditional',
            template: 'formio/components/common/conditional.html'
          }
        ],
        documentation: 'http://help.form.io/userguide/#datagrid',
        noDndOverlay: true,
        confirmRemove: true
      });
    }
  ]);

  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/components/datagrid/display.html',
        '<ng-form>' +
        '<form-builder-option property="label"></form-builder-option>' +
        '<form-builder-option property="addAnother"></form-builder-option>' +
        '<form-builder-option property="customClass"></form-builder-option>' +
        '<form-builder-option property="striped"></form-builder-option>' +
        '<form-builder-option property="bordered"></form-builder-option>' +
        '<form-builder-option property="hover"></form-builder-option>' +
        '<form-builder-option property="condensed"></form-builder-option>' +
        '<form-builder-option property="clearOnHide"></form-builder-option>' +
        '<form-builder-option property="protected"></form-builder-option>' +
        '<form-builder-option property="persistent"></form-builder-option>' +
        '<form-builder-option property="hidden"></form-builder-option>' +
        '<form-builder-option property="disabled"></form-builder-option>' +
        '<form-builder-option property="tableView"></form-builder-option>' +
        '</ng-form>'
      );

      $templateCache.put('formio/components/datagrid/validate.html',
        '<ng-form>' +
        '<form-builder-option property="validate.minLength"></form-builder-option>' +
        '<form-builder-option property="validate.maxLength"></form-builder-option>' +
        '<form-builder-option-custom-validation></form-builder-option-custom-validation>' +
        '</ng-form>'
      );
    }
  ]);
};

},{}],220:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('datetime', {
        onEdit: ['$scope', function($scope) {
          // FOR-34 - Update 12hr time display in the field, not only time picker.
          $scope.$watch('component.timePicker.showMeridian', function(value) {
            var _old = value ? 'HH' : 'hh';
            var _new = !value ? 'HH' : 'hh';

            if ($scope.component.enableTime) {
              $scope.component.format = $scope.component.format.toString().replace(_old, _new);
            }
          });

          $scope.setFormat = function() {
            var stdFormatDateTime = 'yyyy-MM-dd HH:mm';
            var stdFormatDate     = 'yyyy-MM-dd';
            var stdFormatTime     = 'HH:mm';
            if ($scope.component.timePicker.showMeridian) {
                stdFormatDateTime = 'yyyy-MM-dd hh:mm';
                stdFormatTime     = 'hh:mm';
            }
            var stdFormats        = [stdFormatDateTime, stdFormatDate, stdFormatTime];

            if ($scope.component.enableDate && $scope.component.enableTime && stdFormats.indexOf($scope.component.format) !== -1) {
              $scope.component.format = stdFormatDateTime;
            }
            else if ($scope.component.enableDate && !$scope.component.enableTime && stdFormats.indexOf($scope.component.format) !== -1) {
              $scope.component.format = stdFormatDate;
            }
            else if (!$scope.component.enableDate && $scope.component.enableTime && stdFormats.indexOf($scope.component.format) !== -1) {
              $scope.component.format = stdFormatTime;
            }
          };
          $scope.startingDays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
          $scope.modes = [
            {
              name: 'day',
              label: 'Day'
            },
            {
              name: 'month',
              label: 'Month'
            },
            {
              name: 'year',
              label: 'Year'
            }
          ];
        }],
        icon: 'fa fa-clock-o',
        views: [
          {
            name: 'Display',
            template: 'formio/components/datetime/display.html'
          },
          {
            name: 'Date',
            template: 'formio/components/datetime/date.html'
          },
          {
            name: 'Time',
            template: 'formio/components/datetime/time.html'
          },
          {
            name: 'Validation',
            template: 'formio/components/datetime/validate.html'
          },
          {
            name: 'API',
            template: 'formio/components/common/api.html'
          },
          {
            name: 'Layout',
            template: 'formio/components/common/layout.html'
          },
          {
            name: 'Conditional',
            template: 'formio/components/common/conditional.html'
          }
        ],
        documentation: 'http://help.form.io/userguide/#datetime'
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      // Create the settings markup.
      $templateCache.put('formio/components/datetime/display.html',
        '<ng-form>' +
          '<form-builder-option property="label"></form-builder-option>' +
          '<form-builder-option property="defaultDate"></form-builder-option>' +
          '<form-builder-option property="placeholder"></form-builder-option>' +
          '<form-builder-option property="description"></form-builder-option>' +
          '<form-builder-option property="format" label="Date Format" placeholder="Enter the Date format" title="The format for displaying this field\'s date. The format must be specified like the <a href=\'https://docs.angularjs.org/api/ng/filter/date\' target=\'_blank\'>AngularJS date filter</a>."></form-builder-option>' +
          '<form-builder-option property="customClass"></form-builder-option>' +
          '<form-builder-option property="tabindex"></form-builder-option>' +
          '<form-builder-option property="clearOnHide"></form-builder-option>' +
          '<form-builder-option property="protected"></form-builder-option>' +
          '<form-builder-option property="persistent"></form-builder-option>' +
          '<form-builder-option property="hidden"></form-builder-option>' +
          '<form-builder-option property="disabled"></form-builder-option>' +
          '<form-builder-option property="tableView"></form-builder-option>' +
        '</ng-form>'
      );

      $templateCache.put('formio/components/datetime/date.html',
        '<ng-form>' +
          '<div class="checkbox">' +
            '<label form-builder-tooltip="Enables date input for this field.">' +
              '<input type="checkbox" id="enableDate" name="enableDate" ng-model="component.enableDate" ng-checked="component.enableDate" ng-change="setFormat()"> Enable Date Input' +
            '</label>' +
          '</div>' +
          '<div class="form-group">' +
            '<label for="placeholder" form-builder-tooltip="The minimum date that can be picked.">Minimum Date</label>' +
            '<div class="input-group">' +
              '<input type="text" class="form-control" ' +
                'ng-focus="minDateOpen = true" ' +
                'ng-init="minDateOpen = false" ' +
                'is-open="minDateOpen" ' +
                'datetime-picker="yyyy-MM-dd" ' +
                'enable-time="false" ' +
                'ng-model="component.datePicker.minDate" />' +
              '<span class="input-group-btn">' +
                '<button type="button" class="btn btn-default" ng-click="minDateOpen = true"><i class="fa fa-calendar"></i></button>' +
              '</span>' +
            '</div>' +
          '</div>' +
          '<div class="form-group">' +
            '<label for="placeholder"  form-builder-tooltip="The maximum date that can be picked.">Maximum Date</label>' +
            '<div class="input-group">' +
              '<input type="text" class="form-control" ' +
                'ng-focus="maxDateOpen = true" ' +
                'ng-init="maxDateOpen = false" ' +
                'is-open="maxDateOpen" ' +
                'datetime-picker="yyyy-MM-dd" ' +
                'enable-time="false" ' +
                'ng-model="component.datePicker.maxDate" />' +
              '<span class="input-group-btn">' +
                '<button type="button" class="btn btn-default" ng-click="maxDateOpen = true"><i class="fa fa-calendar"></i></button>' +
              '</span>' +
            '</div>' +
          '</div>' +
          '<div class="form-group">' +
            '<label for="startingDay" form-builder-tooltip="The first day of the week.">Starting Day</label>' +
            '<select class="form-control" id="startingDay" name="startingDay" ng-model="component.datePicker.startingDay" ng-options="idx as day for (idx, day) in startingDays"></select>' +
          '</div>' +
          '<div class="form-group">' +
            '<label for="minMode" form-builder-tooltip="The smallest unit of time view to display in the date picker.">Minimum Mode</label>' +
            '<select class="form-control" id="minMode" name="minMode" ng-model="component.datePicker.minMode" ng-options="mode.name as mode.label for mode in modes"></select>' +
          '</div>' +
          '<div class="form-group">' +
            '<label for="maxMode" form-builder-tooltip="The largest unit of time view to display in the date picker.">Maximum Mode</label>' +
            '<select class="form-control" id="maxMode" name="maxMode" ng-model="component.datePicker.maxMode" ng-options="mode.name as mode.label for mode in modes"></select>' +
          '</div>' +
          '<form-builder-option property="datePicker.yearRows" label="Number of Years Displayed (Rows)" placeholder="Year Range (Rows)" title="The number of years to display in the years view (Rows)."></form-builder-option>' +
          '<form-builder-option property="datePicker.yearColumns" label="Number of Years Displayed (Columns)" placeholder="Year Range (Columns)" title="The number of years to display in the years view (Columns)."></form-builder-option>' +
          '<form-builder-option property="datePicker.showWeeks" type="checkbox" label="Show Week Numbers" title="Displays the week numbers on the date picker."></form-builder-option>' +
        '</ng-form>'
      );

      $templateCache.put('formio/components/datetime/time.html',
        '<ng-form>' +
          '<div class="checkbox">' +
            '<label form-builder-tooltip="Enables time input for this field.">' +
              '<input type="checkbox" id="enableTime" name="enableTime" ng-model="component.enableTime" ng-checked="component.enableTime" ng-change="setFormat()"> Enable Time Input' +
            '</label>' +
          '</div>' +
          '<form-builder-option property="timePicker.hourStep" type="number" label="Hour Step Size" title="The number of hours to increment/decrement in the time picker."></form-builder-option>' +
          '<form-builder-option property="timePicker.minuteStep" type="number" label="Minute Step Size" title="The number of minutes to increment/decrement in the time picker."></form-builder-option>' +
          '<form-builder-option property="timePicker.showMeridian" type="checkbox" label="12 Hour Time (AM/PM)" title="Display time in 12 hour time with AM/PM."></form-builder-option>' +
          '<form-builder-option property="timePicker.readonlyInput" type="checkbox" label="Read-Only Input" title="Makes the time picker input boxes read-only. The time can only be changed by the increment/decrement buttons."></form-builder-option>' +
        '</ng-form>'
      );

      $templateCache.put('formio/components/datetime/validate.html',
        '<ng-form>' +
          '<form-builder-option property="validate.required"></form-builder-option>' +
          '<form-builder-option-custom-validation></form-builder-option-custom-validation>' +
        '</ng-form>'
      );
    }
  ]);
};

},{}],221:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('day', {
        icon: 'fa fa-calendar',
        views: [
          {
            name: 'Display',
            template: 'formio/components/day/display.html'
          },
          {
            name: 'Data',
            template: 'formio/components/common/data.html'
          },
          {
            name: 'Validation',
            template: 'formio/components/day/validate.html'
          },
          {
            name: 'API',
            template: 'formio/components/common/api.html'
          },
          {
            name: 'Layout',
            template: 'formio/components/common/layout.html'
          },
          {
            name: 'Conditional',
            template: 'formio/components/common/conditional.html'
          }
        ],
        documentation: 'http://help.form.io/userguide/#day'
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      // Create the settings markup.
      $templateCache.put('formio/components/day/display.html',
        '<ng-form>' +
          '<form-builder-option property="label"></form-builder-option>' +
          '<form-builder-option property="fields.day.placeholder" label="Day Placeholder"></form-builder-option>' +
          '<form-builder-option property="fields.month.placeholder" label="Month Placeholder"></form-builder-option>' +
          '<form-builder-option property="fields.year.placeholder" label="Year Placeholder"></form-builder-option>' +
          '<form-builder-option property="dayFirst" type="checkbox" label="Day first" title="Display the Day field before the Month field."></form-builder-option>' +
          '<form-builder-option property="fields.day.hide" type="checkbox" label="Hide Day" title="Hide the day part of the component."></form-builder-option>' +
          '<form-builder-option property="fields.month.hide" type="checkbox" label="Hide Month" title="Hide the month part of the component."></form-builder-option>' +
          '<form-builder-option property="fields.year.hide" type="checkbox" label="Hide Year" title="Hide the year part of the component."></form-builder-option>' +
          '<form-builder-option property="customClass"></form-builder-option>' +
          '<form-builder-option property="tabindex"></form-builder-option>' +
          '<form-builder-option property="clearOnHide"></form-builder-option>' +
          '<form-builder-option property="protected"></form-builder-option>' +
          '<form-builder-option property="persistent"></form-builder-option>' +
          '<form-builder-option property="hidden"></form-builder-option>' +
          '<form-builder-option property="disabled"></form-builder-option>' +
          '<form-builder-option property="tableView"></form-builder-option>' +
        '</ng-form>'
      );

      $templateCache.put('formio/components/day/validate.html',
        '<ng-form>' +
          '<form-builder-option property="fields.day.required" label="Require Day" type="checkbox"></form-builder-option>' +
          '<form-builder-option property="fields.month.required" label="Require Month" type="checkbox"></form-builder-option>' +
          '<form-builder-option property="fields.year.required" label="Require Year" type="checkbox"></form-builder-option>' +
          '<form-builder-option-custom-validation></form-builder-option-custom-validation>' +
        '</ng-form>'
      );
    }
  ]);
};

},{}],222:[function(_dereq_,module,exports){
"use strict";
var _cloneDeep = _dereq_('lodash/cloneDeep');
var _each = _dereq_('lodash/each');
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      var views = _cloneDeep(formioComponentsProvider.$get().components.textfield.views);
      _each(views, function(view) {
        if (view.name === 'Validation') {
          view.template = 'formio/components/email/validate.html';
        }
      });
      formioComponentsProvider.register('email', {
        icon: 'fa fa-at',
        views: views,
        documentation: 'http://help.form.io/userguide/#email'
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/components/email/validate.html',
        '<ng-form>' +
          '<form-builder-option property="validate.required"></form-builder-option>' +
          '<form-builder-option property="unique"></form-builder-option>' +
          '<div class="panel panel-default">' +
            '<div class="panel-heading"><h3 class="panel-title">Kickbox</h3></div>' +
            '<div class="panel-body">' +
              '<p>Validate this email using the Kickbox email validation service.</p>' +
              '<div class="checkbox">' +
                '<label for="kickbox-enable" form-builder-tooltip="Enable Kickbox validation for this email field.">' +
                  '<input type="checkbox" id="kickbox-enable" name="kickbox-enable" ng-model="component.kickbox.enabled"> Enable' +
                '</label>' +
              '</div>' +
            '</div>' +
          '</div>' +
          '<form-builder-option property="validate.minLength"></form-builder-option>' +
          '<form-builder-option property="validate.maxLength"></form-builder-option>' +
          '<form-builder-option property="validate.pattern"></form-builder-option>' +
          '<form-builder-option-custom-validation></form-builder-option-custom-validation>' +
        '</ng-form>'
      );
    }
  ]);
};

},{"lodash/cloneDeep":171,"lodash/each":174}],223:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('fieldset', {
        fbtemplate: 'formio/formbuilder/fieldset.html',
        icon: 'fa fa-th-large',
        views: [
          {
            name: 'Display',
            template: 'formio/components/fieldset/display.html'
          },
          {
            name: 'Layout',
            template: 'formio/components/common/layout.html'
          },
          {
            name: 'API',
            template: 'formio/components/common/api.html'
          },
          {
            name: 'Conditional',
            template: 'formio/components/common/conditional.html'
          }
        ],
        documentation: 'http://help.form.io/userguide/#fieldset',
        keepChildrenOnRemove: true,
        noDndOverlay: true,
        confirmRemove: true
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/formbuilder/fieldset.html',
        '<fieldset>' +
          '<legend ng-if="component.legend">{{ component.legend }}</legend>' +
          '<form-builder-list component="component" form="form" formio="::formio"></form-builder-list>' +
        '</fieldset>'
      );

      // Create the settings markup.
      $templateCache.put('formio/components/fieldset/display.html',
        '<ng-form>' +
          '<form-builder-option property="legend" label="Legend" placeholder="FieldSet Legend" title="The legend text to appear above this fieldset."></form-builder-option>' +
          '<form-builder-option property="customClass"></form-builder-option>' +
        '</ng-form>'
      );
    }
  ]);
};

},{}],224:[function(_dereq_,module,exports){
"use strict";
var _map = _dereq_('lodash/map');
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(
      formioComponentsProvider
    ) {
      formioComponentsProvider.register('file', {
        onEdit: [
          '$scope',
          'Formio',
          function($scope, Formio) {
            // Pull out title and name from the list of storage plugins.
            $scope.storage = _map(Formio.providers.storage, function(storage, key) {
              return {
                title: storage.title,
                name: key
              };
            });
          }
        ],
        icon: 'fa fa-file',
        views: [
          {
            name: 'Display',
            template: 'formio/components/file/display.html'
          },
          {
            name: 'Validation',
            template: 'formio/components/file/validate.html'
          },
          {
            name: 'API',
            template: 'formio/components/common/api.html'
          },
          {
            name: 'Layout',
            template: 'formio/components/common/layout.html'
          },
          {
            name: 'Conditional',
            template: 'formio/components/common/conditional.html'
          }
        ],
        documentation: 'http://help.form.io/userguide/#file'
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      // Create the settings markup.
      $templateCache.put('formio/components/file/display.html',
        '<ng-form>' +
          '<form-builder-option property="label"></form-builder-option>' +
          '<div class="form-group">' +
            '<label for="storage" form-builder-tooltip="Which storage to save the files in.">Storage</label>' +
            '<select class="form-control" id="storage" name="storage" ng-options="store.name as store.title for store in storage" ng-model="component.storage"></select>' +
          '</div>' +
          '<form-builder-option property="url" ng-show="component.storage === \'url\'"></form-builder-option>' +
          '<form-builder-option property="dir"></form-builder-option>' +
          '<form-builder-option property="image"></form-builder-option>' +
          '<form-builder-option property="imageSize" ng-if="component.image"></form-builder-option>' +
          '<form-builder-option property="customClass"></form-builder-option>' +
          '<form-builder-option property="tabindex"></form-builder-option>' +
          '<form-builder-option property="multiple"></form-builder-option>' +
          '<form-builder-option property="clearOnHide"></form-builder-option>' +
          '<form-builder-option property="protected"></form-builder-option>' +
          '<form-builder-option property="persistent"></form-builder-option>' +
          '<form-builder-option property="hidden"></form-builder-option>' +
          '<form-builder-option property="disabled"></form-builder-option>' +
          '<form-builder-option property="tableView"></form-builder-option>' +
        '</ng-form>'
      );

      $templateCache.put('formio/components/file/validate.html',
        '<ng-form>' +
          '<form-builder-option property="validate.required"></form-builder-option>' +
        '</ng-form>'
      );
    }
  ]);
};

},{"lodash/map":196}],225:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('form', {
        fbtemplate: 'formio/formbuilder/form.html',
        icon: 'fa fa-wpforms',
        views: [
          {
            name: 'Display',
            template: 'formio/components/form/display.html'
          },
          {
            name: 'Data',
            template: 'formio/components/common/data.html'
          },
          {
            name: 'API',
            template: 'formio/components/common/api.html'
          },
          {
            name: 'Conditional',
            template: 'formio/components/common/conditional.html'
          }
        ],
        documentation: 'http://help.form.io/userguide/#form',
        onEdit: ['$scope', function($scope) {
          $scope.forms = [];
          $scope.component.project = $scope.formio.projectId;
          $scope.formio.loadForms({params: {limit: 100}}).then(function(forms) {
            $scope.forms = forms;
            if (!$scope.component.form) {
              $scope.component.form = forms[0]._id;
            }
          });
        }]
      });

      // Override the controller for form building.
      var formComponent = formioComponentsProvider.$get().components.form;
      var formController = formComponent.controller;
      formComponent.controller = [
        '$scope',
        '$controller',
        function(
          $scope,
          $controller
        ) {
          if (!$scope.builder) {
            return $controller(formController, {$scope: $scope});
          }

          $scope.form = {};
          $scope.formio.loadForms({params: {limit: 100}}).then(function(forms) {
            angular.forEach(forms, function(form) {
              if (form._id === $scope.component.form) {
                $scope.form = form;
              }
            });
          });
        }
      ];
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/formbuilder/form.html', '<span class="hidden-element-text">{{ form.title }} {{ form.type }}</span>');

      // Create the settings markup.
      $templateCache.put('formio/components/form/display.html',
        '<ng-form>' +
          '<form-builder-option property="label" label="Name" placeholder="Enter the name for this form field" title="The name for this field. It is only used for administrative purposes such as generating the automatic property name in the API tab (which may be changed manually)."></form-builder-option>' +
          '<div class="form-group">' +
            '<label for="form" form-builder-tooltip="The form to load within this form component..">Form</label>' +
            '<select class="form-control" id="form" name="form" ng-options="value._id as value.title for value in forms" ng-model="component.form"></select>' +
          '</div>' +
          '<form-builder-option property="customClass"></form-builder-option>' +
          '<form-builder-option property="reference"></form-builder-option>' +
          '<form-builder-option property="protected"></form-builder-option>' +
          '<form-builder-option property="persistent"></form-builder-option>' +
          '<form-builder-option property="tableView"></form-builder-option>' +
        '</ng-form>'
      );
    }
  ]);
};

},{}],226:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('hidden', {
        fbtemplate: 'formio/formbuilder/hidden.html',
        icon: 'fa fa-user-secret',
        views: [
          {
            name: 'Display',
            template: 'formio/components/hidden/display.html'
          },
          {
            name: 'Data',
            template: 'formio/components/common/data.html'
          },
          {
            name: 'Validation',
            template: 'formio/components/hidden/validation.html'
          },
          {
            name: 'API',
            template: 'formio/components/common/api.html'
          },
          {
            name: 'Conditional',
            template: 'formio/components/common/conditional.html'
          }
        ],
        documentation: 'http://help.form.io/userguide/#hidden'
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/formbuilder/hidden.html', '<span class="hidden-element-text">{{ component.label }}</span>');

      // Create the settings markup.
      $templateCache.put('formio/components/hidden/display.html',
        '<ng-form>' +
          '<form-builder-option property="label" label="Name" placeholder="Enter the name for this hidden field" title="The name for this field. It is only used for administrative purposes such as generating the automatic property name in the API tab (which may be changed manually)."></form-builder-option>' +
          '<form-builder-option property="customClass"></form-builder-option>' +
          '<form-builder-option property="protected"></form-builder-option>' +
          '<form-builder-option property="persistent"></form-builder-option>' +
          '<form-builder-option property="tableView"></form-builder-option>' +
        '</ng-form>'
      );

      $templateCache.put('formio/components/hidden/validation.html',
        '<ng-form>' +
          '<form-builder-option property="unique"></form-builder-option>' +
        '</ng-form>'
      );
    }
  ]);
};

},{}],227:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('htmlelement', {
        fbtemplate: 'formio/formbuilder/htmlelement.html',
        icon: 'fa fa-code',
        views: [
          {
            name: 'Display',
            template: 'formio/components/htmlelement/display.html'
          },
          {
            name: 'API',
            template: 'formio/components/common/api.html'
          },
          {
            name: 'Conditional',
            template: 'formio/components/common/conditional.html'
          }
        ],
        documentation: 'http://help.form.io/userguide/#html-element-component'
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/formbuilder/htmlelement.html',
        '<formio-html-element component="component"></div>'
      );

      // Create the settings markup.
      $templateCache.put('formio/components/htmlelement/display.html',
        '<ng-form>' +
        '<form-builder-option property="customClass" label="Container Custom Class"></form-builder-option>' +
          '<form-builder-option property="tag" label="HTML Tag" placeholder="HTML Element Tag" title="The tag of this HTML element."></form-builder-option>' +
          '<form-builder-option property="className" label="CSS Class" placeholder="CSS Class" title="The CSS class for this HTML element."></form-builder-option>' +
          '<value-builder ' +
            'data="component.attrs" ' +
            'label="Attributes" ' +
            'tooltip-text="The attributes for this HTML element. Only safe attributes are allowed, such as src, href, and title." ' +
            'value-property="value" ' +
            'label-property="attr" ' +
            'value-label="Value" ' +
            'label-label="Attribute" ' +
            'no-autocomplete-value="true" ' +
          '></value-builder>' +
          '<div class="form-group">' +
            '<label for="content" form-builder-tooltip="The content of this HTML element.">Content</label>' +
            '<textarea class="form-control" id="content" name="content" ng-model="component.content" placeholder="HTML Content" rows="3">{{ component.content }}</textarea>' +
          '</div>' +
        '</ng-form>'
      );
    }
  ]);
};

},{}],228:[function(_dereq_,module,exports){
"use strict";
var app = angular.module('ngFormBuilder');

// Basic
_dereq_('./components')(app);
_dereq_('./textfield')(app);
_dereq_('./number')(app);
_dereq_('./password')(app);
_dereq_('./textarea')(app);
_dereq_('./checkbox')(app);
_dereq_('./selectboxes')(app);
_dereq_('./select')(app);
_dereq_('./radio')(app);
_dereq_('./htmlelement')(app);
_dereq_('./content')(app);
_dereq_('./button')(app);

// Special
_dereq_('./email')(app);
_dereq_('./phonenumber')(app);
_dereq_('./address')(app);
_dereq_('./datetime')(app);
_dereq_('./day')(app);
_dereq_('./currency')(app);
_dereq_('./hidden')(app);
_dereq_('./resource')(app);
_dereq_('./file')(app);
_dereq_('./form')(app);
_dereq_('./signature')(app);
_dereq_('./custom')(app);
_dereq_('./datagrid')(app);
_dereq_('./survey')(app);

// Layout
_dereq_('./columns')(app);
_dereq_('./fieldset')(app);
_dereq_('./container')(app);
_dereq_('./page')(app);
_dereq_('./panel')(app);
_dereq_('./table')(app);
_dereq_('./well')(app);

},{"./address":210,"./button":211,"./checkbox":212,"./columns":213,"./components":214,"./container":215,"./content":216,"./currency":217,"./custom":218,"./datagrid":219,"./datetime":220,"./day":221,"./email":222,"./fieldset":223,"./file":224,"./form":225,"./hidden":226,"./htmlelement":227,"./number":229,"./page":230,"./panel":231,"./password":232,"./phonenumber":233,"./radio":234,"./resource":235,"./select":236,"./selectboxes":237,"./signature":238,"./survey":239,"./table":240,"./textarea":241,"./textfield":242,"./well":243}],229:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('number', {
        icon: 'fa fa-hashtag',
        views: [
          {
            name: 'Display',
            template: 'formio/components/number/display.html'
          },
          {
            name: 'Data',
            template: 'formio/components/common/data.html'
          },
          {
            name: 'Validation',
            template: 'formio/components/number/validate.html'
          },
          {
            name: 'API',
            template: 'formio/components/common/api.html'
          },
          {
            name: 'Layout',
            template: 'formio/components/common/layout.html'
          },
          {
            name: 'Conditional',
            template: 'formio/components/common/conditional.html'
          }
        ],
        documentation: 'http://help.form.io/userguide/#number'
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      // Create the settings markup.
      $templateCache.put('formio/components/number/display.html',
        '<ng-form>' +
          '<form-builder-option property="label"></form-builder-option>' +
          '<form-builder-option property="placeholder"></form-builder-option>' +
          '<form-builder-option property="description"></form-builder-option>' +
          '<form-builder-option property="validate.step" label="Increment (Step)" placeholder="Enter how much to increment per step (or precision)." title="The amount to increment/decrement for each step."></form-builder-option>' +
          '<form-builder-option property="prefix"></form-builder-option>' +
          '<form-builder-option property="suffix"></form-builder-option>' +
          '<form-builder-option property="customClass"></form-builder-option>' +
          '<form-builder-option property="tabindex"></form-builder-option>' +
          '<form-builder-option property="multiple"></form-builder-option>' +
          '<form-builder-option property="clearOnHide"></form-builder-option>' +
          '<form-builder-option property="protected"></form-builder-option>' +
          '<form-builder-option property="persistent"></form-builder-option>' +
          '<form-builder-option property="hidden"></form-builder-option>' +
          '<form-builder-option property="disabled"></form-builder-option>' +
          '<form-builder-option property="tableView"></form-builder-option>' +
        '</ng-form>'
      );

      // Create the API markup.
      $templateCache.put('formio/components/number/validate.html',
        '<ng-form>' +
          '<form-builder-option property="validate.required"></form-builder-option>' +
          '<form-builder-option property="validate.min" type="number" label="Minimum Value" placeholder="Minimum Value" title="The minimum value this field must have before the form can be submitted."></form-builder-option>' +
          '<form-builder-option property="validate.max" type="number" label="Maximum Value" placeholder="Maximum Value" title="The maximum value this field must have before the form can be submitted."></form-builder-option>' +
          '<form-builder-option-custom-validation></form-builder-option-custom-validation>' +
        '</ng-form>'
      );
    }
  ]);
};

},{}],230:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('page', {
        fbtemplate: 'formio/formbuilder/page.html'
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/formbuilder/page.html',
        '<form-builder-list component="component" form="form" formio="::formio"></form-builder-list>'
      );
    }
  ]);
};

},{}],231:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    'FORM_OPTIONS',
    function(
      formioComponentsProvider,
      FORM_OPTIONS
    ) {
      formioComponentsProvider.register('panel', {
        fbtemplate: 'formio/formbuilder/panel.html',
        icon: 'fa fa-list-alt',
        onEdit: ['$scope', function($scope) {
          $scope.themes = FORM_OPTIONS.themes;
          if (!$scope.component.breadcrumb) {
            $scope.component.breadcrumb = 'default';
          }
          $scope.breadcrumbs = [
            {
              name: 'default',
              title: 'Yes'
            },
            {
              name: 'none',
              title: 'No'
            }
          ];
        }],
        views: [
          {
            name: 'Display',
            template: 'formio/components/panel/display.html'
          },
          {
            name: 'Layout',
            template: 'formio/components/common/layout.html'
          },
          {
            name: 'API',
            template: 'formio/components/common/api.html'
          },
          {
            name: 'Conditional',
            template: 'formio/components/panel/conditional.html'
          }
        ],
        documentation: 'http://help.form.io/userguide/#panels',
        noDndOverlay: true,
        confirmRemove: true
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/formbuilder/panel.html',
        '<div class="panel panel-{{ component.theme }}">' +
          '<div ng-if="component.title" class="panel-heading"><h3 class="panel-title">{{ component.title }}</h3></div>' +
          '<div class="panel-body">' +
            '<form-builder-list component="component" form="form" formio="::formio"></form-builder-list>' +
          '</div>' +
        '</div>'
      );

      // Create the settings markup.
      $templateCache.put('formio/components/panel/display.html',
        '<ng-form>' +
          '<form-builder-option property="title" label="Title" placeholder="Panel Title" title="The title text that appears in the header of this panel."></form-builder-option>' +
          '<div class="form-group">' +
            '<label for="theme" form-builder-tooltip="The color theme of this panel.">Theme</label>' +
            '<select class="form-control" id="theme" name="theme" ng-options="theme.name as theme.title for theme in themes" ng-model="component.theme"></select>' +
          '</div>' +
          '<div class="form-group">' +
            '<label for="breadcrumb" form-builder-tooltip="The breadcrumb to show with this page.">Show Breadcrumb</label>' +
            '<select class="form-control" id="breadcrumb" name="breadcrumb" ng-options="breadcrumb.name as breadcrumb.title for breadcrumb in breadcrumbs" ng-model="component.breadcrumb"></select>' +
          '</div>' +
          '<form-builder-option property="customClass"></form-builder-option>' +
        '</ng-form>'
      );

      $templateCache.put('formio/components/panel/conditional.html',
        '<form-builder-conditional></form-builder-conditional>' +
        '<uib-accordion>' +
          '<div uib-accordion-group heading="Advanced Next Page" class="panel panel-default">' +
            '<textarea class="form-control" rows="5" id="custom" name="custom" ng-model="component.nextPage" placeholder="/*** Example Code ***/\nnext = (data[\'mykey\'] > 1) ? \'pageA\' : \'pageB\';"></textarea>' +
            '<small>' +
              '<p>Enter custom conditional code.</p>' +
              '<p>You must assign the <strong>next</strong> variable with the API key of the next page.</p>' +
              '<p>The global variable <strong>data</strong> is provided, and allows you to access the data of any form component, by using its API key.</p>' +
            '</small>' +
          '</div>' +
          '<div uib-accordion-group heading="JSON Next Page" class="panel panel-default">' +
            '<small>' +
              '<p>Execute custom next page with JSON and <a href="http://jsonlogic.com/">JsonLogic</a>.</p>' +
              '<p>Submission data is available as JsonLogic variables, with the same api key as your components.</p>' +
              '<p><a href="http://formio.github.io/formio.js/app/examples/multiform.html" target="_blank">Click here for an example</a></p>' +
            '</small>' +
            '<textarea class="form-control" rows="5" id="json" name="json" json-input ng-model="component.nextPage" placeholder="{ ... }"></textarea>' +
          '</div>' +
        '</uib-accordion>'
      );
    }
  ]);
};

},{}],232:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('password', {
        icon: 'fa fa-asterisk',
        views: [
          {
            name: 'Display',
            template: 'formio/components/password/display.html'
          },
          {
            name: 'Validation',
            template: 'formio/components/textfield/validate.html'
          },
          {
            name: 'API',
            template: 'formio/components/common/api.html'
          },
          {
            name: 'Layout',
            template: 'formio/components/common/layout.html'
          },
          {
            name: 'Conditional',
            template: 'formio/components/common/conditional.html'
          }
        ],
        documentation: 'http://help.form.io/userguide/#password',
        template: 'formio/components/password.html'
      });
    }
  ]);
  app.run([
    '$templateCache',
    function(
      $templateCache
    ) {
      // Disable dragging on password inputs because it breaks dndLists
      var textFieldTmpl = $templateCache.get('formio/components/textfield.html');
      var passwordTmpl = textFieldTmpl.replace(
        /<input type="{{ component.inputType }}" /g,
        '<input type="{{ component.inputType }}" dnd-nodrag '
      );
      $templateCache.put('formio/components/password.html', passwordTmpl);

      // Create the settings markup.
      $templateCache.put('formio/components/password/display.html',
        '<ng-form>' +
          '<form-builder-option property="label"></form-builder-option>' +
          '<form-builder-option property="placeholder"></form-builder-option>' +
          '<form-builder-option property="description"></form-builder-option>' +
          '<form-builder-option property="prefix"></form-builder-option>' +
          '<form-builder-option property="suffix"></form-builder-option>' +
          '<form-builder-option property="customClass"></form-builder-option>' +
          '<form-builder-option property="tabindex"></form-builder-option>' +
          '<form-builder-option property="clearOnHide"></form-builder-option>' +
          '<form-builder-option property="protected"></form-builder-option>' +
          '<form-builder-option property="persistent"></form-builder-option>' +
          '<form-builder-option property="hidden"></form-builder-option>' +
          '<form-builder-option property="disabled"></form-builder-option>' +
          '<form-builder-option property="tableView"></form-builder-option>' +
        '</ng-form>'
      );
    }
  ]);
};

},{}],233:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('phoneNumber', {
        icon: 'fa fa-phone-square',
        views: [
          {
            name: 'Display',
            template: 'formio/components/phoneNumber/display.html'
          },
          {
            name: 'Data',
            template: 'formio/components/common/data.html'
          },
          {
            name: 'Validation',
            template: 'formio/components/phoneNumber/validate.html'
          },
          {
            name: 'API',
            template: 'formio/components/common/api.html'
          },
          {
            name: 'Layout',
            template: 'formio/components/common/layout.html'
          },
          {
            name: 'Conditional',
            template: 'formio/components/common/conditional.html'
          }
        ],
        documentation: 'http://help.form.io/userguide/#phonenumber'
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      // Create the settings markup.
      $templateCache.put('formio/components/phoneNumber/display.html',
        '<ng-form>' +
          '<form-builder-option property="label"></form-builder-option>' +
          '<form-builder-option property="placeholder"></form-builder-option>' +
          '<form-builder-option property="description"></form-builder-option>' +
          '<form-builder-option property="inputMask"></form-builder-option>' +
          '<form-builder-option property="prefix"></form-builder-option>' +
          '<form-builder-option property="suffix"></form-builder-option>' +
          '<form-builder-option property="customClass"></form-builder-option>' +
          '<form-builder-option property="tabindex"></form-builder-option>' +
          '<form-builder-option property="multiple"></form-builder-option>' +
          '<form-builder-option property="clearOnHide"></form-builder-option>' +
          '<form-builder-option property="protected"></form-builder-option>' +
          '<form-builder-option property="persistent"></form-builder-option>' +
          '<form-builder-option property="hidden"></form-builder-option>' +
          '<form-builder-option property="disabled"></form-builder-option>' +
          '<form-builder-option property="tableView"></form-builder-option>' +
        '</ng-form>'
      );

      // Create the Validation markup.
      $templateCache.put('formio/components/phoneNumber/validate.html',
        '<ng-form>' +
          '<form-builder-option property="validate.required"></form-builder-option>' +
          '<form-builder-option property="unique"></form-builder-option>' +
        '</ng-form>'
      );
    }
  ]);
};

},{}],234:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('radio', {
        icon: 'fa fa-dot-circle-o',
        views: [
          {
            name: 'Display',
            template: 'formio/components/radio/display.html'
          },
          {
            name: 'Data',
            template: 'formio/components/common/data.html'
          },
          {
            name: 'Validation',
            template: 'formio/components/radio/validate.html'
          },
          {
            name: 'API',
            template: 'formio/components/common/api.html'
          },
          {
            name: 'Layout',
            template: 'formio/components/common/layout.html'
          },
          {
            name: 'Conditional',
            template: 'formio/components/common/conditional.html'
          }
        ],
        documentation: 'http://help.form.io/userguide/#radio'
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      // Create the settings markup.
      $templateCache.put('formio/components/radio/display.html',
        '<ng-form>' +
          '<form-builder-option property="label"></form-builder-option>' +
          '<value-builder data="component.values" default="component.defaultValue" label="Values" tooltip-text="The radio button values that can be picked for this field. Values are text submitted with the form data. Labels are text that appears next to the radio buttons on the form."></value-builder>' +
          '<form-builder-option property="customClass"></form-builder-option>' +
          '<form-builder-option property="tabindex"></form-builder-option>' +
          '<form-builder-option property="inline" type="checkbox" label="Inline Layout" title="Displays the radio buttons horizontally."></form-builder-option>' +
          '<form-builder-option property="clearOnHide"></form-builder-option>' +
          '<form-builder-option property="protected"></form-builder-option>' +
          '<form-builder-option property="persistent"></form-builder-option>' +
          '<form-builder-option property="hidden"></form-builder-option>' +
          '<form-builder-option property="disabled"></form-builder-option>' +
          '<form-builder-option property="tableView"></form-builder-option>' +
        '</ng-form>'
      );
      // Create the API markup.
      $templateCache.put('formio/components/radio/validate.html',
        '<ng-form>' +
          '<form-builder-option property="validate.required"></form-builder-option>' +
          '<form-builder-option-custom-validation></form-builder-option-custom-validation>' +
        '</ng-form>'
      );
    }
  ]);
};

},{}],235:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('resource', {
        onEdit: ['$scope', function($scope) {
          $scope.resources = [];
          $scope.component.project = $scope.formio.projectId;
          $scope.formio.loadForms({params: {type: 'resource', limit: 100}}).then(function(resources) {
            $scope.resources = resources;
            if (!$scope.component.resource) {
              $scope.component.resource = resources[0]._id;
            }
          });
        }],
        icon: 'fa fa-files-o',
        views: [
          {
            name: 'Display',
            template: 'formio/components/resource/display.html'
          },
          {
            name: 'Validation',
            template: 'formio/components/resource/validate.html'
          },
          {
            name: 'API',
            template: 'formio/components/common/api.html'
          },
          {
            name: 'Layout',
            template: 'formio/components/common/layout.html'
          },
          {
            name: 'Conditional',
            template: 'formio/components/common/conditional.html'
          }
        ],
        documentation: 'http://help.form.io/userguide/#resource'
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      // Create the settings markup.
      $templateCache.put('formio/components/resource/display.html',
        '<ng-form>' +
          '<form-builder-option property="label"></form-builder-option>' +
          '<form-builder-option property="placeholder"></form-builder-option>' +
          '<div class="form-group">' +
            '<label for="resource" form-builder-tooltip="The resource to be used with this field.">Resource</label>' +
            '<select class="form-control" id="resource" name="resource" ng-options="value._id as value.title for value in resources" ng-model="component.resource"></select>' +
          '</div>' +
          '<div class="form-group">' +
            '<label for="selectFields" form-builder-tooltip="The properties on the resource to return as part of the options. Separate property names by commas. If left blank, all properties will be returned.">Select Fields</label>' +
            '<input type="text" class="form-control" id="selectFields" name="selectFields" ng-model="component.selectFields" placeholder="Comma separated list of fields to select." value="{{ component.selectFields }}">' +
          '</div>' +
          '<div class="form-group">' +
            '<label for="searchFields" form-builder-tooltip="A list of search filters based on the fields of the resource. See the <a target=\'_blank\' href=\'https://github.com/travist/resourcejs#filtering-the-results\'>Resource.js documentation</a> for the format of these filters.">Search Fields</label>' +
            '<input type="text" class="form-control" id="searchFields" name="searchFields" ng-model="component.searchFields" ng-list placeholder="The fields to query on the server" value="{{ component.searchFields }}">' +
          '</div>' +
          '<div class="form-group">' +
            '<label for="template" form-builder-tooltip="The HTML template for the result data items.">Item Template</label>' +
            '<textarea class="form-control" id="template" name="template" ng-model="component.template" rows="3">{{ component.template }}</textarea>' +
          '</div>' +
          '<form-builder-option property="customClass"></form-builder-option>' +
          '<form-builder-option property="tabindex"></form-builder-option>' +
          '<form-builder-option property="multiple" label="Allow Multiple Resources"></form-builder-option>' +
          '<form-builder-option property="clearOnHide"></form-builder-option>' +
          '<form-builder-option property="reference"></form-builder-option>' +
          '<form-builder-option property="addResource"></form-builder-option>' +
          '<form-builder-option property="addResourceLabel" ng-if="component.addResource"></form-builder-option>' +
          '<form-builder-option property="disabled"></form-builder-option>' +
          '<form-builder-option property="hidden"></form-builder-option>' +
          '<form-builder-option property="tableView"></form-builder-option>' +
        '</ng-form>'
      );

      // Create the API markup.
      $templateCache.put('formio/components/resource/validate.html',
        '<ng-form>' +
          '<form-builder-option property="validate.required"></form-builder-option>' +
        '</ng-form>'
      );
    }
  ]);
};

},{}],236:[function(_dereq_,module,exports){
"use strict";
var _clone = _dereq_('lodash/clone');
module.exports = function (app) {
  app.config([
    'formioComponentsProvider',
    function (formioComponentsProvider) {
      formioComponentsProvider.register('select', {
        icon: 'fa fa-th-list',
        views: [
          {
            name: 'Display',
            template: 'formio/components/select/display.html'
          },
          {
            name: 'Data',
            template: 'formio/components/select/data.html'
          },
          {
            name: 'Validation',
            template: 'formio/components/select/validate.html'
          },
          {
            name: 'API',
            template: 'formio/components/common/api.html'
          },
          {
            name: 'Layout',
            template: 'formio/components/common/layout.html'
          },
          {
            name: 'Conditional',
            template: 'formio/components/common/conditional.html'
          }
        ],
        onEdit: ['$scope', 'FormioUtils', function ($scope, FormioUtils) {
          $scope.dataSources = {
            values: 'Values',
            json: 'Raw JSON',
            url: 'URL',
            resource: 'Resource',
            custom: 'Custom'
          };
          $scope.resources = [];
          $scope.resourceFields = [];

          // Returns only input fields we are interested in.
          var getInputFields = function (components) {
            var fields = [];
            FormioUtils.eachComponent(components, function (component) {
              if (component.key && component.input && (component.type !== 'button') && component.key !== $scope.component.key) {
                var comp = _clone(component);
                if (!comp.label) {
                  comp.label = comp.key;
                }
                fields.push(comp);
              }
            });
            return fields;
          };

          $scope.formFields = [{label: 'Any Change', key: 'data'}].concat(getInputFields($scope.form.components));

          // Loads the selected fields.
          var loadFields = function () {
            if (!$scope.component.data.resource || ($scope.resources.length === 0)) {
              return;
            }
            var selected = null;
            $scope.resourceFields = [
              {
                property: '',
                title: '{Entire Object}'
              },
              {
                property: '_id',
                title: 'Submission Id'
              }
            ];
            if ($scope.formio.projectId) {
              $scope.component.data.project = $scope.formio.projectId;
            }
            for (var index in $scope.resources) {
              if ($scope.resources[index]._id.toString() === $scope.component.data.resource) {
                selected = $scope.resources[index];
                break;
              }
            }
            if (selected) {
              var fields = getInputFields(selected.components);
              for (var i in fields) {
                var field = fields[i];
                var title = field.label || field.key;
                $scope.resourceFields.push({
                  property: 'data.' + field.key,
                  title: title
                });
              }
              if (!$scope.component.valueProperty && $scope.resourceFields.length) {
                $scope.component.valueProperty = $scope.resourceFields[0].property;
              }
            }
          };

          $scope.$watch('component.dataSrc', function (source) {
            if (($scope.resources.length === 0) && (source === 'resource')) {
              $scope.formio.loadForms({params: {type: 'resource', limit: 4294967295}}).then(function (resources) {
                $scope.resources = resources;
                loadFields();
              });
            }
          });

          // Trigger when the resource changes.
          $scope.$watch('component.data.resource', function (resourceId) {
            if (!resourceId) {
              return;
            }
            loadFields();
          });

          // Update other parameters when the value property changes.
          $scope.currentValueProperty = $scope.component.valueProperty;
          $scope.$watch('component.valueProperty', function (property) {
            if ($scope.component.dataSrc === 'resource' && $scope.currentValueProperty !== property) {
              if (!property) {
                $scope.component.searchField = '';
                $scope.component.template = '<span>{{ item.data }}</span>';
              }
              else {
                $scope.component.searchField = property + '__regex';
                $scope.component.template = '<span>{{ item.' + property + ' }}</span>';
              }
            }
          });

          loadFields();
        }],
        documentation: 'http://help.form.io/userguide/#select'
      });
    }
  ]);
  app.run([
    '$templateCache',
    function ($templateCache) {
      // Create the settings markup.
      $templateCache.put('formio/components/select/display.html',
        '<ng-form>' +
        '<form-builder-option property="label"></form-builder-option>' +
        '<form-builder-option property="placeholder"></form-builder-option>' +
        '<form-builder-option property="description"></form-builder-option>' +
        '<form-builder-option property="customClass"></form-builder-option>' +
        '<form-builder-option property="tabindex"></form-builder-option>' +
        '<form-builder-option property="multiple"></form-builder-option>' +
        '<form-builder-option property="clearOnHide"></form-builder-option>' +
        '<form-builder-option property="protected"></form-builder-option>' +
        '<form-builder-option property="persistent"></form-builder-option>' +
        '<form-builder-option property="hidden"></form-builder-option>' +
        '<form-builder-option property="disabled"></form-builder-option>' +
        '<form-builder-option property="tableView"></form-builder-option>' +
        '</ng-form>'
      );

      $templateCache.put('formio/components/select/data.html',
        '<ng-form>' +
        '<div class="form-group">' +
        '<label for="dataSrc" form-builder-tooltip="The source to use for the select data. Values lets you provide your own values and labels. JSON lets you provide raw JSON data. URL lets you provide a URL to retrieve the JSON data from.">Data Source Type</label>' +
        '<select class="form-control" id="dataSrc" name="dataSrc" ng-model="component.dataSrc" ng-options="value as label for (value, label) in dataSources"></select>' +
        '</div>' +
        '<ng-switch on="component.dataSrc">' +
        '<div class="form-group" ng-switch-when="json">' +
        '<label for="data.json" form-builder-tooltip="A raw JSON array to use as a data source.">Data Source Raw JSON</label>' +
        '<textarea class="form-control" id="data.json" name="data.json" ng-model="component.data.json" placeholder="Raw JSON Array" json-input rows="3">{{ component.data.json }}</textarea>' +
        '</div>' +
        '<div ng-switch-when="url">' +
        '<form-builder-option property="data.url" label="Data Source URL" placeholder="Data Source URL" title="A URL that returns a JSON array to use as the data source."></form-builder-option>' +
        '</div>' +
        '<value-builder ng-switch-when="values" data="component.data.values" label="Data Source Values" tooltip-text="Values to use as the data source. Labels are shown in the select field. Values are the corresponding values saved with the submission."></value-builder>' +
        '<div class="form-group" ng-switch-when="resource">' +
        '<label for="placeholder" form-builder-tooltip="The resource to be used with this field.">Resource</label>' +
        '<ui-select ui-select-required ui-select-open-on-focus ng-model="component.data.resource" theme="bootstrap">' +
        '<ui-select-match class="ui-select-match" placeholder="">' +
        '{{$select.selected.title}}' +
        '</ui-select-match>' +
        '<ui-select-choices class="ui-select-choices" repeat="value._id as value in resources | filter: $select.search" refresh="refreshSubmissions($select.search)" refresh-delay="250">' +
        '<div ng-bind-html="value.title | highlight: $select.search"></div>' +
        '</ui-select-choices>' +
        '</ui-select>' +
        '</div>' +
        '</ng-switch>' +
        '<form-builder-option ng-hide="component.dataSrc !== \'url\'" property="selectValues" label="Data Path" type="text" placeholder="The object path to the iterable items." title="The property within the source data, where iterable items reside. For example: results.items or results[0].items"></form-builder-option>' +
        '<form-builder-option ng-hide="component.dataSrc == \'values\' || component.dataSrc == \'resource\' || component.dataSrc == \'custom\'" property="valueProperty" label="Value Property" placeholder="The selected item\'s property to save." title="The property of each item in the data source to use as the select value. If not specified, the item itself will be used."></form-builder-option>' +
        '<div class="form-group" ng-hide="component.dataSrc !== \'resource\' || !component.data.resource || resourceFields.length == 0">' +
        '<label for="placeholder" form-builder-tooltip="The field to use as the value.">Value</label>' +
        '<select class="form-control" id="valueProperty" name="valueProperty" ng-options="value.property as value.title for value in resourceFields" ng-model="component.valueProperty"></select>' +
        '</div>' +
        '<div class="form-group" ng-if="component.dataSrc == \'resource\' && component.valueProperty === \'\'">' +
        '  <label for="placeholder" form-builder-tooltip="The properties on the resource to return as part of the options. Separate property names by commas. If left blank, all properties will be returned.">Select Fields</label>' +
        '  <input type="text" class="form-control" id="selectFields" name="selectFields" ng-model="component.selectFields" placeholder="Comma separated list of fields to select." value="{{ component.selectFields }}">' +
        '</div>' +
        '<div ng-show="component.dataSrc == \'url\'">' +
        '<input type="checkbox" ng-model="component.data.disableLimit" name="disableLimit"></input>' +
        '  <label for="disableLimit" form-builder-tooltip="When enabled the request will not include the limit and skip options in the query string">Disable limiting response</label>' +
        '</div>' +
        '<form-builder-option ng-show="component.dataSrc == \'url\' || component.dataSrc == \'resource\'" property="searchField" label="Search Query Name" placeholder="Name of URL query parameter" title="The name of the search querystring parameter used when sending a request to filter results with. The server at the URL must handle this query parameter."></form-builder-option>' +
        '<form-builder-option ng-show="component.dataSrc == \'url\' || component.dataSrc == \'resource\'" property="filter" label="Filter Query" placeholder="The filter query for results." title="Use this to provide additional filtering using query parameters."></form-builder-option>' +
        '<form-builder-option ng-show="component.dataSrc == \'url\' || component.dataSrc == \'resource\' || component.dataSrc == \'json\'" property="limit" label="Limit" placeholder="Maximum number of items to view per page of results." title="Use this to limit the number of items to request or view."></form-builder-option>' +
        '<div class="form-group" ng-show="component.dataSrc == \'json\'">' +
        '  <label for="filter" form-builder-tooltip="The filter type for search.">Search Filter</label>' +
        '  <select class="form-control" id="filter" name="filter" ng-model="component.filter" ng-options="value as label for (value, label) in {none: \'No Search\', contains: \'Contains\', startsWith: \'Starts With\'}"></select>' +
        '</div>' +
        '<div class="form-group" ng-show="component.dataSrc == \'custom\'">' +
        '  <label for="custom" form-builder-tooltip="Write custom code to return the value options. The form data object is available.">Custom Values</label>' +
        '  <textarea class="form-control" rows="10" id="custom" name="custom" ng-model="component.data.custom" placeholder="/*** Example Code ***/\nvalues = data[\'mykey\'];">{{ component.data.custom }}</textarea>' +
        '</div>' +
        '<div class="form-group">' +
        '<label for="placeholder" form-builder-tooltip="The HTML template for the result data items.">Item Template</label>' +
        '<textarea class="form-control" id="template" name="template" ng-model="component.template" rows="3">{{ component.template }}</textarea>' +
        '</div>' +
        '<div class="form-group" ng-hide="component.dataSrc == \'values\' || component.dataSrc == \'json\'">' +
        '  <label for="placeholder" form-builder-tooltip="Refresh data when another field changes.">Refresh On</label>' +
        '  <select class="form-control" id="refreshOn" name="refreshOn" ng-options="field.key as field.label for field in formFields" ng-model="component.refreshOn"></select>' +
        '</div>' +
        '<form-builder-option ng-show="component.dataSrc == \'resource\' || component.dataSrc == \'url\' || component.dataSrc == \'custom\'" property="clearOnRefresh"></form-builder-option>' +
        '<form-builder-option ng-show="component.dataSrc == \'resource\'" property="reference"></form-builder-option>' +
        '<form-builder-option ng-show="component.dataSrc == \'url\'" property="authenticate"></form-builder-option>' +
        '<form-builder-option property="defaultValue"></form-builder-option>' +
        '</ng-form>'
      );

      // Create the API markup.
      $templateCache.put('formio/components/select/validate.html',
        '<ng-form>' +
        '<form-builder-option property="validate.required"></form-builder-option>' +
        '<form-builder-option property="unique"></form-builder-option>' +
        '<form-builder-option-custom-validation></form-builder-option-custom-validation>' +
        '</ng-form>'
      );
    }
  ]);
};

},{"lodash/clone":170}],237:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('selectboxes', {
        icon: 'fa fa-plus-square',
        views: [
          {
            name: 'Display',
            template: 'formio/components/selectboxes/display.html'
          },
          {
            name: 'Validation',
            template: 'formio/components/selectboxes/validate.html'
          },
          {
            name: 'API',
            template: 'formio/components/selectboxes/api.html'
          },
          {
            name: 'Layout',
            template: 'formio/components/common/layout.html'
          },
          {
            name: 'Conditional',
            template: 'formio/components/common/conditional.html'
          }
        ],
        documentation: 'http://help.form.io/userguide/#selectboxes'
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      // Create the settings markup.
      $templateCache.put('formio/components/selectboxes/display.html',
        '<ng-form>' +
          '<form-builder-option property="label"></form-builder-option>' +
          '<value-builder data="component.values" label="Select Boxes" tooltip-text="Checkboxes to display. Labels are shown in the form. Values are the corresponding values saved with the submission."></value-builder>' +
          '<form-builder-option property="customClass"></form-builder-option>' +
          '<form-builder-option property="tabindex"></form-builder-option>' +
          '<form-builder-option property="inline" type="checkbox" label="Inline Layout" title="Displays the checkboxes horizontally."></form-builder-option>' +
          '<form-builder-option property="clearOnHide"></form-builder-option>' +
          '<form-builder-option property="protected"></form-builder-option>' +
          '<form-builder-option property="persistent"></form-builder-option>' +
          '<form-builder-option property="hidden"></form-builder-option>' +
          '<form-builder-option property="disabled"></form-builder-option>' +
          '<form-builder-option property="tableView"></form-builder-option>' +
        '</ng-form>'
      );

      // Create the API markup.
      $templateCache.put('formio/components/selectboxes/api.html',
        '<ng-form>' +
          '<form-builder-option-key></form-builder-option-key>' +
        '</ng-form>'
      );

      // Create the API markup.
      $templateCache.put('formio/components/selectboxes/validate.html',
        '<ng-form>' +
          '<form-builder-option property="validate.required"></form-builder-option>' +
          '<form-builder-option-custom-validation></form-builder-option-custom-validation>' +
        '</ng-form>'
      );
    }
  ]);
};

},{}],238:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('signature', {
        icon: 'fa fa-pencil',
        views: [
          {
            name: 'Display',
            template: 'formio/components/signature/display.html'
          },
          {
            name: 'Validation',
            template: 'formio/components/signature/validate.html'
          },
          {
            name: 'API',
            template: 'formio/components/common/api.html'
          },
          {
            name: 'Layout',
            template: 'formio/components/common/layout.html'
          },
          {
            name: 'Conditional',
            template: 'formio/components/common/conditional.html'
          }
        ],
        documentation: 'http://help.form.io/userguide/#signature'
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      // Create the settings markup.
      $templateCache.put('formio/components/signature/display.html',
        '<ng-form>' +
          '<form-builder-option property="footer" label="Footer Label" placeholder="Footer Label" title="The footer text that appears below the signature area."></form-builder-option>' +
          '<form-builder-option property="width" label="Width" placeholder="Width" title="The width of the signature area."></form-builder-option>' +
          '<form-builder-option property="height" label="Height" placeholder="Height" title="The height of the signature area."></form-builder-option>' +
          '<form-builder-option property="backgroundColor" label="Background Color" placeholder="Background Color" title="The background color of the signature area."></form-builder-option>' +
          '<form-builder-option property="penColor" label="Pen Color" placeholder="Pen Color" title="The ink color for the signature area."></form-builder-option>' +
          '<form-builder-option property="customClass"></form-builder-option>' +
          '<form-builder-option property="clearOnHide"></form-builder-option>' +
          '<form-builder-option property="disabled"></form-builder-option>' +
          '<form-builder-option property="hidden"></form-builder-option>' +
          '<form-builder-option property="tableView"></form-builder-option>' +
        '</ng-form>'
      );

      // Create the Validation markup.
      $templateCache.put('formio/components/signature/validate.html',
        '<ng-form>' +
          '<form-builder-option property="validate.required"></form-builder-option>' +
        '</ng-form>'
      );
    }
  ]);
};

},{}],239:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('survey', {
        icon: 'fa fa-list',
        views: [
          {
            name: 'Display',
            template: 'formio/components/survey/display.html'
          },
          {
            name: 'Validation',
            template: 'formio/components/survey/validate.html'
          },
          {
            name: 'API',
            template: 'formio/components/common/api.html'
          },
          {
            name: 'Layout',
            template: 'formio/components/common/layout.html'
          },
          {
            name: 'Conditional',
            template: 'formio/components/common/conditional.html'
          }
        ],
        documentation: 'http://help.form.io/userguide/#survey'
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      // Create the settings markup.
      $templateCache.put('formio/components/survey/display.html',
        '<ng-form>' +
          '<form-builder-option property="label"></form-builder-option>' +
          '<value-builder data="component.questions" default="component.questions" label="Questions" tooltip-text="The questions you would like to as in this survey question."></value-builder>' +
          '<value-builder data="component.values" default="component.values" label="Values" tooltip-text="The values that can be selected per question. Example: \'Satisfied\', \'Very Satisfied\', etc."></value-builder>' +
          '<form-builder-option property="defaultValue"></form-builder-option>' +
          '<form-builder-option property="customClass"></form-builder-option>' +
          '<form-builder-option property="tabindex"></form-builder-option>' +
          '<form-builder-option property="inline" type="checkbox" label="Inline Layout" title="Displays the radio buttons horizontally."></form-builder-option>' +
          '<form-builder-option property="clearOnHide"></form-builder-option>' +
          '<form-builder-option property="protected"></form-builder-option>' +
          '<form-builder-option property="persistent"></form-builder-option>' +
          '<form-builder-option property="hidden"></form-builder-option>' +
          '<form-builder-option property="disabled"></form-builder-option>' +
          '<form-builder-option property="tableView"></form-builder-option>' +
        '</ng-form>'
      );
      // Create the API markup.
      $templateCache.put('formio/components/survey/validate.html',
        '<ng-form>' +
          '<form-builder-option property="validate.required"></form-builder-option>' +
          '<form-builder-option-custom-validation></form-builder-option-custom-validation>' +
        '</ng-form>'
      );
    }
  ]);
};

},{}],240:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('table', {
        fbtemplate: 'formio/formbuilder/table.html',
        documentation: 'http://help.form.io/userguide/#table',
        noDndOverlay: true,
        confirmRemove: true,
        icon: 'fa fa-table',
        views: [
          {
            name: 'Display',
            template: 'formio/components/table/display.html'
          },
          {
            name: 'Layout',
            template: 'formio/components/common/layout.html'
          },
          {
            name: 'API',
            template: 'formio/components/common/api.html'
          },
          {
            name: 'Conditional',
            template: 'formio/components/common/conditional.html'
          }
        ]
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      var tableClasses = "{'table-striped': component.striped, ";
      tableClasses += "'table-bordered': component.bordered, ";
      tableClasses += "'table-hover': component.hover, ";
      tableClasses += "'table-condensed': component.condensed}";
      $templateCache.put('formio/formbuilder/table.html',
        '<div class="table-responsive">' +
          '<table ng-class="' + tableClasses + '" class="table">' +
            '<thead ng-if="component.header.length"><tr>' +
              '<th ng-repeat="header in component.header">{{ header }}</th>' +
            '</tr></thead>' +
            '<tbody>' +
              '<tr ng-repeat="row in component.rows">' +
                '<td ng-repeat="component in row">' +
                  '<form-builder-list component="component" form="form" formio="::formio"></form-builder-list>' +
                '</td>' +
              '</tr>' +
            '</tbody>' +
          '</table>' +
        '</div>'
      );

      $templateCache.put('formio/components/table/display.html',
        '<ng-form>' +
          '<form-builder-table></form-builder-table>' +
          '<form-builder-option property="customClass"></form-builder-option>' +
          '<form-builder-option property="striped"></form-builder-option>' +
          '<form-builder-option property="bordered"></form-builder-option>' +
          '<form-builder-option property="hover"></form-builder-option>' +
          '<form-builder-option property="condensed"></form-builder-option>' +
        '</ng-form>'
      );
    }
  ]);
};

},{}],241:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('textarea', {
        icon: 'fa fa-font',
        views: [
          {
            name: 'Display',
            template: 'formio/components/textarea/display.html'
          },
          {
            name: 'Data',
            template: 'formio/components/common/data.html'
          },
          {
            name: 'Validation',
            template: 'formio/components/textfield/validate.html'
          },
          {
            name: 'API',
            template: 'formio/components/common/api.html'
          },
          {
            name: 'Layout',
            template: 'formio/components/common/layout.html'
          },
          {
            name: 'Conditional',
            template: 'formio/components/common/conditional.html'
          }
        ],
        documentation: 'http://help.form.io/userguide/#textarea'
      });
    }
  ]);
  app.controller('wysiwygSettings', ['$scope', function($scope) {
    $scope.wysiwygEnabled = !!$scope.component.wysiwyg;
    $scope.wysiwygSettings = {
      toolbarGroups:  [
        {name: 'basicstyles', groups: ['basicstyles', 'cleanup']},
        {name: 'paragraph', groups: ['list', 'indent', 'blocks', 'align', 'bidi', 'paragraph', '-', 'JustifyLeft', 'JustifyCenter', 'JustifyRight', 'JustifyBlock']},
        {name: 'links', groups: ['links']},
        {name: 'insert', groups: ['insert']},
        '/',
        {name: 'styles', groups: ['Styles', 'Format', 'Font', 'FontSize']},
        {name: 'colors', groups: ['colors']},
        {name: 'clipboard', groups: ['clipboard', 'undo']},
        {name: 'editing', groups: ['find', 'selection', 'spellchecker', 'editing']},
        {name: 'document', groups: ['mode', 'document', 'doctools']},
        {name: 'others', groups: ['others']},
        {name: 'tools', groups: ['tools']}
      ],
      extraPlugins: 'justify,font',
      removeButtons: 'Cut,Copy,Paste,Underline,Subscript,Superscript,Scayt,About',
      uiColor: '#eeeeee',
      height: '400px',
      width: '100%'
    };
    $scope.$watch('wysiwygEnabled', function(value) {
      $scope.component.wysiwyg = value ? $scope.wysiwygSettings : false;
    });
    $scope.$watch('wysiwygSettings', function(value) {
      if ($scope.wysiwygEnabled) {
        $scope.component.wysiwyg = value;
      }
    });
  }]);
  app.run([
    '$templateCache',
    function($templateCache) {
      // Create the settings markup.
      $templateCache.put('formio/components/textarea/display.html',
        '<ng-form>' +
          '<form-builder-option property="label"></form-builder-option>' +
          '<form-builder-option property="placeholder"></form-builder-option>' +
          '<form-builder-option property="description"></form-builder-option>' +
          '<form-builder-option property="inputMask"></form-builder-option>' +
          '<div ng-controller="wysiwygSettings">' +
            '<div class="checkbox">' +
              '<label><input type="checkbox" ng-model="wysiwygEnabled"> Enable WYWIWYG</label>' +
            '</div>' +
            '<div class="form-group">' +
              '<label for="wysiwyg">WYSIWYG Settings</label>' +
              '<textarea class="form-control" rows="5" id="wysiwyg" ng-model="wysiwygSettings" json-input placeholder="Enter the CKEditor JSON configuration to turn this TextArea into a WYSIWYG."></textarea>' +
            '</div>' +
          '</div>' +
          '<form-builder-option property="prefix"></form-builder-option>' +
          '<form-builder-option property="suffix"></form-builder-option>' +
          '<form-builder-option property="customClass"></form-builder-option>' +
          '<form-builder-option property="tabindex"></form-builder-option>' +
          '<form-builder-option property="multiple"></form-builder-option>' +
          '<form-builder-option property="clearOnHide"></form-builder-option>' +
          '<form-builder-option property="protected"></form-builder-option>' +
          '<form-builder-option property="persistent"></form-builder-option>' +
          '<form-builder-option property="disabled"></form-builder-option>' +
          '<form-builder-option property="tableView"></form-builder-option>' +
        '</ng-form>'
      );
    }
  ]);
};

},{}],242:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('textfield', {
        views: [
          {
            name: 'Display',
            template: 'formio/components/textfield/display.html'
          },
          {
            name: 'Data',
            template: 'formio/components/common/data.html'
          },
          {
            name: 'Validation',
            template: 'formio/components/textfield/validate.html'
          },
          {
            name: 'API',
            template: 'formio/components/common/api.html'
          },
          {
            name: 'Layout',
            template: 'formio/components/common/layout.html'
          },
          {
            name: 'Conditional',
            template: 'formio/components/common/conditional.html'
          }
        ],
        documentation: 'http://help.form.io/userguide/#textfield'
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      // Create the settings markup.
      $templateCache.put('formio/components/textfield/display.html',
        '<ng-form>' +
          '<form-builder-option property="label"></form-builder-option>' +
          '<form-builder-option property="placeholder"></form-builder-option>' +
          '<form-builder-option property="description"></form-builder-option>' +
          '<form-builder-option property="inputMask"></form-builder-option>' +
          '<form-builder-option property="prefix"></form-builder-option>' +
          '<form-builder-option property="suffix"></form-builder-option>' +
          '<form-builder-option property="customClass"></form-builder-option>' +
          '<form-builder-option property="tabindex"></form-builder-option>' +
          '<form-builder-option property="multiple"></form-builder-option>' +
          '<form-builder-option property="clearOnHide"></form-builder-option>' +
          '<form-builder-option property="protected"></form-builder-option>' +
          '<form-builder-option property="persistent"></form-builder-option>' +
          '<form-builder-option property="hidden"></form-builder-option>' +
          '<form-builder-option property="disabled"></form-builder-option>' +
          '<form-builder-option property="tableView"></form-builder-option>' +
        '</ng-form>'
      );

      $templateCache.put('formio/components/textfield/validate.html',
        '<ng-form>' +
          '<form-builder-option property="validate.required"></form-builder-option>' +
          '<form-builder-option property="unique"></form-builder-option>' +
          '<form-builder-option property="validate.minLength"></form-builder-option>' +
          '<form-builder-option property="validate.maxLength"></form-builder-option>' +
          '<form-builder-option property="validate.pattern"></form-builder-option>' +
          '<form-builder-option-custom-validation></form-builder-option-custom-validation>' +
        '</ng-form>'
      );
    }
  ]);
};

},{}],243:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('well', {
        fbtemplate: 'formio/formbuilder/well.html',
        icon: 'fa fa-square-o',
        documentation: 'http://help.form.io/userguide/#well',
        noDndOverlay: true,
        confirmRemove: true,
        views: [
          {
            name: 'Display',
            template: 'formio/components/common/display.html'
          },
          {
            name: 'API',
            template: 'formio/components/common/api.html'
          },
          {
            name: 'Conditional',
            template: 'formio/components/common/conditional.html'
          }
        ]
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/formbuilder/well.html',
        '<div class="well">' +
          '<form-builder-list component="component" form="form" formio="::formio"></form-builder-list>' +
        '</div>'
      );
      $templateCache.put('formio/components/common/display.html',
        '<ng-form>' +
          '<form-builder-option property="customClass"></form-builder-option>' +
        '<ng-form>'
      );
    }
  ]);
};

},{}],244:[function(_dereq_,module,exports){
"use strict";
/**
  * These are component options that can be reused
  * with the builder-option directive
  * Valid properties: label, placeholder, tooltip, type
  */
module.exports = {
  label: {
    label: 'Label',
    placeholder: 'Field Label',
    tooltip: 'The label for this field that will appear next to it.'
  },
  defaultValue: {
    label: 'Default Value',
    placeholder: 'Default Value',
    tooltip: 'The will be the value for this field, before user interaction. Having a default value will override the placeholder text.'
  },
  placeholder: {
    label: 'Placeholder',
    placeholder: 'Placeholder',
    tooltip: 'The placeholder text that will appear when this field is empty.'
  },
  description: {
    label: 'Description',
    placeholder: 'Description for this field.',
    tooltip: 'The description is text that will appear below the input field.'
  },
  path: {
    label: 'Form Path',
    placeholder: 'Enter the path of the Form to load',
    tooltip: 'This is the path of the form to load.'
  },
  inputMask: {
    label: 'Input Mask',
    placeholder: 'Input Mask',
    tooltip: 'An input mask helps the user with input by ensuring a predefined format.<br><br>9: numeric<br>a: alphabetical<br>*: alphanumeric<br><br>Example telephone mask: (999) 999-9999<br><br>See the <a target=\'_blank\' href=\'https://github.com/RobinHerbots/jquery.inputmask\'>jquery.inputmask documentation</a> for more information.</a>'
  },
  authenticate: {
    label: 'Formio Authenticate',
    tooltip: 'Check this if you would like to use Formio Authentication with the request.',
    type: 'checkbox'
  },
  tableView: {
    label: 'Table View',
    type: 'checkbox',
    tooltip: 'Shows this value within the table view of the submissions.'
  },
  prefix: {
    label: 'Prefix',
    placeholder: 'example \'$\', \'@\'',
    tooltip: 'The text to show before a field.'
  },
  suffix: {
    label: 'Suffix',
    placeholder: 'example \'$\', \'@\'',
    tooltip: 'The text to show after a field.'
  },
  multiple: {
    label: 'Multiple Values',
    type: 'checkbox',
    tooltip: 'Allows multiple values to be entered for this field.'
  },
  disabled: {
    label: 'Disabled',
    type: 'checkbox',
    tooltip: 'Disable the form input.'
  },
  clearOnRefresh: {
    label: 'Clear Value On Refresh',
    type: 'checkbox',
    tooltip: 'When the Refresh On field is changed, clear the selected value.'
  },
  clearOnHide: {
    label: 'Clear Value When Hidden',
    type: 'checkbox',
    tooltip: 'When a field is hidden, clear the value.'
  },
  unique: {
    label: 'Unique',
    type: 'checkbox',
    tooltip: 'Makes sure the data submitted for this field is unique, and has not been submitted before.'
  },
  protected: {
    label: 'Protected',
    type: 'checkbox',
    tooltip: 'A protected field will not be returned when queried via API.'
  },
  image: {
    label: 'Display as images',
    type: 'checkbox',
    tooltip: 'Instead of a list of linked files, images will be rendered in the view.'
  },
  imageSize: {
    label: 'Image Size',
    placeholder: '100',
    tooltip: 'The image size for previewing images.'
  },
  persistent: {
    label: 'Persistent',
    type: 'checkbox',
    tooltip: 'A persistent field will be stored in database when the form is submitted.'
  },
  hidden: {
    label: 'Hidden',
    type: 'checkbox',
    tooltip: 'A hidden field is still a part of the form, but is hidden from view.'
  },
  reference: {
    label: 'Save as reference',
    type: 'checkbox',
    tooltip: 'Using this option will save this field as a reference and link its value to the value of the origin record.'
  },
  block: {
    label: 'Block',
    type: 'checkbox',
    tooltip: 'This control should span the full width of the bounding container.'
  },
  leftIcon: {
    label: 'Left Icon',
    placeholder: 'Enter icon classes',
    tooltip: 'This is the full icon class string to show the icon. Example: \'glyphicon glyphicon-search\' or \'fa fa-plus\''
  },
  rightIcon: {
    label: 'Right Icon',
    placeholder: 'Enter icon classes',
    tooltip: 'This is the full icon class string to show the icon. Example: \'glyphicon glyphicon-search\' or \'fa fa-plus\''
  },
  url: {
    label: 'Upload Url',
    placeholder: 'Enter the url to post the files to.',
    tooltip: 'See <a href=\'https://github.com/danialfarid/ng-file-upload#server-side\' target=\'_blank\'>https://github.com/danialfarid/ng-file-upload#server-side</a> for how to set up the server.'
  },
  dir: {
    label: 'Directory',
    placeholder: '(optional) Enter a directory for the files',
    tooltip: 'This will place all the files uploaded in this field in the directory'
  },
  disableOnInvalid: {
    label: 'Disable on Form Invalid',
    type: 'checkbox',
    tooltip: 'This will disable this field if the form is invalid.'
  },
  striped: {
    label: 'Striped',
    type: 'checkbox',
    tooltip: 'This will stripe the table if checked.'
  },
  bordered: {
    label: 'Bordered',
    type: 'checkbox',
    tooltip: 'This will border the table if checked.'
  },
  hover: {
    label: 'Hover',
    type: 'checkbox',
    tooltip: 'Highlight a row on hover.'
  },
  condensed: {
    label: 'Condensed',
    type: 'checkbox',
    tooltip: 'Condense the size of the table.'
  },
  datagridLabel: {
    label: 'Datagrid Label',
    type: 'checkbox',
    tooltip: 'Show the label when in a datagrid.'
  },
  'validate.required': {
    label: 'Required',
    type: 'checkbox',
    tooltip: 'A required field must be filled in before the form can be submitted.'
  },
  'validate.minLength': {
    label: 'Minimum Length',
    placeholder: 'Minimum Length',
    type: 'number',
    tooltip: 'The minimum length requirement this field must meet.'
  },
  'validate.maxLength': {
    label: 'Maximum Length',
    placeholder: 'Maximum Length',
    type: 'number',
    tooltip: 'The maximum length requirement this field must meet'
  },
  'validate.pattern': {
    label: 'Regular Expression Pattern',
    placeholder: 'Regular Expression Pattern',
    tooltip: 'The regular expression pattern test that the field value must pass before the form can be submitted.'
  },
  'customClass': {
    label: 'Custom CSS Class',
    placeholder: 'Custom CSS Class',
    tooltip: 'Custom CSS class to add to this component.'
  },
  'tabindex': {
    label: 'Tab Index',
    placeholder: 'Tab Index',
    tooltip: 'Sets the tabindex attribute of this component to override the tab order of the form. See the <a href=\'https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex\'>MDN documentation</a> on tabindex for more information.'
  },
  'addAnother': {
    label: 'Add Another Text',
    placeholder: 'Add Another',
    tooltip: 'Set the text of the Add Another button.'
  },
  'defaultDate': {
    label: 'Default Value',
    placeholder: 'Default Value',
    tooltip: 'You can use Moment.js functions to set the default value to a specific date. For example: \n \n moment().subtract(10, \'days\').calendar();'
  },
  // Need to use array notation to have dash in name
  'style[\'margin-top\']': {
    label: 'Margin Top',
    placeholder: '0px',
    tooltip: 'Sets the top margin of this component. Must be a valid CSS measurement like `10px`.'
  },
  'style[\'margin-right\']': {
    label: 'Margin Right',
    placeholder: '0px',
    tooltip: 'Sets the right margin of this component. Must be a valid CSS measurement like `10px`.'
  },
  'style[\'margin-bottom\']': {
    label: 'Margin Bottom',
    placeholder: '0px',
    tooltip: 'Sets the bottom margin of this component. Must be a valid CSS measurement like `10px`.'
  },
  'style[\'margin-left\']': {
    label: 'Margin Left',
    placeholder: '0px',
    tooltip: 'Sets the left margin of this component. Must be a valid CSS measurement like `10px`.'
  },
  'addResource': {
    label: 'Show Add Resource Button',
    type: 'checkbox',
    tooltip: 'Include a button for adding a new resource'
  },
  'addResourceLabel': {
    label: 'Add Resource Text',
    placeholder: 'Add Resource',
    tooltip: 'Set the text of the Add Resource button.'
  }
};

},{}],245:[function(_dereq_,module,exports){
"use strict";
module.exports = {
  actions: [
    {
      name: 'submit',
      title: 'Submit'
    },
    {
      name: 'event',
      title: 'Event'
    },
    {
      name: 'reset',
      title: 'Reset'
    },
    {
      name: 'oauth',
      title: 'OAuth'
    }
  ],
  themes: [
    {
      name: 'default',
      title: 'Default'
    },
    {
      name: 'primary',
      title: 'Primary'
    },
    {
      name: 'info',
      title: 'Info'
    },
    {
      name: 'success',
      title: 'Success'
    },
    {
      name: 'danger',
      title: 'Danger'
    },
    {
      name: 'warning',
      title: 'Warning'
    }
  ],
  sizes: [
    {
      name: 'xs',
      title: 'Extra Small'
    },
    {
      name: 'sm',
      title: 'Small'
    },
    {
      name: 'md',
      title: 'Medium'
    },
    {
      name: 'lg',
      title: 'Large'
    }
  ]
};

},{}],246:[function(_dereq_,module,exports){
"use strict";
/*eslint max-statements: 0*/
var _cloneDeep = _dereq_('lodash/cloneDeep');
var _each = _dereq_('lodash/each');
var _omitBy = _dereq_('lodash/omitBy');
var _groupBy = _dereq_('lodash/groupBy');
var _upperFirst = _dereq_('lodash/upperFirst');
var _merge = _dereq_('lodash/merge');
var _capitalize = _dereq_('lodash/capitalize');
module.exports = ['debounce', function(debounce) {
  return {
    replace: true,
    templateUrl: 'formio/formbuilder/builder.html',
    scope: {
      form: '=?',
      src: '=',
      url: '=?',
      type: '=',
      onSave: '=',
      onCancel: '=',
      options: '=?'
    },
    controller: [
      '$scope',
      'formioComponents',
      'ngDialog',
      'Formio',
      'FormioUtils',
      'dndDragIframeWorkaround',
      '$interval',
      '$timeout',
      function(
        $scope,
        formioComponents,
        ngDialog,
        Formio,
        FormioUtils,
        dndDragIframeWorkaround,
        $interval,
        $timeout
      ) {
        $scope.options = $scope.options || {};

        // Add the components to the scope.
        var submitButton = angular.copy(formioComponents.components.button.settings);
        if (!$scope.form) {
          $scope.form = {};
        }
        if (!$scope.form.components) {
          $scope.form.components = [];
        }
        if (!$scope.form.display) {
          $scope.form.display = 'form';
        }
        if (!$scope.options.noSubmit && !$scope.form.components.length) {
          $scope.form.components.push(submitButton);
        }
        $scope.hideCount = 2;
        $scope.form.page = 0;
        $scope.formio = $scope.src ? new Formio($scope.src) : null;
        if ($scope.url) {
          $scope.formio = new Formio($scope.url);
        }

        var setNumPages = function() {
          if (!$scope.form) {
            return;
          }
          if ($scope.form.display !== 'wizard') {
            return;
          }

          var numPages = 0;
          $scope.form.components.forEach(function(component) {
            if (component.type === 'panel') {
              numPages++;
            }
          });

          $scope.form.numPages = numPages;

          // Add a page if none is found.
          if (numPages === 0) {
            $scope.newPage();
          }

          // Make sure the page doesn't excede the end.
          if ((numPages > 0) && ($scope.form.page >= numPages)) {
            $scope.form.page = numPages - 1;
          }
        };

        // Load the form.
        if ($scope.src && $scope.formio && $scope.formio.formId) {
          $scope.formio.loadForm().then(function(form) {
            $scope.form = form;
            if (!$scope.form.display) {
              $scope.form.display = 'form';
            }
            if (!$scope.options.noSubmit && $scope.form.components.length === 0) {
              $scope.form.components.push(submitButton);
            }
            $scope.showPage(0);
          });
        }

        // Ensure we always have a page set.
        $scope.$watch('form.page', function(page) {
          if (page === undefined) {
            $scope.showPage(0);
          }
        });

        $scope.$watch('form.display', function(display) {
          $scope.hideCount = (display === 'wizard') ? 1 : 2;
        });

        // Ensure that they don't remove components by canceling the edit modal.
        $scope.$watch('form._id', function(_id) {
          if (!_id) {
            return;
          }
          FormioUtils.eachComponent($scope.form.components, function(component) {
            delete component.isNew;
          }, true);
        });

        // Make sure they can switch back and forth between wizard and pages.
        $scope.$on('formDisplay', function(event, display) {
          $scope.form.display = display;
          setNumPages();
          $timeout(function() {
            $scope.showPage(0);
            $scope.$apply();
          });
        });

        // Return the form pages.
        $scope.pages = function() {
          var pages = [];
          $scope.form.components.forEach(function(component) {
            if (component.type === 'panel') {
              if (component.title) {
                pages.push(component.title);
              }
              else {
                pages.push('Page ' + (pages.length + 1));
              }
            }
          });
          return pages;
        };

        $scope.getPage = function() {
          var pageNum = 0;
          for (var i = 0; i < $scope.form.components.length; i++) {
            var component = $scope.form.components[i];
            if (component.type === 'panel') {
              if (i === $scope.form.page) {
                break;
              }
              pageNum++;
            }
          }
          return pageNum;
        };

        // Show the form page.
        /* eslint-disable max-depth */
        $scope.showPage = function(page) {
          var pageNum = 0;
          if ($scope.form && $scope.form.components) {
            for (var i = 0; i < $scope.form.components.length; i++) {
              var component = $scope.form.components[i];
              if (component.type === 'panel') {
                if (pageNum === page) {
                  pageNum = i;
                  break;
                }
                pageNum++;
              }
            }
          }
          $scope.form.page = pageNum;
        };
        /* eslint-enable max-depth */

        $scope.newPage = function() {
          var index = $scope.form.numPages;
          var pageNum = index + 1;
          var component = {
            type: 'panel',
            title: 'Page ' + pageNum,
            isNew: true,
            components: [],
            input: false,
            key: 'page' + pageNum
          };
          $scope.form.numPages++;
          $scope.$emit('newPage', {
            index: index,
            component: component
          });
          $scope.form.components.splice(index, 0, component);
        };

        // Ensure the number of pages is always correct.
        $scope.$watch('form.components.length', function() {
          setNumPages();
        });

        $scope.formComponents = _cloneDeep(formioComponents.components);
        _each($scope.formComponents, function(component, key) {
          component.settings.isNew = true;
          if (component.settings.hasOwnProperty('builder') && !component.settings.builder || component.disabled) {
            delete $scope.formComponents[key];
          }
        });

        $scope.pdftypes = [
          $scope.formComponents.textfield,
          $scope.formComponents.number,
          $scope.formComponents.password,
          $scope.formComponents.email,
          $scope.formComponents.phoneNumber,
          $scope.formComponents.currency,
          $scope.formComponents.checkbox,
          $scope.formComponents.signature,
          $scope.formComponents.select,
          $scope.formComponents.textarea,
          $scope.formComponents.datetime
        ];

        $scope.formComponentGroups = _cloneDeep(_omitBy(formioComponents.groups, 'disabled'));
        $scope.formComponentsByGroup = _groupBy($scope.formComponents, function(component) {
          return component.group;
        });

        // Get the resource fields.
        var resourceEnabled = !formioComponents.groups.resource || !formioComponents.groups.resource.disabled;
        if ($scope.formio && resourceEnabled) {
          $scope.formComponentsByGroup.resource = {};
          $scope.formComponentGroups.resource = {
            title: 'Existing Resource Fields',
            panelClass: 'subgroup-accordion-container',
            subgroups: {}
          };

          $scope.formio.loadForms({params: {type: 'resource', limit: 100}}).then(function(resources) {
            // Iterate through all resources.
            _each(resources, function(resource) {
              var resourceKey = resource.name;

              // Add a legend for this resource.
              $scope.formComponentsByGroup.resource[resourceKey] = [];
              $scope.formComponentGroups.resource.subgroups[resourceKey] = {
                title: resource.title
              };

              // Iterate through each component.
              FormioUtils.eachComponent(resource.components, function(component) {
                if (component.type === 'button') return;

                var componentName = component.label;
                if (!componentName && component.key) {
                  componentName = _upperFirst(component.key);
                }

                $scope.formComponentsByGroup.resource[resourceKey].push(_merge(
                  _cloneDeep(formioComponents.components[component.type], true),
                  {
                    title: componentName,
                    group: 'resource',
                    subgroup: resourceKey,
                    settings: component
                  },
                  {
                    settings: {
                      label: component.label,
                      key: component.key,
                      lockKey: true,
                      source: resource._id,
                      isNew: true
                    }
                  }
                ));
              }, true);
            });
          });
        }

        var update = function() {
          $scope.$emit('formUpdate', $scope.form);
        };

        // Add a new component.
        $scope.$on('formBuilder:add', update);
        $scope.$on('formBuilder:update', update);
        $scope.$on('formBuilder:remove', update);
        $scope.$on('formBuilder:edit', update);

        $scope.saveSettings = function() {
          ngDialog.closeAll(true);
          $scope.$emit('formUpdate', $scope.form);
        };

        $scope.capitalize = _capitalize;

        // Set the root list height to the height of the formbuilder for ease of form building.
        var rootlistEL = angular.element('.rootlist');
        var formbuilderEL = angular.element('.formbuilder');

        $interval(function setRootListHeight() {
          var listHeight = rootlistEL.height('inherit').height();
          var builderHeight = formbuilderEL.height();
          if ((builderHeight - listHeight) > 100) {
            rootlistEL.height(builderHeight);
          }
        }, 1000);

        // Add to scope so it can be used in templates
        $scope.dndDragIframeWorkaround = dndDragIframeWorkaround;
        $scope.showPage(0);
      }
    ],
    link: function(scope, element) {
      var scrollSidebar = debounce(function() {
        // Disable all buttons within the form.
        angular.element('.formbuilder').find('button').attr('disabled', 'disabled');

        // Make the left column follow the form.
        var formComponents = angular.element('.formcomponents');
        var formBuilder = angular.element('.formbuilder');
        if (formComponents.length !== 0 && formBuilder.length !== 0) {
          var maxScroll = formBuilder.outerHeight() > formComponents.outerHeight() ? formBuilder.outerHeight() - formComponents.outerHeight() : 0;
          // 50 pixels gives space for the fixed header.
          var scroll = angular.element(window).scrollTop() - formComponents.parent().offset().top + 50;
          if (scroll < 0) {
            scroll = 0;
          }
          if (scroll > maxScroll) {
            scroll = maxScroll;
          }
          formComponents.css('margin-top', scroll + 'px');
        }
      }, 100, false);
      window.onscroll = scrollSidebar;
      element.on('$destroy', function() {
        window.onscroll = null;
      });
    }
  };
}];

},{"lodash/capitalize":169,"lodash/cloneDeep":171,"lodash/each":174,"lodash/groupBy":178,"lodash/merge":198,"lodash/omitBy":200,"lodash/upperFirst":208}],247:[function(_dereq_,module,exports){
"use strict";
/**
 * Create the form-builder-component directive.
 * Extend the formio-component directive and change the template.
 */
module.exports = [
  'formioComponentDirective',
  function(formioComponentDirective) {
    return angular.extend({}, formioComponentDirective[0], {
      scope: false,
      templateUrl: 'formio/formbuilder/component.html'
    });
  }
];

},{}],248:[function(_dereq_,module,exports){
"use strict";
'use strict';
var utils = _dereq_('formiojs/utils');
var _get = _dereq_('lodash/get');
var _reject = _dereq_('lodash/reject');
module.exports = [
  function() {
    return {
      restrict: 'E',
      scope: true,
      template: '' +
        '<uib-accordion>' +
          '<div uib-accordion-group heading="Simple" class="panel panel-default" is-open="status.simple">' +
            'This component should Display:' +
            '<select class="form-control input-md" ng-model="component.conditional.show">' +
            '<option ng-repeat="item in _booleans track by $index" value="{{item}}">{{item.toString()}}</option>' +
            '</select>' +
            '<br>When the form component:' +
            '<select class="form-control input-md" ng-model="component.conditional.when">' +
            '<option ng-repeat="item in _components track by $index" value="{{item.key}}">{{item !== "" ? item.label + " (" + item.key + ")" : ""}}</option>' +
            '</select>' +
            '<br>Has the value:' +
            '<input type="text" class="form-control input-md" ng-model="component.conditional.eq">' +
          '</div>' +
          '<div uib-accordion-group heading="Advanced" class="panel panel-default" is-open="status.advanced">' +
            '<textarea class="form-control" rows="5" id="custom" name="custom" ng-model="component.customConditional" placeholder="/*** Example Code ***/\nshow = (data[\'mykey\'] > 1);"></textarea>' +
            '<small>' +
            '<p>Enter custom conditional code.</p>' +
            '<p>You must assign the <strong>show</strong> variable as either <strong>true</strong> or <strong>false</strong>.</p>' +
            '<p>The global variable <strong>data</strong> is provided, and allows you to access the data of any form component, by using its API key.</p>' +
            '<p><strong>Note: Advanced Conditional logic will override the results of the Simple Conditional logic.</strong></p>' +
            '</small>' +
          '</div>' +
          '<div uib-accordion-group heading="JSON Conditional" class="panel panel-default" is-open="status.json">' +
            '<small>' +
              '<p>Execute custom validation logic with JSON and <a href="http://jsonlogic.com/">JsonLogic</a>.</p>' +
              '<p>Submission data is available as JsonLogic variables, with the same api key as your components.</p>' +
              '<p><a href="http://formio.github.io/formio.js/app/examples/conditions.html" target="_blank">Click here for an example</a></p>' +
            '</small>' +
            '<textarea class="form-control" rows="5" id="json" name="json" json-input ng-model="component.conditional.json" placeholder="{ ... }"></textarea>' +
          '</div>' +
        '</uib-accordion>',
      controller: [
        '$scope',
        function(
          $scope) {
          // Default the current components conditional logic.
          $scope.component = $scope.component || {};
          $scope.component.conditional = $scope.component.conditional || {};

          // The available logic functions.
          $scope._booleans = ['', 'true', 'false'];

          // Filter the list of available form components for conditional logic.
          $scope._components = _get($scope, 'form.components') || [];
          $scope._components = utils.flattenComponents($scope._components);
          // Remove non-input/button fields because they don't make sense.
          // FA-890 - Dont allow the current component to be a conditional trigger.
          $scope._components = _reject($scope._components, function(c) {
            return !c.input || (c.type === 'button') || (c.key === $scope.component.key) || (!c.label && !c.key);
          });

          // Add default item to the components list.
          $scope._components.unshift('');

          // Default and watch the show logic.
          $scope.component.conditional.show = $scope.component.conditional.show || '';
          // Coerce show var to supported value.
          var _booleanMap = {
            '': '',
            'true': 'true',
            'false': 'false'
          };
          $scope.component.conditional.show = _booleanMap.hasOwnProperty($scope.component.conditional.show)
            ? _booleanMap[$scope.component.conditional.show]
            : '';

          // Default and watch the when logic.
          $scope.component.conditional.when = $scope.component.conditional.when || null;

          // Default and watch the search logic.
          $scope.component.conditional.eq = $scope.component.conditional.eq || '';

          // Track the status of the accordion panels open state.
          $scope.status = {
            simple: !$scope.component.customConditional,
            advanced: !!$scope.component.customConditional
          };
        }
      ]
    };
  }
];

},{"formiojs/utils":3,"lodash/get":177,"lodash/reject":203}],249:[function(_dereq_,module,exports){
"use strict";
var _isNumber = _dereq_('lodash/isNumber');
var _camelCase = _dereq_('lodash/camelCase');
var _assign = _dereq_('lodash/assign');
module.exports = [
  '$scope',
  '$element',
  '$rootScope',
  'formioComponents',
  'FormioUtils',
  'ngDialog',
  'dndDragIframeWorkaround',
  '$timeout',
  'BuilderUtils',
  function(
    $scope,
    $element,
    $rootScope,
    formioComponents,
    FormioUtils,
    ngDialog,
    dndDragIframeWorkaround,
    $timeout,
    BuilderUtils
  ) {
    $scope.builder = true;
    $rootScope.builder = true;
    $scope.hideCount = (_isNumber($scope.hideDndBoxCount) ? $scope.hideDndBoxCount : 1);
    $scope.$watch('hideDndBoxCount', function(hideCount) {
      $scope.hideCount = hideCount ? hideCount : 1;
    });

    $scope.formComponents = formioComponents.components;
    if (!$scope.component) {
      $scope.component = $scope.form;
    }

    // Components depend on this existing
    $scope.data = {};

    $scope.emit = function() {
      var args = [].slice.call(arguments);
      args[0] = 'formBuilder:' + args[0];
      $scope.$emit.apply($scope, args);
    };

    $scope.$on('iframe-componentClick', function(event, data) {
      angular.forEach($scope.component.components, function(component) {
        if (component.id === data.id) {
          $scope.editComponent(component);
        }
      });
    });
    $scope.$on('iframe-componentUpdate', function(event, data) {
      angular.forEach($scope.component.components, function(component) {
        if (component.id === data.id) {
          component.overlay = data.overlay;
        }
      });
    });

    $scope.$on('fbDragDrop', function(event, component) {
      component.settings.id = Math.random().toString(36).substring(7);
      component.settings.overlay = {
        page: '1',
        top: component.fbDropY,
        left: component.fbDropX
      };
      $scope.addComponent(component.settings);
    });

    $scope.addComponent = function(component, index) {
      if (index === 'undefined') {
        index = -1;
      }
      // Only edit immediately for components that are not resource comps.
      if (component.isNew && !component.lockConfiguration && (!component.key || (component.key.indexOf('.') === -1))) {
        $scope.editComponent(component);
      }
      else {
        // Ensure the component has a key.
        component.key = component.key || component.label || 'component';

        BuilderUtils.uniquify($scope.form, component);

        // Update the component to not be flagged as new anymore.
        FormioUtils.eachComponent([component], function(child) {
          delete child.isNew;
        }, true);
      }

      // Refresh all CKEditor instances
      $scope.$broadcast('ckeditor.refresh');

      dndDragIframeWorkaround.isDragging = false;
      $scope.emit('add');
      $scope.$broadcast('iframeMessage', {name: 'addElement', data: component});

      // If this is a root component and the display is a wizard, then we know
      // that they dropped the component outside of where it is supposed to go...
      // Instead append or prepend to the components array.
      if ($scope.component.display === 'wizard') {
        $scope.$apply(function() {
          var pageIndex = (index === 0) ? 0 : $scope.form.components[$scope.form.page].components.length;
          $scope.form.components[$scope.form.page].components.splice(pageIndex, 0, component);
        });
        return true;
      }

      // Make sure that they don't ever add a component on the bottom of the submit button.
      var lastComponent = $scope.component.components[$scope.component.components.length - 1];
      if (
        (lastComponent) &&
        (lastComponent.type === 'button') &&
        (lastComponent.action === 'submit')
      ) {
        // There is only one element on the page.
        if ($scope.component.components.length === 1) {
          index = 0;
        }
        else if (index >= $scope.component.components.length) {
          index -= 1;
        }
      }

      // Add the component to the components array.
      $scope.component.components.splice(index, 0, component);
      $timeout($scope.$apply.bind($scope));

      // Return true since this will tell the drag-and-drop list component to not insert into its own array.
      return true;
    };

    // Allow prototyped scopes to update the original component.
    $scope.updateComponent = function(newComponent, key) {
      var list = $scope.component.components;
      if (_.findIndex(list, {key: key}) !== -1) {
        list.splice(_.findIndex(list, {key: key}), 1, newComponent);
        $scope.emit('update', newComponent);
        $scope.$broadcast('iframeMessage', {name: 'updateElement', data: newComponent});
      }
      else {
        //console.warn('not found', key);
      }
    };

    var remove = function(component) {
      if ($scope.component.components.indexOf(component) !== -1) {
        $scope.component.components.splice($scope.component.components.indexOf(component), 1);
        $scope.emit('remove', component);
        $scope.$broadcast('iframeMessage', {name: 'removeElement', data: component});
      }
    };

    $scope.saveComponent = function(component) {
      $scope.emit('update', component);
      $scope.$broadcast('iframeMessage', {name: 'updateElement', data: component});
      ngDialog.closeAll(true);
    };

    $scope.removeComponent = function(component, shouldConfirm) {
      if (shouldConfirm) {
        // Show confirm dialog before removing a component
        ngDialog.open({
          template: 'formio/components/confirm-remove.html',
          showClose: false
        }).closePromise.then(function(e) {
          var cancelled = e.value === false || e.value === '$closeButton' || e.value === '$document' || e.value === '$escape';
          if (!cancelled) {
            remove(component);
          }
        });
      }
      else {
        remove(component);
      }
    };

    // Edit a specific component.
    $scope.editComponent = function(component) {
      $scope.formComponent = formioComponents.components[component.type] || formioComponents.components.custom;
      // No edit view available
      if (!$scope.formComponent.hasOwnProperty('views')) {
        return;
      }

      // Create child isolate scope for dialog
      var childScope = $scope.$new(false);
      childScope.component = component;
      childScope.data = {};
      if (component.key) {
        childScope.data[component.key] = component.multiple ? [''] : '';
      }

      var previousSettings = angular.copy(component);

      // Open the dialog.
      ngDialog.open({
        template: 'formio/components/settings.html',
        scope: childScope,
        className: 'ngdialog-theme-default component-settings',
        controller: ['$scope', 'Formio', '$controller', function($scope, Formio, $controller) {
          $scope.editorVisible = true;

          // Allow the component to add custom logic to the edit page.
          if ($scope.formComponent && $scope.formComponent.onEdit) {
            $controller($scope.formComponent.onEdit, {$scope: $scope});
          }

          $scope.$watch('component.multiple', function(value) {
            $scope.data[$scope.component.key] = value ? [''] : '';
          });

          var editorDebounce = null;
          $scope.$watchCollection('component.wysiwyg', function() {
            $scope.editorVisible = false;
            if (editorDebounce) {
              clearTimeout(editorDebounce);
            }
            editorDebounce = setTimeout(function() {
              $scope.editorVisible = true;
            }, 200);
          });

          // Watch the settings label and auto set the key from it.
          var invalidRegex = /^[^A-Za-z]*|[^A-Za-z0-9\-]*/g;
          $scope.$watch('component.label', function() {
            if ($scope.component.label && !$scope.component.lockKey && $scope.component.isNew) {
              if ($scope.data.hasOwnProperty($scope.component.key)) {
                delete $scope.data[$scope.component.key];
              }
              $scope.component.key = _camelCase($scope.component.label.replace(invalidRegex, ''));
              BuilderUtils.uniquify($scope.form, $scope.component);
              $scope.data[$scope.component.key] = $scope.component.multiple ? [''] : '';
            }
          });
        }]
      }).closePromise.then(function(e) {
        var cancelled = e.value === false || e.value === '$closeButton' || e.value === '$document' || e.value === '$escape';
        if (cancelled) {
          if (component.isNew) {
            return remove(component);
          }

          // Revert to old settings, but use the same object reference
          _assign(component, previousSettings);
          return;
        }

        FormioUtils.eachComponent([component], function(child) {
          delete child.isNew;
        }, true);
        $scope.$broadcast('iframeMessage', {name: 'updateElement', data: component});
        $scope.emit('edit', component);
      });
    };

    // Clone form component
    $scope.cloneComponent = function(component) {
      $scope.formElement = angular.copy(component);
      $scope.formElement.key = component.key + '' + $scope.form.components.length;
      $scope.form.components.push($scope.formElement);
    };

    // Add to scope so it can be used in templates
    $scope.dndDragIframeWorkaround = dndDragIframeWorkaround;
  }
];

},{"lodash/assign":167,"lodash/camelCase":168,"lodash/isNumber":188}],250:[function(_dereq_,module,exports){
"use strict";
module.exports = [
  'formioElementDirective',
  function(formioElementDirective) {
    return angular.extend({}, formioElementDirective[0], {
      scope: false,
      controller: [
        '$scope',
        'formioComponents',
        function(
          $scope,
          formioComponents
        ) {
          $scope.builder = true;
          $scope.formComponent = formioComponents.components[$scope.component.type] || formioComponents.components.custom;
          if ($scope.formComponent.fbtemplate) {
            $scope.template = $scope.formComponent.fbtemplate;
          }
        }
      ]
    });
  }
];

},{}],251:[function(_dereq_,module,exports){
"use strict";
module.exports = [
  function() {
    return {
      scope: {
        component: '=',
        formio: '=',
        form: '=',
        // # of items needed in the list before hiding the
        // drag and drop prompt div
        hideDndBoxCount: '=',
        rootList: '=',
        options: '='
      },
      restrict: 'E',
      replace: true,
      controller: 'formBuilderDnd',
      templateUrl: 'formio/formbuilder/list.html'
    };
  }
];

},{}],252:[function(_dereq_,module,exports){
"use strict";
/**
* This directive creates a field for tweaking component options.
* This needs at least a property attribute specifying what property
* of the component to bind to.
*
* If the property is defined in COMMON_OPTIONS above, it will automatically
* populate its label, placeholder, input type, and tooltip. If not, you may specify
* those via attributes (except for tooltip, which you can specify with the title attribute).
* The generated input will also carry over any other properties you specify on this directive.
*/
module.exports = ['COMMON_OPTIONS', '$filter', function(COMMON_OPTIONS, $filter) {
  return {
    restrict: 'E',
    require: 'property',
    priority: 2,
    replace: true,
    template: function(el, attrs) {
      var formioTranslate = $filter('formioTranslate');

      var property = attrs.property;
      var label = attrs.label || (COMMON_OPTIONS[property] && COMMON_OPTIONS[property].label) || '';
      var placeholder = (COMMON_OPTIONS[property] && COMMON_OPTIONS[property].placeholder) || null;
      var type = attrs.type || (COMMON_OPTIONS[property] && COMMON_OPTIONS[property].type) || 'text';
      var tooltip = (COMMON_OPTIONS[property] && COMMON_OPTIONS[property].tooltip) || '';

      var input = type === 'textarea' ? angular.element('<textarea></textarea>') : angular.element('<input>');
      var inputAttrs = {
        id: property,
        name: property,
        type: type,
        'ng-model': 'component.' + property,
        placeholder: formioTranslate(placeholder)
      };
      // Pass through attributes from the directive to the input element
      angular.forEach(attrs.$attr, function(key) {
        inputAttrs[key] = attrs[attrs.$normalize(key)];
        // Allow specifying tooltip via title attr
        if (key.toLowerCase() === 'title') {
          tooltip = attrs[key];
        }
      });

      // Add min/max value floor values for validation.
      if (property === 'validate.minLength' || property === 'validate.maxLength') {
        inputAttrs.min = 0;
      }

      input.attr(inputAttrs);

      // Checkboxes have a slightly different layout
      if (inputAttrs.type && inputAttrs.type.toLowerCase() === 'checkbox') {
        return '<div class="checkbox">' +
                '<label for="' + property + '" form-builder-tooltip="' + formioTranslate(tooltip) + '">' +
                input.prop('outerHTML') +
                ' ' + formioTranslate(label) + '</label>' +
              '</div>';
      }

      input.addClass('form-control');
      return '<div class="form-group">' +
                '<label for="' + property + '" form-builder-tooltip="' + formioTranslate(tooltip) + '">' + formioTranslate(label) + '</label>' +
                input.prop('outerHTML') +
              '</div>';
    }
  };
}];

},{}],253:[function(_dereq_,module,exports){
"use strict";
/**
* A directive for editing a component's custom validation.
*/
module.exports = function() {
  return {
    restrict: 'E',
    replace: true,
    template: '' +
      '<div>' +
      '<uib-accordion>' +
      '  <div uib-accordion-group heading="Custom Validation" class="panel panel-default">' +
      '    <textarea class="form-control" rows="5" id="custom" name="custom" ng-model="component.validate.custom" placeholder="/*** Example Code ***/\nvalid = (input === 3) ? true : \'Must be 3\';">{{ component.validate.custom }}</textarea>' +
      '    <small>' +
      '      <p>Enter custom validation code.</p>' +
      '      <p>You must assign the <strong>valid</strong> variable as either <strong>true</strong> or an error message if validation fails.</p>' +
      '      <p>The global variables <strong>input</strong>, <strong>component</strong>, and <strong>valid</strong> are provided.</p>' +
      '    </small>' +
      '    <div class="well">' +
      '      <div class="checkbox">' +
      '        <label>' +
      '          <input type="checkbox" id="private" name="private" ng-model="component.validate.customPrivate" ng-checked="component.validate.customPrivate"> <strong>Secret Validation</strong>' +
      '        </label>' +
      '      </div>' +
      '      <p>Check this if you wish to perform the validation ONLY on the server side. This keeps your validation logic private and secret.</p>' +
      '    </div>' +
      '  </div>' +
      '  <div uib-accordion-group heading="JSON Validation" class="panel panel-default">' +
      '    <small>' +
      '      <p>Execute custom validation logic with JSON and <a href="http://jsonlogic.com/">JsonLogic</a>.</p>' +
      '      <p>Submission data is available as JsonLogic variables, with the same api key as your components.</p>' +
      '      <p><a href="http://formio.github.io/formio.js/app/examples/conditions.html" target="_blank">Click here for an example</a></p>' +
      '    </small>' +
      '    <textarea class="form-control" rows="5" id="json" name="json" json-input ng-model="component.validate.json" placeholder=\'{ ... }\'></textarea>' +
      '  </div>' +
      '</uib-accordion>' +
      '</div>'
  };
};

},{}],254:[function(_dereq_,module,exports){
"use strict";
/**
* A directive for a field to edit a component's key.
*/
module.exports = function() {
  return {
    restrict: 'E',
    replace: true,
    template: function() {
      return '<div class="form-group" ng-class="{\'has-warning\': shouldWarnAboutEmbedding()}">' +
                '<div class="alert alert-warning" role="alert" ng-if="!component.isNew">' +
                'Changing the API key will cause you to lose existing submission data associated with this component.' +
                '</div>' +
                '<label for="key" class="control-label" form-builder-tooltip="The name of this field in the API endpoint.">Property Name</label>' +
                '<input type="text" class="form-control" id="key" name="key" ng-model="component.key" valid-api-key value="{{ component.key }}" ' +
                'ng-disabled="component.source" ng-blur="onBlur()">' +
                '<p ng-if="shouldWarnAboutEmbedding()" class="help-block"><span class="glyphicon glyphicon-exclamation-sign"></span> ' +
                  'Using a dot in your Property Name will link this field to a field from a Resource. Doing this manually is not recommended because you will experience unexpected behavior if the Resource field is not found. If you wish to embed a Resource field in your form, use a component from the corresponding Resource Components category on the left.' +
                '</p>' +
              '</div>';
    },
    controller: ['$scope', 'BuilderUtils', function($scope, BuilderUtils) {
      BuilderUtils.uniquify($scope.form, $scope.component);

      $scope.onBlur = function() {
        $scope.component.lockKey = true;

        // If they try to input an empty key, refill it with default and let uniquify make it unique.
        if (!$scope.component.key && $scope.formComponents[$scope.component.type].settings.key) {
          $scope.component.key = $scope.formComponents[$scope.component.type].settings.key;
          $scope.component.lockKey = false; // Also unlock key
          BuilderUtils.uniquify($scope.form, $scope.component);
        }
      };

      $scope.shouldWarnAboutEmbedding = function() {
        if (!$scope.component || !$scope.component.key) {
          return false;
        }
        return !$scope.component.source && $scope.component.key.indexOf('.') !== -1;
      };
    }]
  };
};

},{}],255:[function(_dereq_,module,exports){
"use strict";
/**
* A directive for a field to edit a component's tags.
*/
var _map = _dereq_('lodash/map');
module.exports = function() {
  return {
    restrict: 'E',
    replace: true,
    template: function() {
      return '' +
        '<div class="form-group">' +
        '  <label class="control-label" form-builder-tooltip="Tag the field for use in custom logic.">Field Tags</label>' +
        '  <tags-input ng-model="tags" on-tag-added="addTag($tag)" on-tag-removed="removeTag($tag)"></tags-input>' +
        '</div>';
    },
    controller: ['$scope', function($scope) {
      $scope.component.tags = $scope.component.tags || [];
      $scope.tags = _map($scope.component.tags, function(tag) {
        return {text: tag};
      });

      $scope.addTag = function(tag) {
        if (!$scope.component) {
          return;
        }
        if (!$scope.component.tags) {
          $scope.component.tags = [];
        }
        $scope.component.tags.push(tag.text);
      };
      $scope.removeTag = function(tag) {
        if ($scope.component.tags && $scope.component.tags.length) {
          var tagIndex = $scope.component.tags.indexOf(tag.text);
          if (tagIndex !== -1) {
            $scope.component.tags.splice(tagIndex, 1);
          }
        }
      };
    }]
  };
};

},{"lodash/map":196}],256:[function(_dereq_,module,exports){
"use strict";
module.exports = [
  function() {
    return {
      scope: {
        component: '=',
        formio: '=',
        form: '=',
        // # of items needed in the list before hiding the
        // drag and drop prompt div
        hideDndBoxCount: '=',
        options: '='
      },
      restrict: 'E',
      replace: true,
      controller: 'formBuilderDnd',
      templateUrl: 'formio/formbuilder/row.html'
    };
  }
];

},{}],257:[function(_dereq_,module,exports){
"use strict";
/**
 * A directive for a table builder
 */
var _merge = _dereq_('lodash/merge');
module.exports = function() {
  return {
    restrict: 'E',
    replace: true,
    template: function() {
      return '<div class="form-builder-table">' +
        '  <div class="form-group">' +
        '    <label for="label">Number of Rows</label>' +
        '    <input type="number" class="form-control" id="numRows" name="numRows" placeholder="Number of Rows" ng-model="component.numRows">' +
        '  </div>' +
        '  <div class="form-group">' +
        '    <label for="label">Number of Columns</label>' +
        '    <input type="number" class="form-control" id="numCols" name="numCols" placeholder="Number of Columns" ng-model="component.numCols">' +
        '  </div>' +
        '</div>';
    },
    controller: [
      '$scope',
      function($scope) {
        $scope.builder = true;
        var changeTable = function() {
          /*eslint-disable max-depth */
          if ($scope.component.numRows && $scope.component.numCols) {
            var tmpTable = [];
            $scope.component.rows.splice($scope.component.numRows);
            for (var row = 0; row < $scope.component.numRows; row++) {
              if ($scope.component.rows[row]) {
                $scope.component.rows[row].splice($scope.component.numCols);
              }
              for (var col = 0; col < $scope.component.numCols; col++) {
                if (!tmpTable[row]) {
                  tmpTable[row] = [];
                }
                tmpTable[row][col] = {components:[]};
              }
            }
            $scope.component.rows = _merge(tmpTable, $scope.component.rows);
            /*eslint-enable max-depth */
          }
        };

        $scope.$watch('component.numRows', changeTable);
        $scope.$watch('component.numCols', changeTable);
      }
    ]
  };
};

},{"lodash/merge":198}],258:[function(_dereq_,module,exports){
"use strict";
/**
* Invokes Bootstrap's popover jquery plugin on an element
* Tooltip text can be provided via title attribute or
* as the value for this directive.
*/
module.exports = ['$filter', function($filter) {
  return {
    restrict: 'A',
    replace: false,
    link: function($scope, el, attrs) {
      var formioTranslate = $filter('formioTranslate');

      if (attrs.formBuilderTooltip || attrs.title) {
        var tooltip = angular.element('<i class="glyphicon glyphicon-question-sign text-muted"></i>');
        tooltip.popover({
          html: true,
          trigger: 'manual',
          placement: 'right',
          content: formioTranslate(attrs.title || attrs.formBuilderTooltip)
        }).on('mouseenter', function() {
          var $self = angular.element(this);
          $self.popover('show');
          $self.siblings('.popover').on('mouseleave', function() {
            $self.popover('hide');
          });
        }).on('mouseleave', function() {
          var $self = angular.element(this);
          setTimeout(function() {
            if (!angular.element('.popover:hover').length) {
              $self.popover('hide');
            }
          }, 100);
        });
        el.append(' ').append(tooltip);
      }
    }
  };
}];

},{}],259:[function(_dereq_,module,exports){
"use strict";
module.exports = function() {
  return {
    restrict: 'A',
    require: 'ngModel',
    link: function(scope, elem, attr, ctrl) {
      ctrl.$parsers.push(function(input) {
        try {
          var obj = JSON.parse(input);
          ctrl.$setValidity('jsonInput', true);
          return obj;
        }
        catch (e) {
          ctrl.$setValidity('jsonInput', false);
          return undefined;
        }
      });
      ctrl.$formatters.push(function(data) {
        if (data === null) {
          ctrl.$setValidity('jsonInput', false);
          return '';
        }
        try {
          var str = angular.toJson(data, true);
          ctrl.$setValidity('jsonInput', true);
          return str;
        }
        catch (e) {
          ctrl.$setValidity('jsonInput', false);
          return '';
        }
      });
    }
  };
};

},{}],260:[function(_dereq_,module,exports){
"use strict";
/*
* Prevents user inputting invalid api key characters.
* Valid characters for an api key are alphanumeric and hyphens
*/
module.exports = function() {
  return {
    require: 'ngModel',
    link: function(scope, element, attrs, ngModel) {
      var invalidRegex = /^[^A-Za-z]+|[^A-Za-z0-9\-\.]+/g;
      ngModel.$parsers.push(function(inputValue) {
        var transformedInput = inputValue.replace(invalidRegex, '');
        if (transformedInput !== inputValue) {
          ngModel.$setViewValue(transformedInput);
          ngModel.$render();
        }
        return transformedInput;
     });
    }
  };
};

},{}],261:[function(_dereq_,module,exports){
"use strict";
/**
* A directive that provides a UI to add {value, label} objects to an array.
*/
var _map = _dereq_('lodash/map');
var _camelCase = _dereq_('lodash/camelCase');
module.exports = function() {
  return {
    scope: {
      data: '=',
      label: '@',
      tooltipText: '@',
      valueLabel: '@',
      labelLabel: '@',
      valueProperty: '@',
      labelProperty: '@'
    },
    restrict: 'E',
    template: '<div class="form-group">' +
                '<label form-builder-tooltip="{{ tooltipText |formioTranslate }}">{{ label |formioTranslate }}</label>' +
                '<table class="table table-condensed">' +
                  '<thead>' +
                    '<tr>' +
                      '<th class="col-xs-6">{{ labelLabel |formioTranslate }}</th>' +
                      '<th class="col-xs-4">{{ valueLabel |formioTranslate }}</th>' +
                      '<th class="col-xs-2"></th>' +
                    '</tr>' +
                  '</thead>' +
                  '<tbody>' +
                    '<tr ng-repeat="v in data track by $index">' +
                      '<td class="col-xs-6"><input type="text" class="form-control" ng-model="v[labelProperty]" placeholder="{{ labelLabel |formioTranslate }}"/></td>' +
                      '<td class="col-xs-4"><input type="text" class="form-control" ng-model="v[valueProperty]" placeholder="{{ valueLabel |formioTranslate }}"/></td>' +
                      '<td class="col-xs-2"><button type="button" class="btn btn-danger btn-xs" ng-click="removeValue($index)" tabindex="-1"><span class="glyphicon glyphicon-remove-circle"></span></button></td>' +
                    '</tr>' +
                  '</tbody>' +
                '</table>' +
                '<button type="button" class="btn" ng-click="addValue()">{{ \'Add Value\' |formioTranslate }}</button>' +
              '</div>',
    replace: true,
    link: function($scope, el, attrs) {
      $scope.valueProperty = $scope.valueProperty || 'value';
      $scope.labelProperty = $scope.labelProperty || 'label';
      $scope.valueLabel = $scope.valueLabel || 'Value';
      $scope.labelLabel = $scope.labelLabel || 'Label';
      $scope.data = $scope.data || [];

      $scope.addValue = function() {
        var obj = {};
        obj[$scope.valueProperty] = '';
        obj[$scope.labelProperty] = '';
        $scope.data.push(obj);
      };

      $scope.removeValue = function(index) {
        $scope.data.splice(index, 1);
      };

      if ($scope.data.length === 0) {
        $scope.addValue();
      }

      if (!attrs.noAutocompleteValue) {
        $scope.$watch('data', function(newValue, oldValue) {
          // Ignore array addition/deletion changes
          if (newValue.length !== oldValue.length) {
            return;
          }

          _map(newValue, function(entry, i) {
            if (entry[$scope.labelProperty] !== oldValue[i][$scope.labelProperty]) {// label changed
              if (entry[$scope.valueProperty] === '' || entry[$scope.valueProperty] === _camelCase(oldValue[i][$scope.labelProperty])) {
                entry[$scope.valueProperty] = _camelCase(entry[$scope.labelProperty]);
              }
            }
          });
        }, true);
      }
    }
  };
};

},{"lodash/camelCase":168,"lodash/map":196}],262:[function(_dereq_,module,exports){
"use strict";
'use strict';

module.exports = ['FormioUtils', function(FormioUtils) {
  var suffixRegex = /(\d+)$/;

  /**
   * Memoize the given form components in a map, using the component keys.
   *
   * @param {Array} components
   *   An array of the form components.
   * @param {Object} input
   *   The input component we're trying to uniquify.
   *
   * @returns {Object}
   *   The memoized form components.
   */
  var findExistingComponents = function(components, input) {
    // Prebuild a list of existing components.
    var existingComponents = {};
    FormioUtils.eachComponent(components, function(component) {
      // If theres no key, we cant compare components.
      if (!component.key) return;

      // A component is pre-existing if the key is unique, or the key is a duplicate and its not flagged as the new component.
      if (
        (component.key !== input.key) ||
        ((component.key === input.key) && (!!component.isNew !== !!input.isNew))
      ) {
        existingComponents[component.key] = component;
      }
    }, true);

    return existingComponents;
  };

  /**
   * Determine if the given component key already exists in the memoization.
   *
   * @param {Object} memoization
   *   The form components map.
   * @param component
   *   The component to uniquify.
   *
   * @returns {boolean}
   *   Whether or not the key exists.
   */
  var keyExists = function(memoization, key) {
    if (memoization.hasOwnProperty(key)) {
      return true;
    }
    return false;
  };

  /**
   * Iterate the given key to make it unique.
   *
   * @param {String} key
   *   Modify the component key to be unique.
   *
   * @returns {String}
   *   The new component key.
   */
  var iterateKey = function(key) {
    if (!key.match(suffixRegex)) {
      return key + '2';
    }

    return key.replace(suffixRegex, function(suffix) {
      return Number(suffix) + 1;
    });
  };

  /**
   * Appends a number to a component.key to keep it unique
   *
   * @param {Object} form
   *   The components parent form.
   * @param {Object} component
   *   The component to uniquify
   */
  var uniquify = function(form, component) {
    var isNew = component.isNew || false;

    // Recurse into all child components.
    FormioUtils.eachComponent([component], function(component) {
      // Force the component isNew to be the same as the parent.
      component.isNew = isNew;

      // Skip key uniquification if this component doesn't have a key.
      if (!component.key) {
        return;
      }

      var memoization = findExistingComponents(form.components, component);
      while (keyExists(memoization, component.key)) {
        component.key = iterateKey(component.key);
      }
    }, true);

    return component;
  };

  return {
    uniquify: uniquify
  };
}];

},{}],263:[function(_dereq_,module,exports){
"use strict";
// Create an AngularJS service called debounce
module.exports = ['$timeout','$q', function($timeout, $q) {
  // The service is actually this function, which we call with the func
  // that should be debounced and how long to wait in between calls
  return function debounce(func, wait, immediate) {
    var timeout;
    // Create a deferred object that will be resolved when we need to
    // actually call the func
    var deferred = $q.defer();
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) {
          deferred.resolve(func.apply(context, args));
          deferred = $q.defer();
        }
      };
      var callNow = immediate && !timeout;
      if ( timeout ) {
        $timeout.cancel(timeout);
      }
      timeout = $timeout(later, wait);
      if (callNow) {
        deferred.resolve(func.apply(context,args));
        deferred = $q.defer();
      }
      return deferred.promise;
    };
  };
}];

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsInNyYy9uZ0Zvcm1CdWlsZGVyLmpzIiwiLi5cXC4uXFwuLlxcbmdGb3JtQnVpbGRlclxcbm9kZV9tb2R1bGVzXFxmb3JtaW9qc1xcYnVpbGRcXHV0aWxzXFxpbmRleC5qcyIsIi4uXFwuLlxcLi5cXG5nRm9ybUJ1aWxkZXJcXG5vZGVfbW9kdWxlc1xcZm9ybWlvanNcXHV0aWxzLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvanNvbi1sb2dpYy1qcy9sb2dpYy5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fRGF0YVZpZXcuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0hhc2guanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXBDYWNoZS5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fUHJvbWlzZS5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fU2V0LmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19TZXRDYWNoZS5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3RhY2suanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N5bWJvbC5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fVWludDhBcnJheS5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fV2Vha01hcC5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYWRkTWFwRW50cnkuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FkZFNldEVudHJ5LmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19hcHBseS5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlBZ2dyZWdhdG9yLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUVhY2guanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5RmlsdGVyLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheU1hcC5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlQdXNoLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVJlZHVjZS5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlTb21lLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19hc2NpaVRvQXJyYXkuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FzY2lpV29yZHMuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc2lnbk1lcmdlVmFsdWUuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc2lnblZhbHVlLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NvY0luZGV4T2YuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBZ2dyZWdhdG9yLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduSW4uanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ25WYWx1ZS5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUNsb25lLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQ3JlYXRlLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRWFjaC5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZpbHRlci5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZvci5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZvck93bi5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldC5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldEFsbEtleXMuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VIYXNJbi5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzQXJndW1lbnRzLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNFcXVhbC5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzRXF1YWxEZWVwLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNNYXRjaC5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNUeXBlZEFycmF5LmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXRlcmF0ZWUuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlS2V5c0luLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWFwLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWF0Y2hlcy5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1hdGNoZXNQcm9wZXJ0eS5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1lcmdlLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWVyZ2VEZWVwLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUGlja0J5LmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUHJvcGVydHkuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQcm9wZXJ0eURlZXAuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQcm9wZXJ0eU9mLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUmVzdC5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNldC5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNldFRvU3RyaW5nLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2xpY2UuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUaW1lcy5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRvU3RyaW5nLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVW5hcnkuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NhY2hlSGFzLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19jYXN0RnVuY3Rpb24uanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RQYXRoLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19jYXN0U2xpY2UuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQXJyYXlCdWZmZXIuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQnVmZmVyLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZURhdGFWaWV3LmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZU1hcC5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVSZWdFeHAuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lU2V0LmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZVN5bWJvbC5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVUeXBlZEFycmF5LmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5QXJyYXkuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlPYmplY3QuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlTeW1ib2xzLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5U3ltYm9sc0luLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3JlSnNEYXRhLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVBZ2dyZWdhdG9yLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVBc3NpZ25lci5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQmFzZUVhY2guanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUJhc2VGb3IuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUNhc2VGaXJzdC5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQ29tcG91bmRlci5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZGVidXJyTGV0dGVyLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19kZWZpbmVQcm9wZXJ0eS5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxBcnJheXMuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsQnlUYWcuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsT2JqZWN0cy5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0QWxsS2V5cy5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0QWxsS2V5c0luLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXBEYXRhLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXRjaERhdGEuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE5hdGl2ZS5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UHJvdG90eXBlLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHMuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHNJbi5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VGFnLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRWYWx1ZS5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzUGF0aC5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzVW5pY29kZS5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzVW5pY29kZVdvcmQuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hDbGVhci5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaERlbGV0ZS5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEdldC5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEhhcy5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaFNldC5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lQXJyYXkuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZUJ5VGFnLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVPYmplY3QuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSW5kZXguanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSXRlcmF0ZWVDYWxsLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleS5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXlhYmxlLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19pc01hc2tlZC5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNQcm90b3R5cGUuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlQ2xlYXIuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZURlbGV0ZS5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlR2V0LmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVIYXMuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZVNldC5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVDbGVhci5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVEZWxldGUuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlR2V0LmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUhhcy5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVTZXQuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcFRvQXJyYXkuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19tZW1vaXplQ2FwcGVkLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVDcmVhdGUuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXMuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXNJbi5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbm9kZVV0aWwuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyQXJnLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyUmVzdC5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0Q2FjaGVBZGQuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlSGFzLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb0FycmF5LmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb1N0cmluZy5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2hvcnRPdXQuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrQ2xlYXIuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrRGVsZXRlLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0dldC5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tIYXMuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrU2V0LmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpbmdUb0FycmF5LmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpbmdUb1BhdGguanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvS2V5LmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL190b1NvdXJjZS5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fdW5pY29kZVRvQXJyYXkuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3VuaWNvZGVXb3Jkcy5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9hc3NpZ24uanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvY2FtZWxDYXNlLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL2NhcGl0YWxpemUuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvY2xvbmUuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvY2xvbmVEZWVwLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL2NvbnN0YW50LmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL2RlYnVyci5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9lYWNoLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL2VxLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL2ZvckVhY2guanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvZ2V0LmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL2dyb3VwQnkuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvaGFzSW4uanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvaWRlbnRpdHkuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcmd1bWVudHMuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheS5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5TGlrZS5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5TGlrZU9iamVjdC5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0J1ZmZlci5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0Z1bmN0aW9uLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL2lzTGVuZ3RoLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL2lzTnVtYmVyLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0LmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0TGlrZS5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1BsYWluT2JqZWN0LmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL2lzU3ltYm9sLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL2lzVHlwZWRBcnJheS5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL2tleXNJbi5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9tYXAuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvbWVtb2l6ZS5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9tZXJnZS5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9uZWdhdGUuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvb21pdEJ5LmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL3BpY2tCeS5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9wcm9wZXJ0eS5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9yZWplY3QuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvc3R1YkFycmF5LmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJGYWxzZS5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC90b1BsYWluT2JqZWN0LmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL3RvU3RyaW5nLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL3VwcGVyRmlyc3QuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvd29yZHMuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL3NyYy9jb21wb25lbnRzL2FkZHJlc3MuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL3NyYy9jb21wb25lbnRzL2J1dHRvbi5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvc3JjL2NvbXBvbmVudHMvY2hlY2tib3guanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL3NyYy9jb21wb25lbnRzL2NvbHVtbnMuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL3NyYy9jb21wb25lbnRzL2NvbXBvbmVudHMuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL3NyYy9jb21wb25lbnRzL2NvbnRhaW5lci5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvc3JjL2NvbXBvbmVudHMvY29udGVudC5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvc3JjL2NvbXBvbmVudHMvY3VycmVuY3kuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL3NyYy9jb21wb25lbnRzL2N1c3RvbS5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvc3JjL2NvbXBvbmVudHMvZGF0YWdyaWQuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL3NyYy9jb21wb25lbnRzL2RhdGV0aW1lLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9zcmMvY29tcG9uZW50cy9kYXkuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL3NyYy9jb21wb25lbnRzL2VtYWlsLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9zcmMvY29tcG9uZW50cy9maWVsZHNldC5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvc3JjL2NvbXBvbmVudHMvZmlsZS5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvc3JjL2NvbXBvbmVudHMvZm9ybS5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvc3JjL2NvbXBvbmVudHMvaGlkZGVuLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9zcmMvY29tcG9uZW50cy9odG1sZWxlbWVudC5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvc3JjL2NvbXBvbmVudHMvaW5kZXguanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL3NyYy9jb21wb25lbnRzL251bWJlci5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvc3JjL2NvbXBvbmVudHMvcGFnZS5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvc3JjL2NvbXBvbmVudHMvcGFuZWwuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL3NyYy9jb21wb25lbnRzL3Bhc3N3b3JkLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9zcmMvY29tcG9uZW50cy9waG9uZW51bWJlci5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvc3JjL2NvbXBvbmVudHMvcmFkaW8uanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL3NyYy9jb21wb25lbnRzL3Jlc291cmNlLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9zcmMvY29tcG9uZW50cy9zZWxlY3QuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL3NyYy9jb21wb25lbnRzL3NlbGVjdGJveGVzLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9zcmMvY29tcG9uZW50cy9zaWduYXR1cmUuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL3NyYy9jb21wb25lbnRzL3N1cnZleS5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvc3JjL2NvbXBvbmVudHMvdGFibGUuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL3NyYy9jb21wb25lbnRzL3RleHRhcmVhLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9zcmMvY29tcG9uZW50cy90ZXh0ZmllbGQuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL3NyYy9jb21wb25lbnRzL3dlbGwuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL3NyYy9jb25zdGFudHMvY29tbW9uT3B0aW9ucy5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvc3JjL2NvbnN0YW50cy9mb3JtT3B0aW9ucy5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvc3JjL2RpcmVjdGl2ZXMvZm9ybUJ1aWxkZXIuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL3NyYy9kaXJlY3RpdmVzL2Zvcm1CdWlsZGVyQ29tcG9uZW50LmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9zcmMvZGlyZWN0aXZlcy9mb3JtQnVpbGRlckNvbmRpdGlvbmFsLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9zcmMvZGlyZWN0aXZlcy9mb3JtQnVpbGRlckRuZC5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvc3JjL2RpcmVjdGl2ZXMvZm9ybUJ1aWxkZXJFbGVtZW50LmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9zcmMvZGlyZWN0aXZlcy9mb3JtQnVpbGRlckxpc3QuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL3NyYy9kaXJlY3RpdmVzL2Zvcm1CdWlsZGVyT3B0aW9uLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9zcmMvZGlyZWN0aXZlcy9mb3JtQnVpbGRlck9wdGlvbkN1c3RvbVZhbGlkYXRpb24uanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL3NyYy9kaXJlY3RpdmVzL2Zvcm1CdWlsZGVyT3B0aW9uS2V5LmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9zcmMvZGlyZWN0aXZlcy9mb3JtQnVpbGRlck9wdGlvblRhZ3MuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL3NyYy9kaXJlY3RpdmVzL2Zvcm1CdWlsZGVyUm93LmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9zcmMvZGlyZWN0aXZlcy9mb3JtQnVpbGRlclRhYmxlLmpzIiwiLi4vLi4vLi4vbmdGb3JtQnVpbGRlci9zcmMvZGlyZWN0aXZlcy9mb3JtQnVpbGRlclRvb2x0aXAuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL3NyYy9kaXJlY3RpdmVzL2pzb25JbnB1dC5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvc3JjL2RpcmVjdGl2ZXMvdmFsaWRBcGlLZXkuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL3NyYy9kaXJlY3RpdmVzL3ZhbHVlQnVpbGRlci5qcyIsIi4uLy4uLy4uL25nRm9ybUJ1aWxkZXIvc3JjL2ZhY3Rvcmllcy9CdWlsZGVyVXRpbHMuanMiLCIuLi8uLi8uLi9uZ0Zvcm1CdWlsZGVyL3NyYy9mYWN0b3JpZXMvZGVib3VuY2UuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFKQTs7OztBQUVBLElBQUksVUFBVSxPQUFPLE1BQVAsS0FBa0IsVUFBbEIsSUFBZ0MsU0FBTyxPQUFPLFFBQWQsTUFBMkIsUUFBM0QsR0FBc0UsVUFBVSxHQUFWLEVBQWU7QUFBRSxnQkFBYyxHQUFkLDBDQUFjLEdBQWQ7QUFBb0IsQ0FBM0csR0FBOEcsVUFBVSxHQUFWLEVBQWU7QUFBRSxTQUFPLE9BQU8sT0FBTyxNQUFQLEtBQWtCLFVBQXpCLElBQXVDLElBQUksV0FBSixLQUFvQixNQUEzRCxJQUFxRSxRQUFRLE9BQU8sU0FBcEYsR0FBZ0csUUFBaEcsVUFBa0gsR0FBbEgsMENBQWtILEdBQWxILENBQVA7QUFBK0gsQ0FBNVE7O0FBRUEsSUFBSSxlQUFlLFFBQVEsZUFBUixDQUFuQjs7QUFFQSxJQUFJLGdCQUFnQix1QkFBdUIsWUFBdkIsQ0FBcEI7O0FBRUEsU0FBUyxzQkFBVCxDQUFnQyxHQUFoQyxFQUFxQztBQUFFLFNBQU8sT0FBTyxJQUFJLFVBQVgsR0FBd0IsR0FBeEIsR0FBOEIsRUFBRSxTQUFTLEdBQVgsRUFBckM7QUFBd0Q7O0FBRS9GLElBQUksT0FBTyxRQUFRLFlBQVIsQ0FBWDs7QUFFQSxPQUFPLE9BQVAsR0FBaUI7QUFDZjs7Ozs7Ozs7O0FBU0EscUJBQW1CLFNBQVMsaUJBQVQsQ0FBMkIsU0FBM0IsRUFBc0M7QUFDdkQsV0FBTyxVQUFVLE9BQVYsSUFBcUIsTUFBTSxPQUFOLENBQWMsVUFBVSxPQUF4QixDQUFyQixJQUF5RCxVQUFVLElBQVYsSUFBa0IsTUFBTSxPQUFOLENBQWMsVUFBVSxJQUF4QixDQUEzRSxJQUE0RyxVQUFVLFVBQVYsSUFBd0IsTUFBTSxPQUFOLENBQWMsVUFBVSxVQUF4QixDQUFwSSxHQUEwSyxJQUExSyxHQUFpTCxLQUF4TDtBQUNELEdBWmM7O0FBY2Y7Ozs7Ozs7Ozs7OztBQVlBLGlCQUFlLFNBQVMsYUFBVCxDQUF1QixVQUF2QixFQUFtQyxFQUFuQyxFQUF1QyxVQUF2QyxFQUFtRCxJQUFuRCxFQUF5RDtBQUN0RSxRQUFJLENBQUMsVUFBTCxFQUFpQjtBQUNqQixXQUFPLFFBQVEsRUFBZjtBQUNBLGVBQVcsT0FBWCxDQUFtQixVQUFVLFNBQVYsRUFBcUI7QUFDdEMsVUFBSSxhQUFhLFVBQVUsT0FBVixJQUFxQixNQUFNLE9BQU4sQ0FBYyxVQUFVLE9BQXhCLENBQXRDO0FBQ0EsVUFBSSxVQUFVLFVBQVUsSUFBVixJQUFrQixNQUFNLE9BQU4sQ0FBYyxVQUFVLElBQXhCLENBQWhDO0FBQ0EsVUFBSSxXQUFXLFVBQVUsVUFBVixJQUF3QixNQUFNLE9BQU4sQ0FBYyxVQUFVLFVBQXhCLENBQXZDO0FBQ0EsVUFBSSxZQUFZLEtBQWhCO0FBQ0EsVUFBSSxVQUFVLFVBQVUsR0FBVixHQUFnQixPQUFPLE9BQU8sR0FBUCxHQUFhLFVBQVUsR0FBOUIsR0FBb0MsVUFBVSxHQUE5RCxHQUFvRSxFQUFsRjs7QUFFQSxVQUFJLGNBQWMsVUFBVSxJQUF4QixJQUFnQyxDQUFDLFVBQUQsSUFBZSxDQUFDLE9BQWhCLElBQTJCLENBQUMsUUFBaEUsRUFBMEU7QUFDeEUsb0JBQVksR0FBRyxTQUFILEVBQWMsT0FBZCxDQUFaO0FBQ0Q7O0FBRUQsVUFBSSxVQUFVLFNBQVMsT0FBVCxHQUFtQjtBQUMvQixZQUFJLFVBQVUsR0FBVixLQUFrQixVQUFVLElBQVYsS0FBbUIsVUFBbkIsSUFBaUMsVUFBVSxJQUFWLEtBQW1CLFdBQXRFLENBQUosRUFBd0Y7QUFDdEYsaUJBQU8sT0FBUDtBQUNEO0FBQ0QsZUFBTyxJQUFQO0FBQ0QsT0FMRDs7QUFPQSxVQUFJLENBQUMsU0FBTCxFQUFnQjtBQUNkLFlBQUksVUFBSixFQUFnQjtBQUNkLG9CQUFVLE9BQVYsQ0FBa0IsT0FBbEIsQ0FBMEIsVUFBVSxNQUFWLEVBQWtCO0FBQzFDLDBCQUFjLE9BQU8sVUFBckIsRUFBaUMsRUFBakMsRUFBcUMsVUFBckMsRUFBaUQsU0FBakQ7QUFDRCxXQUZEO0FBR0QsU0FKRCxNQUlPLElBQUksT0FBSixFQUFhO0FBQ2xCLGFBQUcsTUFBSCxDQUFVLEtBQVYsQ0FBZ0IsRUFBaEIsRUFBb0IsVUFBVSxJQUE5QixFQUFvQyxPQUFwQyxDQUE0QyxVQUFVLEdBQVYsRUFBZTtBQUN6RCwwQkFBYyxJQUFJLFVBQWxCLEVBQThCLEVBQTlCLEVBQWtDLFVBQWxDLEVBQThDLFNBQTlDO0FBQ0QsV0FGRDtBQUdELFNBSk0sTUFJQSxJQUFJLFFBQUosRUFBYztBQUNuQix3QkFBYyxVQUFVLFVBQXhCLEVBQW9DLEVBQXBDLEVBQXdDLFVBQXhDLEVBQW9ELFNBQXBEO0FBQ0Q7QUFDRjtBQUNGLEtBL0JEO0FBZ0NELEdBN0RjOztBQStEZjs7Ozs7Ozs7Ozs7QUFXQSxnQkFBYyxTQUFTLFlBQVQsQ0FBc0IsVUFBdEIsRUFBa0MsR0FBbEMsRUFBdUM7QUFDbkQsUUFBSSxNQUFKO0FBQ0EsV0FBTyxPQUFQLENBQWUsYUFBZixDQUE2QixVQUE3QixFQUF5QyxVQUFVLFNBQVYsRUFBcUI7QUFDNUQsVUFBSSxVQUFVLEdBQVYsS0FBa0IsR0FBdEIsRUFBMkI7QUFDekIsaUJBQVMsU0FBVDtBQUNEO0FBQ0YsS0FKRDtBQUtBLFdBQU8sTUFBUDtBQUNELEdBbEZjOztBQW9GZjs7Ozs7Ozs7Ozs7QUFXQSxxQkFBbUIsU0FBUyxpQkFBVCxDQUEyQixVQUEzQixFQUF1QyxVQUF2QyxFQUFtRDtBQUNwRSxRQUFJLFlBQVksRUFBaEI7QUFDQSxXQUFPLE9BQVAsQ0FBZSxhQUFmLENBQTZCLFVBQTdCLEVBQXlDLFVBQVUsU0FBVixFQUFxQixJQUFyQixFQUEyQjtBQUNsRSxnQkFBVSxJQUFWLElBQWtCLFNBQWxCO0FBQ0QsS0FGRCxFQUVHLFVBRkg7QUFHQSxXQUFPLFNBQVA7QUFDRCxHQXJHYzs7QUF1R2Y7Ozs7Ozs7QUFPQSxnQkFBYyxTQUFTLFlBQVQsQ0FBc0IsU0FBdEIsRUFBaUM7QUFDN0MsV0FBTyxVQUFVLGNBQVYsQ0FBeUIsbUJBQXpCLEtBQWlELFVBQVUsaUJBQTNELElBQWdGLFVBQVUsY0FBVixDQUF5QixhQUF6QixLQUEyQyxVQUFVLFdBQXJELElBQW9FLFVBQVUsV0FBVixDQUFzQixJQUExSyxJQUFrTCxVQUFVLGNBQVYsQ0FBeUIsYUFBekIsS0FBMkMsVUFBVSxXQUFyRCxJQUFvRSxVQUFVLFdBQVYsQ0FBc0IsSUFBblI7QUFDRCxHQWhIYzs7QUFrSGY7Ozs7Ozs7Ozs7OztBQVlBLGtCQUFnQixTQUFTLGNBQVQsQ0FBd0IsU0FBeEIsRUFBbUMsR0FBbkMsRUFBd0MsSUFBeEMsRUFBOEM7QUFDNUQsUUFBSSxVQUFVLGNBQVYsQ0FBeUIsbUJBQXpCLEtBQWlELFVBQVUsaUJBQS9ELEVBQWtGO0FBQ2hGLFVBQUk7QUFDRixZQUFJLFNBQVMsZ0NBQWI7QUFDQSxrQkFBVSxVQUFVLGlCQUFWLENBQTRCLFFBQTVCLEVBQVY7QUFDQSxrQkFBVSxxQkFBVjtBQUNBLFlBQUksU0FBUyxLQUFLLE1BQUwsQ0FBYjtBQUNBLGVBQU8sT0FBTyxRQUFQLE9BQXNCLE1BQTdCO0FBQ0QsT0FORCxDQU1FLE9BQU8sQ0FBUCxFQUFVO0FBQ1YsZ0JBQVEsSUFBUixDQUFhLHVFQUF1RSxVQUFVLEdBQTlGLEVBQW1HLENBQW5HO0FBQ0EsZUFBTyxJQUFQO0FBQ0Q7QUFDRixLQVhELE1BV08sSUFBSSxVQUFVLGNBQVYsQ0FBeUIsYUFBekIsS0FBMkMsVUFBVSxXQUFyRCxJQUFvRSxVQUFVLFdBQVYsQ0FBc0IsSUFBOUYsRUFBb0c7QUFDekcsVUFBSSxPQUFPLFVBQVUsV0FBckI7QUFDQSxVQUFJLFFBQVEsSUFBWjtBQUNBLFVBQUksR0FBSixFQUFTO0FBQ1AsZ0JBQVEsS0FBSyxRQUFMLENBQWMsRUFBRSxNQUFNLEdBQVIsRUFBZCxFQUE2QixLQUFLLElBQWxDLENBQVI7QUFDRDtBQUNELFVBQUksU0FBUyxVQUFVLElBQVYsSUFBa0IsT0FBTyxLQUFQLEtBQWlCLFdBQTVDLENBQUosRUFBOEQ7QUFDNUQsZ0JBQVEsS0FBSyxRQUFMLENBQWMsRUFBRSxNQUFNLElBQVIsRUFBZCxFQUE4QixLQUFLLElBQW5DLENBQVI7QUFDRDtBQUNEO0FBQ0EsVUFBSSxVQUFVLElBQVYsSUFBa0IsT0FBTyxLQUFQLEtBQWlCLFdBQXZDLEVBQW9EO0FBQ2xELGVBQU8sS0FBUDtBQUNEO0FBQ0Q7QUFDQSxVQUFJLENBQUMsT0FBTyxLQUFQLEtBQWlCLFdBQWpCLEdBQStCLFdBQS9CLEdBQTZDLFFBQVEsS0FBUixDQUE5QyxNQUFrRSxRQUFsRSxJQUE4RSxNQUFNLGNBQU4sQ0FBcUIsS0FBSyxFQUExQixDQUFsRixFQUFpSDtBQUMvRyxlQUFPLE1BQU0sS0FBSyxFQUFYLEVBQWUsUUFBZixPQUE4QixLQUFLLElBQUwsQ0FBVSxRQUFWLEVBQXJDO0FBQ0Q7QUFDRDtBQUNBLFVBQUksaUJBQWlCLEtBQWpCLElBQTBCLE1BQU0sT0FBTixDQUFjLEtBQUssRUFBbkIsTUFBMkIsQ0FBQyxDQUExRCxFQUE2RDtBQUMzRCxlQUFPLEtBQUssSUFBTCxDQUFVLFFBQVYsT0FBeUIsTUFBaEM7QUFDRDs7QUFFRCxhQUFPLE1BQU0sUUFBTixPQUFxQixLQUFLLEVBQUwsQ0FBUSxRQUFSLEVBQXJCLE1BQTZDLEtBQUssSUFBTCxDQUFVLFFBQVYsT0FBeUIsTUFBdEUsQ0FBUDtBQUNELEtBdkJNLE1BdUJBLElBQUksVUFBVSxjQUFWLENBQXlCLGFBQXpCLEtBQTJDLFVBQVUsV0FBckQsSUFBb0UsVUFBVSxXQUFWLENBQXNCLElBQTlGLEVBQW9HO0FBQ3pHLGFBQU8sY0FBYyxPQUFkLENBQXNCLEtBQXRCLENBQTRCLFVBQVUsV0FBVixDQUFzQixJQUFsRCxFQUF3RDtBQUM3RCxjQUFNLElBRHVEO0FBRTdELGFBQUs7QUFGd0QsT0FBeEQsQ0FBUDtBQUlEOztBQUVEO0FBQ0EsV0FBTyxJQUFQO0FBQ0QsR0ExS2M7O0FBNEtmOzs7Ozs7OztBQVFBLFlBQVUsU0FBUyxRQUFULENBQWtCLFVBQWxCLEVBQThCLEdBQTlCLEVBQW1DO0FBQzNDLFFBQUksT0FBTyxXQUFXLElBQVgsSUFBbUIsRUFBOUI7O0FBRUEsUUFBSSxTQUFTLFNBQVMsTUFBVCxDQUFnQixJQUFoQixFQUFzQjtBQUNqQyxVQUFJLENBQUo7QUFDQSxVQUFJLEtBQUo7O0FBRUEsVUFBSSxDQUFDLElBQUwsRUFBVztBQUNULGVBQU8sSUFBUDtBQUNEOztBQUVELFVBQUksQ0FBQyxPQUFPLElBQVAsS0FBZ0IsV0FBaEIsR0FBOEIsV0FBOUIsR0FBNEMsUUFBUSxJQUFSLENBQTdDLE1BQWdFLFFBQWhFLElBQTRFLEVBQUUsZ0JBQWdCLEtBQWxCLENBQWhGLEVBQTBHO0FBQ3hHLFlBQUksS0FBSyxjQUFMLENBQW9CLEdBQXBCLENBQUosRUFBOEI7QUFDNUIsaUJBQU8sS0FBSyxHQUFMLENBQVA7QUFDRDs7QUFFRCxZQUFJLE9BQU8sT0FBTyxJQUFQLENBQVksSUFBWixDQUFYO0FBQ0EsYUFBSyxJQUFJLENBQVQsRUFBWSxJQUFJLEtBQUssTUFBckIsRUFBNkIsR0FBN0IsRUFBa0M7QUFDaEMsY0FBSSxRQUFRLEtBQUssS0FBSyxDQUFMLENBQUwsQ0FBUixNQUEyQixRQUEvQixFQUF5QztBQUN2QyxvQkFBUSxPQUFPLEtBQUssS0FBSyxDQUFMLENBQUwsQ0FBUCxDQUFSO0FBQ0Q7O0FBRUQsY0FBSSxLQUFKLEVBQVc7QUFDVCxtQkFBTyxLQUFQO0FBQ0Q7QUFDRjtBQUNGO0FBQ0YsS0F4QkQ7O0FBMEJBLFdBQU8sT0FBTyxJQUFQLENBQVA7QUFDRCxHQWxOYzs7QUFvTmY7Ozs7Ozs7QUFPQSxlQUFhLFNBQVMsV0FBVCxDQUFxQixNQUFyQixFQUE2QixJQUE3QixFQUFtQztBQUM5QyxXQUFPLE9BQU8sT0FBUCxDQUFlLHlCQUFmLEVBQTBDLFVBQVUsS0FBVixFQUFpQixLQUFqQixFQUF3QjtBQUN2RSxhQUFPLEtBQUssSUFBTCxFQUFXLEtBQVgsQ0FBUDtBQUNELEtBRk0sQ0FBUDtBQUdEO0FBL05jLENBQWpCOzs7QUNaQTs7QUFDQSxPQUFPLE9BQVAsR0FBaUIsUUFBUSxlQUFSLENBQWpCOzs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJcInVzZSBzdHJpY3RcIjtcbi8qISBuZy1mb3JtaW8tYnVpbGRlciB2PCU9dmVyc2lvbiU+IHwgaHR0cHM6Ly91bnBrZy5jb20vbmctZm9ybWlvLWJ1aWxkZXJAPCU9dmVyc2lvbiU+L0xJQ0VOU0UudHh0ICovXHJcbi8qZ2xvYmFsIHdpbmRvdzogZmFsc2UsIGNvbnNvbGU6IGZhbHNlLCBqUXVlcnk6IGZhbHNlICovXHJcbi8qanNoaW50IGJyb3dzZXI6IHRydWUgKi9cclxuXHJcblxyXG52YXIgYXBwID0gYW5ndWxhci5tb2R1bGUoJ25nRm9ybUJ1aWxkZXInLCBbXHJcbiAgJ2Zvcm1pbycsXHJcbiAgJ2RuZExpc3RzJyxcclxuICAnbmdEaWFsb2cnLFxyXG4gICd1aS5ib290c3RyYXAuYWNjb3JkaW9uJyxcclxuICAnY2tlZGl0b3InXHJcbl0pO1xyXG5cclxuYXBwLmNvbnN0YW50KCdGT1JNX09QVElPTlMnLCByZXF1aXJlKCcuL2NvbnN0YW50cy9mb3JtT3B0aW9ucycpKTtcclxuXHJcbmFwcC5jb25zdGFudCgnQ09NTU9OX09QVElPTlMnLCByZXF1aXJlKCcuL2NvbnN0YW50cy9jb21tb25PcHRpb25zJykpO1xyXG5cclxuYXBwLmZhY3RvcnkoJ2RlYm91bmNlJywgcmVxdWlyZSgnLi9mYWN0b3JpZXMvZGVib3VuY2UnKSk7XHJcblxyXG5hcHAuZGlyZWN0aXZlKCdmb3JtQnVpbGRlckRyYWdnYWJsZScsIGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXN0cmljdDogJ0EnLFxyXG4gICAgc2NvcGU6IHtcclxuICAgICAgJ2Zvcm1CdWlsZGVyRHJhZ2dhYmxlJzogJz0nXHJcbiAgICB9LFxyXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQpIHtcclxuICAgICAgdmFyIGVsID0gZWxlbWVudFswXTtcclxuICAgICAgZWwuZHJhZ2dhYmxlID0gdHJ1ZTtcclxuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICB2YXIgZHJhZ0RhdGEgPSBzY29wZS5mb3JtQnVpbGRlckRyYWdnYWJsZTtcclxuICAgICAgICB2YXIgZHJvcFpvbmUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmItZHJvcC16b25lJyk7XHJcbiAgICAgICAgaWYgKGRyb3Bab25lKSB7XHJcbiAgICAgICAgICBkcm9wWm9uZS5zdHlsZS56SW5kZXggPSAxMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoJ1RleHQnLCBKU09OLnN0cmluZ2lmeShkcmFnRGF0YSkpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfSwgZmFsc2UpO1xyXG4gICAgfVxyXG4gIH07XHJcbn0pO1xyXG5cclxuYXBwLmRpcmVjdGl2ZSgnZm9ybUJ1aWxkZXJEcm9wcGFibGUnLCBmdW5jdGlvbigpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcmVzdHJpY3Q6ICdBJyxcclxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50KSB7XHJcbiAgICAgIHZhciBlbCA9IGVsZW1lbnRbMF07XHJcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfSwgZmFsc2UpO1xyXG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdkcm9wJywgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICB2YXIgZHJhZ0RhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGFUcmFuc2Zlci5nZXREYXRhKCd0ZXh0L3BsYWluJykpO1xyXG4gICAgICAgIHZhciBkcm9wT2Zmc2V0ID0galF1ZXJ5KGVsKS5vZmZzZXQoKTtcclxuICAgICAgICBlbC5zdHlsZS56SW5kZXggPSAwO1xyXG4gICAgICAgIGRyYWdEYXRhLmZiRHJvcFggPSBldmVudC5wYWdlWCAtIGRyb3BPZmZzZXQubGVmdDtcclxuICAgICAgICBkcmFnRGF0YS5mYkRyb3BZID0gZXZlbnQucGFnZVkgLSBkcm9wT2Zmc2V0LnRvcDtcclxuICAgICAgICBzY29wZS4kZW1pdCgnZmJEcmFnRHJvcCcsIGRyYWdEYXRhKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH0sIGZhbHNlKTtcclxuICAgIH1cclxuICB9O1xyXG59KTtcclxuXHJcbmFwcC5mYWN0b3J5KCdCdWlsZGVyVXRpbHMnLCByZXF1aXJlKCcuL2ZhY3Rvcmllcy9CdWlsZGVyVXRpbHMnKSk7XHJcblxyXG5hcHAuZGlyZWN0aXZlKCdmb3JtQnVpbGRlcicsIHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9mb3JtQnVpbGRlcicpKTtcclxuXHJcbmFwcC5kaXJlY3RpdmUoJ2Zvcm1CdWlsZGVyQ29tcG9uZW50JywgcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2Zvcm1CdWlsZGVyQ29tcG9uZW50JykpO1xyXG5cclxuYXBwLmRpcmVjdGl2ZSgnZm9ybUJ1aWxkZXJFbGVtZW50JywgcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2Zvcm1CdWlsZGVyRWxlbWVudCcpKTtcclxuXHJcbmFwcC5jb250cm9sbGVyKCdmb3JtQnVpbGRlckRuZCcsIHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9mb3JtQnVpbGRlckRuZCcpKTtcclxuXHJcbmFwcC5kaXJlY3RpdmUoJ2Zvcm1CdWlsZGVyTGlzdCcsIHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9mb3JtQnVpbGRlckxpc3QnKSk7XHJcblxyXG5hcHAuZGlyZWN0aXZlKCdmb3JtQnVpbGRlclJvdycsIHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9mb3JtQnVpbGRlclJvdycpKTtcclxuXHJcbmFwcC5kaXJlY3RpdmUoJ2pzb25JbnB1dCcsIHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9qc29uSW5wdXQnKSk7XHJcblxyXG5hcHAuZGlyZWN0aXZlKCdmb3JtQnVpbGRlck9wdGlvbicsIHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9mb3JtQnVpbGRlck9wdGlvbicpKTtcclxuXHJcbmFwcC5kaXJlY3RpdmUoJ2Zvcm1CdWlsZGVyVGFibGUnLCByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvZm9ybUJ1aWxkZXJUYWJsZScpKTtcclxuXHJcbmFwcC5kaXJlY3RpdmUoJ2Zvcm1CdWlsZGVyT3B0aW9uS2V5JywgcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2Zvcm1CdWlsZGVyT3B0aW9uS2V5JykpO1xyXG5cclxuYXBwLmRpcmVjdGl2ZSgnZm9ybUJ1aWxkZXJPcHRpb25UYWdzJywgcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2Zvcm1CdWlsZGVyT3B0aW9uVGFncycpKTtcclxuXHJcbmFwcC5kaXJlY3RpdmUoJ3ZhbGlkQXBpS2V5JywgcmVxdWlyZSgnLi9kaXJlY3RpdmVzL3ZhbGlkQXBpS2V5JykpO1xyXG5cclxuYXBwLmRpcmVjdGl2ZSgnZm9ybUJ1aWxkZXJPcHRpb25DdXN0b21WYWxpZGF0aW9uJywgcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2Zvcm1CdWlsZGVyT3B0aW9uQ3VzdG9tVmFsaWRhdGlvbicpKTtcclxuXHJcbmFwcC5kaXJlY3RpdmUoJ2Zvcm1CdWlsZGVyVG9vbHRpcCcsIHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9mb3JtQnVpbGRlclRvb2x0aXAnKSk7XHJcblxyXG5hcHAuZGlyZWN0aXZlKCd2YWx1ZUJ1aWxkZXInLCByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvdmFsdWVCdWlsZGVyJykpO1xyXG5cclxuYXBwLmRpcmVjdGl2ZSgnZm9ybUJ1aWxkZXJDb25kaXRpb25hbCcsIHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9mb3JtQnVpbGRlckNvbmRpdGlvbmFsJykpO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgd29ya2Fyb3VuZCBoYW5kbGVzIHRoZSBmYWN0IHRoYXQgaWZyYW1lcyBjYXB0dXJlIG1vdXNlIGRyYWdcclxuICogZXZlbnRzLiBUaGlzIGludGVyZmVyZXMgd2l0aCBkcmFnZ2luZyBvdmVyIGNvbXBvbmVudHMgbGlrZSB0aGVcclxuICogQ29udGVudCBjb21wb25lbnQuIEFzIGEgd29ya2Fyb3VuZCwgd2Uga2VlcCB0cmFjayBvZiB0aGUgaXNEcmFnZ2luZ1xyXG4gKiBmbGFnIGhlcmUgdG8gb3ZlcmxheSBpZnJhbWVzIHdpdGggYSBkaXYgd2hpbGUgZHJhZ2dpbmcuXHJcbiAqL1xyXG5hcHAudmFsdWUoJ2RuZERyYWdJZnJhbWVXb3JrYXJvdW5kJywge1xyXG4gIGlzRHJhZ2dpbmc6IGZhbHNlXHJcbn0pO1xyXG5cclxuYXBwLnJ1bihbXHJcbiAgJyR0ZW1wbGF0ZUNhY2hlJyxcclxuICAnJHJvb3RTY29wZScsXHJcbiAgJ25nRGlhbG9nJyxcclxuICBmdW5jdGlvbihcclxuICAgICR0ZW1wbGF0ZUNhY2hlLFxyXG4gICAgJHJvb3RTY29wZSxcclxuICAgIG5nRGlhbG9nXHJcbiAgKSB7XHJcbiAgICAvLyBDbG9zZSBhbGwgb3BlbiBkaWFsb2dzIG9uIHN0YXRlIGNoYW5nZS5cclxuICAgICRyb290U2NvcGUuJG9uKCckc3RhdGVDaGFuZ2VTdGFydCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICBuZ0RpYWxvZy5jbG9zZUFsbChmYWxzZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9mb3JtYnVpbGRlci9lZGl0YnV0dG9ucy5odG1sJyxcclxuICAgICAgXCI8ZGl2IGNsYXNzPVxcXCJjb21wb25lbnQtYnRuLWdyb3VwXFxcIj5cXHJcXG4gIDxkaXYgY2xhc3M9XFxcImJ0biBidG4teHhzIGJ0bi1kYW5nZXIgY29tcG9uZW50LXNldHRpbmdzLWJ1dHRvbiBjb21wb25lbnQtc2V0dGluZ3MtYnV0dG9uLXJlbW92ZVxcXCIgc3R5bGU9XFxcInotaW5kZXg6IDEwMDBcXFwiIG5nLWNsaWNrPVxcXCJyZW1vdmVDb21wb25lbnQoY29tcG9uZW50LCBmb3JtQ29tcG9uZW50LmNvbmZpcm1SZW1vdmUpXFxcIj48c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1yZW1vdmVcXFwiPjwvc3Bhbj48L2Rpdj5cXHJcXG4gIDxkaXYgbmctaWY9XFxcIjo6Zm9ybUNvbXBvbmVudC52aWV3cyAmJiAhY29tcG9uZW50LmxvY2tDb25maWd1cmF0aW9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi14eHMgYnRuLWRlZmF1bHQgY29tcG9uZW50LXNldHRpbmdzLWJ1dHRvbiBjb21wb25lbnQtc2V0dGluZ3MtYnV0dG9uLWNsb25lXFxcIiBzdHlsZT1cXFwiei1pbmRleDogMTAwMFxcXCIgbmctY2xpY2s9XFxcImNsb25lQ29tcG9uZW50KGNvbXBvbmVudClcXFwiPjxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLW5ldy13aW5kb3dcXFwiPjwvc3Bhbj48L2Rpdj5cXHJcXG4gIDxkaXYgbmctaWY9XFxcIjo6IWhpZGVNb3ZlQnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi14eHMgYnRuLWRlZmF1bHQgY29tcG9uZW50LXNldHRpbmdzLWJ1dHRvbiBjb21wb25lbnQtc2V0dGluZ3MtYnV0dG9uLW1vdmVcXFwiIHN0eWxlPVxcXCJ6LWluZGV4OiAxMDAwXFxcIj48c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbiBnbHlwaGljb24tbW92ZVxcXCI+PC9zcGFuPjwvZGl2PlxcclxcbiAgPGRpdiBuZy1pZj1cXFwiOjpmb3JtQ29tcG9uZW50LnZpZXdzICYmICFjb21wb25lbnQubG9ja0NvbmZpZ3VyYXRpb25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLXh4cyBidG4tZGVmYXVsdCBjb21wb25lbnQtc2V0dGluZ3MtYnV0dG9uIGNvbXBvbmVudC1zZXR0aW5ncy1idXR0b24tZWRpdFxcXCIgc3R5bGU9XFxcInotaW5kZXg6IDEwMDBcXFwiIG5nLWNsaWNrPVxcXCJlZGl0Q29tcG9uZW50KGNvbXBvbmVudClcXFwiPjxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNvZ1xcXCI+PC9zcGFuPjwvZGl2PlxcclxcbjwvZGl2PlxcclxcblwiXHJcbiAgICApO1xyXG5cclxuICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2Zvcm1idWlsZGVyL2NvbXBvbmVudC5odG1sJyxcclxuICAgICAgXCI8ZGl2IGNsYXNzPVxcXCJjb21wb25lbnQtZm9ybS1ncm91cCBjb21wb25lbnQtdHlwZS17eyBjb21wb25lbnQudHlwZSB9fSBmb3JtLWJ1aWxkZXItY29tcG9uZW50XFxcIj5cXHJcXG4gIDxkaXYgbmctaWY9XFxcIjo6IWhpZGVCdXR0b25zXFxcIiBuZy1pbmNsdWRlPVxcXCInZm9ybWlvL2Zvcm1idWlsZGVyL2VkaXRidXR0b25zLmh0bWwnXFxcIj48L2Rpdj5cXHJcXG4gIDxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXAgaGFzLWZlZWRiYWNrIGZvcm0tZmllbGQtdHlwZS17eyBjb21wb25lbnQudHlwZSB9fSB7e2NvbXBvbmVudC5jdXN0b21DbGFzc319XFxcIiBpZD1cXFwiZm9ybS1ncm91cC17eyBjb21wb25lbnQua2V5IH19XFxcIiBzdHlsZT1cXFwicG9zaXRpb246aW5oZXJpdFxcXCIgbmctc3R5bGU9XFxcImNvbXBvbmVudC5zdHlsZVxcXCI+XFxyXFxuICAgIDxmb3JtLWJ1aWxkZXItZWxlbWVudD48L2Zvcm0tYnVpbGRlci1lbGVtZW50PlxcclxcbiAgPC9kaXY+XFxyXFxuPC9kaXY+XFxyXFxuXCJcclxuICAgICk7XHJcblxyXG4gICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vZm9ybWJ1aWxkZXIvbGlzdC5odG1sJyxcclxuICAgICAgXCI8dWwgY2xhc3M9XFxcImNvbXBvbmVudC1saXN0XFxcIlxcclxcbiAgICBkbmQtbGlzdD1cXFwiY29tcG9uZW50LmNvbXBvbmVudHNcXFwiXFxyXFxuICAgIGRuZC1kcm9wPVxcXCJhZGRDb21wb25lbnQoaXRlbSwgaW5kZXgpXFxcIj5cXHJcXG4gIDxsaSBuZy1pZj1cXFwiY29tcG9uZW50LmNvbXBvbmVudHMubGVuZ3RoIDwgaGlkZUNvdW50XFxcIj5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiYWxlcnQgYWxlcnQtaW5mb1xcXCIgc3R5bGU9XFxcInRleHQtYWxpZ246Y2VudGVyOyBtYXJnaW4tYm90dG9tOiA1cHg7XFxcIiByb2xlPVxcXCJhbGVydFxcXCI+XFxyXFxuICAgICAgRHJhZyBhbmQgRHJvcCBhIGZvcm0gY29tcG9uZW50XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgPC9saT5cXHJcXG4gIDwhLS0gRE8gTk9UIFBVVCBcXFwidHJhY2sgYnkgJGluZGV4XFxcIiBIRVJFIFNJTkNFIERZTkFNSUNBTExZIEFERElORy9SRU1PVklORyBDT01QT05FTlRTIFdJTEwgQlJFQUsgLS0+XFxyXFxuICA8bGkgbmctcmVwZWF0PVxcXCJjb21wb25lbnQgaW4gY29tcG9uZW50LmNvbXBvbmVudHNcXFwiXFxyXFxuICAgICAgbmctaWY9XFxcIiFyb290TGlzdCB8fCAhZm9ybS5kaXNwbGF5IHx8IChmb3JtLmRpc3BsYXkgPT09ICdmb3JtJykgfHwgKGZvcm0ucGFnZSA9PT0gJGluZGV4KVxcXCJcXHJcXG4gICAgICBkbmQtZHJhZ2dhYmxlPVxcXCJjb21wb25lbnRcXFwiXFxyXFxuICAgICAgZG5kLWVmZmVjdC1hbGxvd2VkPVxcXCJtb3ZlXFxcIlxcclxcbiAgICAgIGRuZC1kcmFnc3RhcnQ9XFxcImRuZERyYWdJZnJhbWVXb3JrYXJvdW5kLmlzRHJhZ2dpbmcgPSB0cnVlXFxcIlxcclxcbiAgICAgIGRuZC1kcmFnZW5kPVxcXCJkbmREcmFnSWZyYW1lV29ya2Fyb3VuZC5pc0RyYWdnaW5nID0gZmFsc2VcXFwiXFxyXFxuICAgICAgZG5kLW1vdmVkPVxcXCJyZW1vdmVDb21wb25lbnQoY29tcG9uZW50LCBmYWxzZSlcXFwiPlxcclxcbiAgICA8Zm9ybS1idWlsZGVyLWNvbXBvbmVudCBuZy1pZj1cXFwiIWNvbXBvbmVudC5oaWRlQnVpbGRlclxcXCI+PC9mb3JtLWJ1aWxkZXItY29tcG9uZW50PlxcclxcbiAgICA8ZGl2IG5nLWlmPVxcXCJkbmREcmFnSWZyYW1lV29ya2Fyb3VuZC5pc0RyYWdnaW5nICYmICFmb3JtQ29tcG9uZW50Lm5vRG5kT3ZlcmxheVxcXCIgY2xhc3M9XFxcImRuZE92ZXJsYXlcXFwiPjwvZGl2PlxcclxcbiAgPC9saT5cXHJcXG48L3VsPlxcclxcblwiXHJcbiAgICApO1xyXG5cclxuICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2Zvcm1idWlsZGVyL3Jvdy5odG1sJyxcclxuICAgICAgXCI8ZGl2IGNsYXNzPVxcXCJmb3JtYnVpbGRlci1yb3dcXFwiPlxcclxcbiAgPGxhYmVsIG5nLWlmPVxcXCJjb21wb25lbnQubGFiZWxcXFwiIGNsYXNzPVxcXCJjb250cm9sLWxhYmVsXFxcIj57eyBjb21wb25lbnQubGFiZWwgfX08L2xhYmVsPlxcclxcbiAgPHVsIGNsYXNzPVxcXCJjb21wb25lbnQtcm93IGZvcm1idWlsZGVyLWdyb3VwXFxcIlxcclxcbiAgICAgIGRuZC1saXN0PVxcXCJjb21wb25lbnQuY29tcG9uZW50c1xcXCJcXHJcXG4gICAgICBkbmQtZHJvcD1cXFwiYWRkQ29tcG9uZW50KGl0ZW0sIGluZGV4KVxcXCJcXHJcXG4gICAgICBkbmQtaG9yaXpvbnRhbC1saXN0PVxcXCJ0cnVlXFxcIj5cXHJcXG4gICAgPGxpIG5nLXJlcGVhdD1cXFwiY29tcG9uZW50IGluIGNvbXBvbmVudC5jb21wb25lbnRzXFxcIlxcclxcbiAgICAgICAgY2xhc3M9XFxcImZvcm1idWlsZGVyLWdyb3VwLXJvdyBwdWxsLWxlZnRcXFwiXFxyXFxuICAgICAgICBkbmQtZHJhZ2dhYmxlPVxcXCJjb21wb25lbnRcXFwiXFxyXFxuICAgICAgICBkbmQtZWZmZWN0LWFsbG93ZWQ9XFxcIm1vdmVcXFwiXFxyXFxuICAgICAgICBkbmQtZHJhZ3N0YXJ0PVxcXCJkbmREcmFnSWZyYW1lV29ya2Fyb3VuZC5pc0RyYWdnaW5nID0gdHJ1ZVxcXCJcXHJcXG4gICAgICAgIGRuZC1kcmFnZW5kPVxcXCJkbmREcmFnSWZyYW1lV29ya2Fyb3VuZC5pc0RyYWdnaW5nID0gZmFsc2VcXFwiXFxyXFxuICAgICAgICBkbmQtbW92ZWQ9XFxcInJlbW92ZUNvbXBvbmVudChjb21wb25lbnQsIGZhbHNlKVxcXCI+XFxyXFxuICAgICAgPGZvcm0tYnVpbGRlci1jb21wb25lbnQ+PC9mb3JtLWJ1aWxkZXItY29tcG9uZW50PlxcclxcbiAgICAgIDxkaXYgbmctaWY9XFxcImRuZERyYWdJZnJhbWVXb3JrYXJvdW5kLmlzRHJhZ2dpbmcgJiYgIWZvcm1Db21wb25lbnQubm9EbmRPdmVybGF5XFxcIiBjbGFzcz1cXFwiZG5kT3ZlcmxheVxcXCI+PC9kaXY+XFxyXFxuICAgIDwvbGk+XFxyXFxuICAgIDxsaSBjbGFzcz1cXFwiZm9ybWJ1aWxkZXItZ3JvdXAtcm93IGZvcm0tYnVpbGRlci1kcm9wXFxcIiBuZy1pZj1cXFwiY29tcG9uZW50LmNvbXBvbmVudHMubGVuZ3RoIDwgaGlkZUNvdW50XFxcIj5cXHJcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJhbGVydCBhbGVydC1pbmZvXFxcIiByb2xlPVxcXCJhbGVydFxcXCI+XFxyXFxuICAgICAgICBEcmFnIGFuZCBEcm9wIGEgZm9ybSBjb21wb25lbnRcXHJcXG4gICAgICA8L2Rpdj5cXHJcXG4gICAgPC9saT5cXHJcXG4gIDwvdWw+XFxyXFxuICA8ZGl2IHN0eWxlPVxcXCJjbGVhcjpib3RoO1xcXCI+PC9kaXY+XFxyXFxuPC9kaXY+XFxyXFxuXCJcclxuICAgICk7XHJcblxyXG4gICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vZm9ybWJ1aWxkZXIvYnVpbGRlci5odG1sJyxcclxuICAgICAgXCI8ZGl2IGNsYXNzPVxcXCJyb3cgZm9ybWJ1aWxkZXJcXFwiPlxcclxcbiAgPGRpdiBjbGFzcz1cXFwiY29sLXhzLTQgY29sLXNtLTMgY29sLW1kLTIgZm9ybWNvbXBvbmVudHNcXFwiIG5nLWlmPVxcXCJmb3JtICYmIGZvcm0uZGlzcGxheVxcXCI+XFxyXFxuICAgIDx1aWItYWNjb3JkaW9uIGNsb3NlLW90aGVycz1cXFwidHJ1ZVxcXCIgbmctaWY9XFxcImZvcm0uZGlzcGxheSAhPT0gJ3BkZidcXFwiPlxcclxcbiAgICAgIDxkaXYgdWliLWFjY29yZGlvbi1ncm91cCBuZy1yZXBlYXQ9XFxcIihncm91cE5hbWUsIGdyb3VwKSBpbiBmb3JtQ29tcG9uZW50R3JvdXBzXFxcIiBoZWFkaW5nPVxcXCJ7eyBncm91cC50aXRsZSB9fVxcXCIgaXMtb3Blbj1cXFwiJGZpcnN0XFxcIiBjbGFzcz1cXFwicGFuZWwgcGFuZWwtZGVmYXVsdCBmb3JtLWJ1aWxkZXItcGFuZWwge3sgZ3JvdXAucGFuZWxDbGFzcyB9fVxcXCI+XFxyXFxuICAgICAgICA8dWliLWFjY29yZGlvbiBjbG9zZS1vdGhlcnM9XFxcInRydWVcXFwiIG5nLWlmPVxcXCJncm91cC5zdWJncm91cHNcXFwiPlxcclxcbiAgICAgICAgICA8ZGl2IHVpYi1hY2NvcmRpb24tZ3JvdXAgbmctcmVwZWF0PVxcXCIoc3ViZ3JvdXBOYW1lLCBzdWJncm91cCkgaW4gZ3JvdXAuc3ViZ3JvdXBzXFxcIiBoZWFkaW5nPVxcXCJ7eyBzdWJncm91cC50aXRsZSB9fVxcXCIgaXMtb3Blbj1cXFwiJGZpcnN0XFxcIiBjbGFzcz1cXFwicGFuZWwgcGFuZWwtZGVmYXVsdCBmb3JtLWJ1aWxkZXItcGFuZWwgc3ViZ3JvdXAtYWNjb3JkaW9uXFxcIj5cXHJcXG4gICAgICAgICAgICA8ZGl2IG5nLXJlcGVhdD1cXFwiY29tcG9uZW50IGluIGZvcm1Db21wb25lbnRzQnlHcm91cFtncm91cE5hbWVdW3N1Ymdyb3VwTmFtZV1cXFwiIG5nLWlmPVxcXCJjb21wb25lbnQudGl0bGVcXFwiXFxyXFxuICAgICAgICAgICAgICAgIGRuZC1kcmFnZ2FibGU9XFxcImNvbXBvbmVudC5zZXR0aW5nc1xcXCJcXHJcXG4gICAgICAgICAgICAgICAgZG5kLWRyYWdzdGFydD1cXFwiZG5kRHJhZ0lmcmFtZVdvcmthcm91bmQuaXNEcmFnZ2luZyA9IHRydWVcXFwiXFxyXFxuICAgICAgICAgICAgICAgIGRuZC1kcmFnZW5kPVxcXCJkbmREcmFnSWZyYW1lV29ya2Fyb3VuZC5pc0RyYWdnaW5nID0gZmFsc2VcXFwiXFxyXFxuICAgICAgICAgICAgICAgIGRuZC1lZmZlY3QtYWxsb3dlZD1cXFwiY29weVxcXCJcXHJcXG4gICAgICAgICAgICAgICAgY2xhc3M9XFxcImZvcm1jb21wb25lbnRjb250YWluZXJcXFwiPlxcclxcbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImJ0biBidG4tcHJpbWFyeSBidG4teHMgYnRuLWJsb2NrIGZvcm1jb21wb25lbnRcXFwiIHRpdGxlPVxcXCJ7e2NvbXBvbmVudC50aXRsZX19XFxcIiBzdHlsZT1cXFwib3ZlcmZsb3c6IGhpZGRlbjsgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgPGkgbmctaWY9XFxcImNvbXBvbmVudC5pY29uXFxcIiBjbGFzcz1cXFwie3sgY29tcG9uZW50Lmljb24gfX1cXFwiPjwvaT4ge3sgY29tcG9uZW50LnRpdGxlIH19XFxyXFxuICAgICAgICAgICAgICA8L3NwYW4+XFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPC91aWItYWNjb3JkaW9uPlxcclxcbiAgICAgICAgPGRpdiBuZy1yZXBlYXQ9XFxcImNvbXBvbmVudCBpbiBmb3JtQ29tcG9uZW50c0J5R3JvdXBbZ3JvdXBOYW1lXVxcXCIgbmctaWY9XFxcIiFncm91cC5zdWJncm91cCAmJiBjb21wb25lbnQudGl0bGVcXFwiXFxyXFxuICAgICAgICAgICAgZG5kLWRyYWdnYWJsZT1cXFwiY29tcG9uZW50LnNldHRpbmdzXFxcIlxcclxcbiAgICAgICAgICAgIGRuZC1kcmFnc3RhcnQ9XFxcImRuZERyYWdJZnJhbWVXb3JrYXJvdW5kLmlzRHJhZ2dpbmcgPSB0cnVlXFxcIlxcclxcbiAgICAgICAgICAgIGRuZC1kcmFnZW5kPVxcXCJkbmREcmFnSWZyYW1lV29ya2Fyb3VuZC5pc0RyYWdnaW5nID0gZmFsc2VcXFwiXFxyXFxuICAgICAgICAgICAgZG5kLWVmZmVjdC1hbGxvd2VkPVxcXCJjb3B5XFxcIlxcclxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJmb3JtY29tcG9uZW50Y29udGFpbmVyXFxcIj5cXHJcXG4gICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImJ0biBidG4tcHJpbWFyeSBidG4teHMgYnRuLWJsb2NrIGZvcm1jb21wb25lbnRcXFwiIHRpdGxlPVxcXCJ7e2NvbXBvbmVudC50aXRsZX19XFxcIiBzdHlsZT1cXFwib3ZlcmZsb3c6IGhpZGRlbjsgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XFxcIj5cXHJcXG4gICAgICAgICAgICA8aSBuZy1pZj1cXFwiY29tcG9uZW50Lmljb25cXFwiIGNsYXNzPVxcXCJ7eyBjb21wb25lbnQuaWNvbiB9fVxcXCI+PC9pPiB7eyBjb21wb25lbnQudGl0bGUgfX1cXHJcXG4gICAgICAgICAgPC9zcGFuPlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgPC9kaXY+XFxyXFxuICAgIDwvdWliLWFjY29yZGlvbj5cXHJcXG4gICAgPHVpYi1hY2NvcmRpb24gY2xvc2Utb3RoZXJzPVxcXCJ0cnVlXFxcIiBuZy1pZj1cXFwiZm9ybS5kaXNwbGF5ID09PSAncGRmJ1xcXCI+XFxyXFxuICAgICAgPGRpdiB1aWItYWNjb3JkaW9uLWdyb3VwIGhlYWRpbmc9XFxcIlBERiBGaWVsZHNcXFwiIGlzLW9wZW49XFxcInRydWVcXFwiIGNsYXNzPVxcXCJwYW5lbCBwYW5lbC1kZWZhdWx0IGZvcm0tYnVpbGRlci1wYW5lbFxcXCI+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtY29tcG9uZW50Y29udGFpbmVyXFxcIiBuZy1yZXBlYXQ9XFxcInBkZnR5cGUgaW4gcGRmdHlwZXNcXFwiPlxcclxcbiAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiYnRuIGJ0bi1wcmltYXJ5IGJ0bi14cyBidG4tYmxvY2sgZm9ybWNvbXBvbmVudFxcXCIgdGl0bGU9XFxcInt7IHBkZnR5cGUudGl0bGUgfX1cXFwiIHN0eWxlPVxcXCJvdmVyZmxvdzogaGlkZGVuOyB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcXFwiIGZvcm0tYnVpbGRlci1kcmFnZ2FibGU9XFxcInBkZnR5cGVcXFwiPlxcclxcbiAgICAgICAgICAgIDxpIG5nLWlmPVxcXCJwZGZ0eXBlLmljb25cXFwiIGNsYXNzPVxcXCJ7eyBwZGZ0eXBlLmljb24gfX1cXFwiPjwvaT4ge3sgcGRmdHlwZS50aXRsZSB9fVxcclxcbiAgICAgICAgICA8L3NwYW4+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICA8L2Rpdj5cXHJcXG4gICAgPC91aWItYWNjb3JkaW9uPlxcclxcbiAgPC9kaXY+XFxyXFxuICA8ZGl2IGNsYXNzPVxcXCJjb2wteHMtOCBjb2wtc20tOSBjb2wtbWQtMTAgZm9ybWFyZWFcXFwiIG5nLWlmPVxcXCJmb3JtICYmIGZvcm0uZGlzcGxheVxcXCI+XFxyXFxuICAgIDxvbCBjbGFzcz1cXFwiYnJlYWRjcnVtYlxcXCIgbmctaWY9XFxcImZvcm0uZGlzcGxheSA9PT0gJ3dpemFyZCdcXFwiPlxcclxcbiAgICAgIDxsaSBuZy1yZXBlYXQ9XFxcInRpdGxlIGluIHBhZ2VzKCkgdHJhY2sgYnkgJGluZGV4XFxcIj48YSBjbGFzcz1cXFwibGFiZWxcXFwiIHN0eWxlPVxcXCJmb250LXNpemU6MWVtO1xcXCIgbmctY2xhc3M9XFxcInsnbGFiZWwtaW5mbyc6ICgkaW5kZXggPT09IGdldFBhZ2UoKSksICdsYWJlbC1wcmltYXJ5JzogKCRpbmRleCAhPT0gZ2V0UGFnZSgpKX1cXFwiIG5nLWNsaWNrPVxcXCJzaG93UGFnZSgkaW5kZXgpXFxcIj57eyB0aXRsZSB9fTwvYT48L2xpPlxcclxcbiAgICAgIDxsaT48YSBjbGFzcz1cXFwibGFiZWwgbGFiZWwtc3VjY2Vzc1xcXCIgc3R5bGU9XFxcImZvbnQtc2l6ZToxZW07XFxcIiBuZy1jbGljaz1cXFwibmV3UGFnZSgpXFxcIiBkYXRhLXRvZ2dsZT1cXFwidG9vbHRpcFxcXCIgdGl0bGU9XFxcIkNyZWF0ZSBQYWdlXFxcIj48c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1wbHVzXFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+PC9zcGFuPiBwYWdlPC9hPjwvbGk+XFxyXFxuICAgIDwvb2w+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImRyb3B6b25lXFxcIj5cXHJcXG4gICAgICA8ZGl2IG5nLWlmPVxcXCJmb3JtLmRpc3BsYXkgPT09ICdwZGYnXFxcIiBuZy1jb250cm9sbGVyPVxcXCJmb3JtQnVpbGRlckRuZFxcXCI+XFxyXFxuICAgICAgICA8ZGl2IGZvcm0tYnVpbGRlci1kcm9wcGFibGUgc3R5bGU9XFxcIndpZHRoOjEwMCU7aGVpZ2h0OjIwMDBweDtwb3NpdGlvbjphYnNvbHV0ZTtcXFwiIGlkPVxcXCJmYi1kcm9wLXpvbmVcXFwiPjwvZGl2PlxcclxcbiAgICAgICAgPGZvcm1pbyBmb3JtPVxcXCJmb3JtXFxcIiBuZy1pbml0PVxcXCJmb3JtLmJ1aWxkZXIgPSB0cnVlO1xcXCI+PC9mb3JtaW8+XFxyXFxuICAgICAgPC9kaXY+XFxyXFxuICAgICAgPGZvcm0tYnVpbGRlci1saXN0IG5nLWlmPVxcXCJmb3JtLmRpc3BsYXkgIT09ICdwZGYnXFxcIiBjb21wb25lbnQ9XFxcImZvcm1cXFwiIGZvcm09XFxcImZvcm1cXFwiIGZvcm1pbz1cXFwiOjpmb3JtaW9cXFwiIGhpZGUtZG5kLWJveC1jb3VudD1cXFwiaGlkZUNvdW50XFxcIiByb290LWxpc3Q9XFxcInRydWVcXFwiIGNsYXNzPVxcXCJyb290bGlzdFxcXCIgb3B0aW9ucz1cXFwib3B0aW9uc1xcXCI+PC9mb3JtLWJ1aWxkZXItbGlzdD5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICA8L2Rpdj5cXHJcXG48L2Rpdj5cXHJcXG5cIlxyXG4gICAgKTtcclxuXHJcbiAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9mb3JtYnVpbGRlci9kYXRhZ3JpZC5odG1sJyxcclxuICAgICAgXCI8ZGl2IGNsYXNzPVxcXCJkYXRhZ3JpZC1kbmQgZHJvcHpvbmVcXFwiIG5nLWNvbnRyb2xsZXI9XFxcImZvcm1CdWlsZGVyRG5kXFxcIj5cXHJcXG4gIDxsYWJlbCBuZy1pZj1cXFwiY29tcG9uZW50LmxhYmVsXFxcIiBjbGFzcz1cXFwiY29udHJvbC1sYWJlbFxcXCI+e3sgY29tcG9uZW50LmxhYmVsIH19PC9sYWJlbD5cXHJcXG4gIDx0YWJsZSBjbGFzcz1cXFwidGFibGUgZGF0YWdyaWQtdGFibGVcXFwiIG5nLWNsYXNzPVxcXCJ7J3RhYmxlLXN0cmlwZWQnOiBjb21wb25lbnQuc3RyaXBlZCwgJ3RhYmxlLWJvcmRlcmVkJzogY29tcG9uZW50LmJvcmRlcmVkLCAndGFibGUtaG92ZXInOiBjb21wb25lbnQuaG92ZXIsICd0YWJsZS1jb25kZW5zZWQnOiBjb21wb25lbnQuY29uZGVuc2VkfVxcXCI+XFxyXFxuICAgIDx0cj5cXHJcXG4gICAgICA8dGggc3R5bGU9XFxcInBhZGRpbmc6MzBweCAwIDEwcHggMFxcXCIgbmctcmVwZWF0PVxcXCJjb21wb25lbnQgaW4gY29tcG9uZW50LmNvbXBvbmVudHNcXFwiIG5nLWNsYXNzPVxcXCJ7J2ZpZWxkLXJlcXVpcmVkJzogY29tcG9uZW50LnZhbGlkYXRlLnJlcXVpcmVkfVxcXCI+XFxyXFxuICAgICAgICB7eyAoY29tcG9uZW50LmxhYmVsIHx8ICcnKSB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXIgfX1cXHJcXG4gICAgICAgIDxkaXYgbmctaWY9XFxcImRuZERyYWdJZnJhbWVXb3JrYXJvdW5kLmlzRHJhZ2dpbmcgJiYgIWZvcm1Db21wb25lbnQubm9EbmRPdmVybGF5XFxcIiBjbGFzcz1cXFwiZG5kT3ZlcmxheVxcXCI+PC9kaXY+XFxyXFxuICAgICAgPC90aD5cXHJcXG4gICAgPC90cj5cXHJcXG4gICAgPHRyXFxyXFxuICAgICAgY2xhc3M9XFxcImNvbXBvbmVudC1saXN0XFxcIlxcclxcbiAgICAgIGRuZC1saXN0PVxcXCJjb21wb25lbnQuY29tcG9uZW50c1xcXCJcXHJcXG4gICAgICBkbmQtZHJvcD1cXFwiYWRkQ29tcG9uZW50KGl0ZW0sIGluZGV4KVxcXCJcXHJcXG4gICAgPlxcclxcbiAgICAgIDx0ZFxcclxcbiAgICAgICAgbmctcmVwZWF0PVxcXCJjb21wb25lbnQgaW4gY29tcG9uZW50LmNvbXBvbmVudHNcXFwiXFxyXFxuICAgICAgICBuZy1pbml0PVxcXCJoaWRlTW92ZUJ1dHRvbiA9IHRydWU7IGNvbXBvbmVudC5oaWRlTGFiZWwgPSB0cnVlXFxcIlxcclxcbiAgICAgICAgZG5kLWRyYWdnYWJsZT1cXFwiY29tcG9uZW50XFxcIlxcclxcbiAgICAgICAgZG5kLWVmZmVjdC1hbGxvd2VkPVxcXCJtb3ZlXFxcIlxcclxcbiAgICAgICAgZG5kLWRyYWdzdGFydD1cXFwiZG5kRHJhZ0lmcmFtZVdvcmthcm91bmQuaXNEcmFnZ2luZyA9IHRydWVcXFwiXFxyXFxuICAgICAgICBkbmQtZHJhZ2VuZD1cXFwiZG5kRHJhZ0lmcmFtZVdvcmthcm91bmQuaXNEcmFnZ2luZyA9IGZhbHNlXFxcIlxcclxcbiAgICAgICAgZG5kLW1vdmVkPVxcXCJyZW1vdmVDb21wb25lbnQoY29tcG9uZW50LCBmYWxzZSlcXFwiXFxyXFxuICAgICAgPlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29tcG9uZW50LWZvcm0tZ3JvdXAgY29tcG9uZW50LXR5cGUte3sgY29tcG9uZW50LnR5cGUgfX0gZm9ybS1idWlsZGVyLWNvbXBvbmVudFxcXCI+XFxyXFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImhhcy1mZWVkYmFjayBmb3JtLWZpZWxkLXR5cGUte3sgY29tcG9uZW50LnR5cGUgfX0ge3tjb21wb25lbnQuY3VzdG9tQ2xhc3N9fVxcXCIgaWQ9XFxcImZvcm0tZ3JvdXAte3sgY29tcG9uZW50LmtleSB9fVxcXCIgc3R5bGU9XFxcInBvc2l0aW9uOmluaGVyaXRcXFwiIG5nLXN0eWxlPVxcXCJjb21wb25lbnQuc3R5bGVcXFwiPlxcclxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImlucHV0LWdyb3VwXFxcIj5cXHJcXG4gICAgICAgICAgICAgIDxmb3JtLWJ1aWxkZXItY29tcG9uZW50PjwvZm9ybS1idWlsZGVyLWNvbXBvbmVudD5cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICA8L3RkPlxcclxcbiAgICAgIDx0ZCBuZy1pZj1cXFwiY29tcG9uZW50LmNvbXBvbmVudHMubGVuZ3RoID09PSAwXFxcIj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImFsZXJ0IGFsZXJ0LWluZm9cXFwiIHJvbGU9XFxcImFsZXJ0XFxcIj5cXHJcXG4gICAgICAgICAgRGF0YWdyaWQgQ29tcG9uZW50c1xcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgPC90ZD5cXHJcXG4gICAgPC90cj5cXHJcXG4gIDwvdGFibGU+XFxyXFxuICA8ZGl2IHN0eWxlPVxcXCJjbGVhcjpib3RoO1xcXCI+PC9kaXY+XFxyXFxuPC9kaXY+XFxyXFxuXCJcclxuICAgICk7XHJcblxyXG4gICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9jb25maXJtLXJlbW92ZS5odG1sJyxcclxuICAgICAgXCI8Zm9ybSBpZD1cXFwiY29uZmlybS1yZW1vdmUtZGlhbG9nXFxcIj5cXHJcXG4gIDxwPlJlbW92aW5nIHRoaXMgY29tcG9uZW50IHdpbGwgYWxzbyA8c3Ryb25nPnJlbW92ZSBhbGwgb2YgaXRzIGNoaWxkcmVuPC9zdHJvbmc+ISBBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZG8gdGhpcz88L3A+XFxyXFxuICA8ZGl2PlxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIj5cXHJcXG4gICAgICA8YnV0dG9uIHR5cGU9XFxcInN1Ym1pdFxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGFuZ2VyIHB1bGwtcmlnaHRcXFwiIG5nLWNsaWNrPVxcXCJjbG9zZVRoaXNEaWFsb2codHJ1ZSlcXFwiPlJlbW92ZTwvYnV0dG9uPiZuYnNwO1xcclxcbiAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IHB1bGwtcmlnaHRcXFwiIHN0eWxlPVxcXCJtYXJnaW4tcmlnaHQ6IDVweDtcXFwiIG5nLWNsaWNrPVxcXCJjbG9zZVRoaXNEaWFsb2coZmFsc2UpXFxcIj5DYW5jZWw8L2J1dHRvbj4mbmJzcDtcXHJcXG4gICAgPC9kaXY+XFxyXFxuICA8L2Rpdj5cXHJcXG48L2Zvcm0+XFxyXFxuXCJcclxuICAgICk7XHJcbiAgfVxyXG5dKTtcclxuXHJcbnJlcXVpcmUoJy4vY29tcG9uZW50cycpO1xyXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9qc29uTG9naWNKcyA9IHJlcXVpcmUoJ2pzb24tbG9naWMtanMnKTtcblxudmFyIF9qc29uTG9naWNKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9qc29uTG9naWNKcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBfZ2V0ID0gcmVxdWlyZSgnbG9kYXNoL2dldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLyoqXG4gICAqIERldGVybWluZSBpZiBhIGNvbXBvbmVudCBpcyBhIGxheW91dCBjb21wb25lbnQgb3Igbm90LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29tcG9uZW50XG4gICAqICAgVGhlIGNvbXBvbmVudCB0byBjaGVjay5cbiAgICpcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqICAgV2hldGhlciBvciBub3QgdGhlIGNvbXBvbmVudCBpcyBhIGxheW91dCBjb21wb25lbnQuXG4gICAqL1xuICBpc0xheW91dENvbXBvbmVudDogZnVuY3Rpb24gaXNMYXlvdXRDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudC5jb2x1bW5zICYmIEFycmF5LmlzQXJyYXkoY29tcG9uZW50LmNvbHVtbnMpIHx8IGNvbXBvbmVudC5yb3dzICYmIEFycmF5LmlzQXJyYXkoY29tcG9uZW50LnJvd3MpIHx8IGNvbXBvbmVudC5jb21wb25lbnRzICYmIEFycmF5LmlzQXJyYXkoY29tcG9uZW50LmNvbXBvbmVudHMpID8gdHJ1ZSA6IGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJdGVyYXRlIHRocm91Z2ggZWFjaCBjb21wb25lbnQgd2l0aGluIGEgZm9ybS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbXBvbmVudHNcbiAgICogICBUaGUgY29tcG9uZW50cyB0byBpdGVyYXRlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKiAgIFRoZSBpdGVyYXRpb24gZnVuY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBpbmNsdWRlQWxsXG4gICAqICAgV2hldGhlciBvciBub3QgdG8gaW5jbHVkZSBsYXlvdXQgY29tcG9uZW50cy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgICogICBUaGUgY3VycmVudCBkYXRhIHBhdGggb2YgdGhlIGVsZW1lbnQuIEV4YW1wbGU6IGRhdGEudXNlci5maXJzdE5hbWVcbiAgICovXG4gIGVhY2hDb21wb25lbnQ6IGZ1bmN0aW9uIGVhY2hDb21wb25lbnQoY29tcG9uZW50cywgZm4sIGluY2x1ZGVBbGwsIHBhdGgpIHtcbiAgICBpZiAoIWNvbXBvbmVudHMpIHJldHVybjtcbiAgICBwYXRoID0gcGF0aCB8fCAnJztcbiAgICBjb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgdmFyIGhhc0NvbHVtbnMgPSBjb21wb25lbnQuY29sdW1ucyAmJiBBcnJheS5pc0FycmF5KGNvbXBvbmVudC5jb2x1bW5zKTtcbiAgICAgIHZhciBoYXNSb3dzID0gY29tcG9uZW50LnJvd3MgJiYgQXJyYXkuaXNBcnJheShjb21wb25lbnQucm93cyk7XG4gICAgICB2YXIgaGFzQ29tcHMgPSBjb21wb25lbnQuY29tcG9uZW50cyAmJiBBcnJheS5pc0FycmF5KGNvbXBvbmVudC5jb21wb25lbnRzKTtcbiAgICAgIHZhciBub1JlY3Vyc2UgPSBmYWxzZTtcbiAgICAgIHZhciBuZXdQYXRoID0gY29tcG9uZW50LmtleSA/IHBhdGggPyBwYXRoICsgJy4nICsgY29tcG9uZW50LmtleSA6IGNvbXBvbmVudC5rZXkgOiAnJztcblxuICAgICAgaWYgKGluY2x1ZGVBbGwgfHwgY29tcG9uZW50LnRyZWUgfHwgIWhhc0NvbHVtbnMgJiYgIWhhc1Jvd3MgJiYgIWhhc0NvbXBzKSB7XG4gICAgICAgIG5vUmVjdXJzZSA9IGZuKGNvbXBvbmVudCwgbmV3UGF0aCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdWJQYXRoID0gZnVuY3Rpb24gc3ViUGF0aCgpIHtcbiAgICAgICAgaWYgKGNvbXBvbmVudC5rZXkgJiYgKGNvbXBvbmVudC50eXBlID09PSAnZGF0YWdyaWQnIHx8IGNvbXBvbmVudC50eXBlID09PSAnY29udGFpbmVyJykpIHtcbiAgICAgICAgICByZXR1cm4gbmV3UGF0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH07XG5cbiAgICAgIGlmICghbm9SZWN1cnNlKSB7XG4gICAgICAgIGlmIChoYXNDb2x1bW5zKSB7XG4gICAgICAgICAgY29tcG9uZW50LmNvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgICAgICBlYWNoQ29tcG9uZW50KGNvbHVtbi5jb21wb25lbnRzLCBmbiwgaW5jbHVkZUFsbCwgc3ViUGF0aCgpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChoYXNSb3dzKSB7XG4gICAgICAgICAgW10uY29uY2F0LmFwcGx5KFtdLCBjb21wb25lbnQucm93cykuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICBlYWNoQ29tcG9uZW50KHJvdy5jb21wb25lbnRzLCBmbiwgaW5jbHVkZUFsbCwgc3ViUGF0aCgpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChoYXNDb21wcykge1xuICAgICAgICAgIGVhY2hDb21wb25lbnQoY29tcG9uZW50LmNvbXBvbmVudHMsIGZuLCBpbmNsdWRlQWxsLCBzdWJQYXRoKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBhIGNvbXBvbmVudCBieSBpdHMga2V5XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb21wb25lbnRzXG4gICAqICAgVGhlIGNvbXBvbmVudHMgdG8gaXRlcmF0ZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKiAgIFRoZSBrZXkgb2YgdGhlIGNvbXBvbmVudCB0byBnZXQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqICAgVGhlIGNvbXBvbmVudCB0aGF0IG1hdGNoZXMgdGhlIGdpdmVuIGtleSwgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZC5cbiAgICovXG4gIGdldENvbXBvbmVudDogZnVuY3Rpb24gZ2V0Q29tcG9uZW50KGNvbXBvbmVudHMsIGtleSkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgbW9kdWxlLmV4cG9ydHMuZWFjaENvbXBvbmVudChjb21wb25lbnRzLCBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICBpZiAoY29tcG9uZW50LmtleSA9PT0ga2V5KSB7XG4gICAgICAgIHJlc3VsdCA9IGNvbXBvbmVudDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBGbGF0dGVuIHRoZSBmb3JtIGNvbXBvbmVudHMgZm9yIGRhdGEgbWFuaXB1bGF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29tcG9uZW50c1xuICAgKiAgIFRoZSBjb21wb25lbnRzIHRvIGl0ZXJhdGUuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5jbHVkZUFsbFxuICAgKiAgIFdoZXRoZXIgb3Igbm90IHRvIGluY2x1ZGUgbGF5b3V0IGNvbXBvbmVudHMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqICAgVGhlIGZsYXR0ZW5lZCBjb21wb25lbnRzIG1hcC5cbiAgICovXG4gIGZsYXR0ZW5Db21wb25lbnRzOiBmdW5jdGlvbiBmbGF0dGVuQ29tcG9uZW50cyhjb21wb25lbnRzLCBpbmNsdWRlQWxsKSB7XG4gICAgdmFyIGZsYXR0ZW5lZCA9IHt9O1xuICAgIG1vZHVsZS5leHBvcnRzLmVhY2hDb21wb25lbnQoY29tcG9uZW50cywgZnVuY3Rpb24gKGNvbXBvbmVudCwgcGF0aCkge1xuICAgICAgZmxhdHRlbmVkW3BhdGhdID0gY29tcG9uZW50O1xuICAgIH0sIGluY2x1ZGVBbGwpO1xuICAgIHJldHVybiBmbGF0dGVuZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgaWYgdGhpcyBjb21wb25lbnQgaGFzIGEgY29uZGl0aW9uYWwgc3RhdGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0gY29tcG9uZW50IC0gVGhlIGNvbXBvbmVudCBKU09OIHNjaGVtYS5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59IC0gVFJVRSAtIFRoaXMgY29tcG9uZW50IGhhcyBhIGNvbmRpdGlvbmFsLCBGQUxTRSAtIE5vIGNvbmRpdGlvbmFsIHByb3ZpZGVkLlxuICAgKi9cbiAgaGFzQ29uZGl0aW9uOiBmdW5jdGlvbiBoYXNDb25kaXRpb24oY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudC5oYXNPd25Qcm9wZXJ0eSgnY3VzdG9tQ29uZGl0aW9uYWwnKSAmJiBjb21wb25lbnQuY3VzdG9tQ29uZGl0aW9uYWwgfHwgY29tcG9uZW50Lmhhc093blByb3BlcnR5KCdjb25kaXRpb25hbCcpICYmIGNvbXBvbmVudC5jb25kaXRpb25hbCAmJiBjb21wb25lbnQuY29uZGl0aW9uYWwud2hlbiB8fCBjb21wb25lbnQuaGFzT3duUHJvcGVydHkoJ2NvbmRpdGlvbmFsJykgJiYgY29tcG9uZW50LmNvbmRpdGlvbmFsICYmIGNvbXBvbmVudC5jb25kaXRpb25hbC5qc29uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3MgdGhlIGNvbmRpdGlvbnMgZm9yIGEgcHJvdmlkZWQgY29tcG9uZW50IGFuZCBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0gY29tcG9uZW50XG4gICAqICAgVGhlIGNvbXBvbmVudCB0byBjaGVjayBmb3IgdGhlIGNvbmRpdGlvbi5cbiAgICogQHBhcmFtIHJvd1xuICAgKiAgIFRoZSBkYXRhIHdpdGhpbiBhIHJvd1xuICAgKiBAcGFyYW0gZGF0YVxuICAgKiAgIFRoZSBmdWxsIHN1Ym1pc3Npb24gZGF0YS5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBjaGVja0NvbmRpdGlvbjogZnVuY3Rpb24gY2hlY2tDb25kaXRpb24oY29tcG9uZW50LCByb3csIGRhdGEpIHtcbiAgICBpZiAoY29tcG9uZW50Lmhhc093blByb3BlcnR5KCdjdXN0b21Db25kaXRpb25hbCcpICYmIGNvbXBvbmVudC5jdXN0b21Db25kaXRpb25hbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHNjcmlwdCA9ICcoZnVuY3Rpb24oKSB7IHZhciBzaG93ID0gdHJ1ZTsnO1xuICAgICAgICBzY3JpcHQgKz0gY29tcG9uZW50LmN1c3RvbUNvbmRpdGlvbmFsLnRvU3RyaW5nKCk7XG4gICAgICAgIHNjcmlwdCArPSAnOyByZXR1cm4gc2hvdzsgfSkoKSc7XG4gICAgICAgIHZhciByZXN1bHQgPSBldmFsKHNjcmlwdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQudG9TdHJpbmcoKSA9PT0gJ3RydWUnO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0FuIGVycm9yIG9jY3VycmVkIGluIGEgY3VzdG9tIGNvbmRpdGlvbmFsIHN0YXRlbWVudCBmb3IgY29tcG9uZW50ICcgKyBjb21wb25lbnQua2V5LCBlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb21wb25lbnQuaGFzT3duUHJvcGVydHkoJ2NvbmRpdGlvbmFsJykgJiYgY29tcG9uZW50LmNvbmRpdGlvbmFsICYmIGNvbXBvbmVudC5jb25kaXRpb25hbC53aGVuKSB7XG4gICAgICB2YXIgY29uZCA9IGNvbXBvbmVudC5jb25kaXRpb25hbDtcbiAgICAgIHZhciB2YWx1ZSA9IG51bGw7XG4gICAgICBpZiAocm93KSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5nZXRWYWx1ZSh7IGRhdGE6IHJvdyB9LCBjb25kLndoZW4pO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEgJiYgKHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5nZXRWYWx1ZSh7IGRhdGE6IGRhdGEgfSwgY29uZC53aGVuKTtcbiAgICAgIH1cbiAgICAgIC8vIEZPUi00MDAgLSBGaXggaXNzdWUgd2hlcmUgZmFsc2V5IHZhbHVlcyB3ZXJlIGJlaW5nIGV2YWx1YXRlZCBhcyBzaG93PXRydWVcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIFNwZWNpYWwgY2hlY2sgZm9yIHNlbGVjdGJveGVzIGNvbXBvbmVudC5cbiAgICAgIGlmICgodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSkpID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eShjb25kLmVxKSkge1xuICAgICAgICByZXR1cm4gdmFsdWVbY29uZC5lcV0udG9TdHJpbmcoKSA9PT0gY29uZC5zaG93LnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICAvLyBGT1ItMTc5IC0gQ2hlY2sgZm9yIG11bHRpcGxlIHZhbHVlcy5cbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5ICYmIHZhbHVlLmluZGV4T2YoY29uZC5lcSkgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBjb25kLnNob3cudG9TdHJpbmcoKSA9PT0gJ3RydWUnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKSA9PT0gY29uZC5lcS50b1N0cmluZygpID09PSAoY29uZC5zaG93LnRvU3RyaW5nKCkgPT09ICd0cnVlJyk7XG4gICAgfSBlbHNlIGlmIChjb21wb25lbnQuaGFzT3duUHJvcGVydHkoJ2NvbmRpdGlvbmFsJykgJiYgY29tcG9uZW50LmNvbmRpdGlvbmFsICYmIGNvbXBvbmVudC5jb25kaXRpb25hbC5qc29uKSB7XG4gICAgICByZXR1cm4gX2pzb25Mb2dpY0pzMi5kZWZhdWx0LmFwcGx5KGNvbXBvbmVudC5jb25kaXRpb25hbC5qc29uLCB7XG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIHJvdzogcm93XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IHRvIHNob3cuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgZm9yIGEgY29tcG9uZW50IGtleSwgaW4gdGhlIGdpdmVuIHN1Ym1pc3Npb24uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdWJtaXNzaW9uXG4gICAqICAgQSBzdWJtaXNzaW9uIG9iamVjdCB0byBzZWFyY2guXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICogICBBIGZvciBjb21wb25lbnRzIEFQSSBrZXkgdG8gc2VhcmNoIGZvci5cbiAgICovXG4gIGdldFZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZShzdWJtaXNzaW9uLCBrZXkpIHtcbiAgICB2YXIgZGF0YSA9IHN1Ym1pc3Npb24uZGF0YSB8fCB7fTtcblxuICAgIHZhciBzZWFyY2ggPSBmdW5jdGlvbiBzZWFyY2goZGF0YSkge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgdmFsdWU7XG5cbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKCh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZGF0YSkpID09PSAnb2JqZWN0JyAmJiAhKGRhdGEgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHJldHVybiBkYXRhW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChfdHlwZW9mKGRhdGFba2V5c1tpXV0pID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdmFsdWUgPSBzZWFyY2goZGF0YVtrZXlzW2ldXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBzZWFyY2goZGF0YSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludGVycG9sYXRlIGEgc3RyaW5nIGFuZCBhZGQgZGF0YSByZXBsYWNlbWVudHMuXG4gICAqXG4gICAqIEBwYXJhbSBzdHJpbmdcbiAgICogQHBhcmFtIGRhdGFcbiAgICogQHJldHVybnMge1hNTHxzdHJpbmd8Knx2b2lkfVxuICAgKi9cbiAgaW50ZXJwb2xhdGU6IGZ1bmN0aW9uIGludGVycG9sYXRlKHN0cmluZywgZGF0YSkge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXFx7XFx7XFxzKihbXlxcc10qKVxccypcXH1cXH0vZywgZnVuY3Rpb24gKG1hdGNoLCB0b2tlbikge1xuICAgICAgcmV0dXJuIF9nZXQoZGF0YSwgdG9rZW4pO1xuICAgIH0pO1xuICB9XG59OyIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9idWlsZC91dGlscycpO1xuIiwiLyogZ2xvYmFscyBkZWZpbmUsbW9kdWxlICovXG4vKlxuVXNpbmcgYSBVbml2ZXJzYWwgTW9kdWxlIExvYWRlciB0aGF0IHNob3VsZCBiZSBicm93c2VyLCByZXF1aXJlLCBhbmQgQU1EIGZyaWVuZGx5XG5odHRwOi8vcmljb3N0YWNydXouY29tL2NoZWF0c2hlZXRzL3VtZGpzLmh0bWxcbiovXG47KGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5qc29uTG9naWMgPSBmYWN0b3J5KCk7XG4gIH1cbn0odGhpcywgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICAvKiBnbG9iYWxzIGNvbnNvbGU6ZmFsc2UgKi9cblxuICBpZiAoICEgQXJyYXkuaXNBcnJheSkge1xuICAgIEFycmF5LmlzQXJyYXkgPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJnKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBhcnJheVVuaXF1ZShhcnJheSkge1xuICAgIHZhciBhID0gW107XG4gICAgZm9yICh2YXIgaT0wLCBsPWFycmF5Lmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICAgIGlmIChhLmluZGV4T2YoYXJyYXlbaV0pID09PSAtMSkge1xuICAgICAgICBhLnB1c2goYXJyYXlbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfVxuXG4gIHZhciBqc29uTG9naWMgPSB7fTtcbiAgdmFyIG9wZXJhdGlvbnMgPSB7XG4gICAgXCI9PVwiOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gYSA9PSBiO1xuICAgIH0sXG4gICAgXCI9PT1cIjogZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgfSxcbiAgICBcIiE9XCI6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiBhICE9IGI7XG4gICAgfSxcbiAgICBcIiE9PVwiOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gYSAhPT0gYjtcbiAgICB9LFxuICAgIFwiPlwiOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gYSA+IGI7XG4gICAgfSxcbiAgICBcIj49XCI6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiBhID49IGI7XG4gICAgfSxcbiAgICBcIjxcIjogZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAgcmV0dXJuIChjID09PSB1bmRlZmluZWQpID8gYSA8IGIgOiAoYSA8IGIpICYmIChiIDwgYyk7XG4gICAgfSxcbiAgICBcIjw9XCI6IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiAoYyA9PT0gdW5kZWZpbmVkKSA/IGEgPD0gYiA6IChhIDw9IGIpICYmIChiIDw9IGMpO1xuICAgIH0sXG4gICAgXCIhIVwiOiBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4ganNvbkxvZ2ljLnRydXRoeShhKTtcbiAgICB9LFxuICAgIFwiIVwiOiBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gIWpzb25Mb2dpYy50cnV0aHkoYSk7XG4gICAgfSxcbiAgICBcIiVcIjogZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIGEgJSBiO1xuICAgIH0sXG4gICAgXCJsb2dcIjogZnVuY3Rpb24oYSkge1xuICAgICAgY29uc29sZS5sb2coYSk7IHJldHVybiBhO1xuICAgIH0sXG4gICAgXCJpblwiOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICBpZih0eXBlb2YgYi5pbmRleE9mID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gKGIuaW5kZXhPZihhKSAhPT0gLTEpO1xuICAgIH0sXG4gICAgXCJjYXRcIjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmpvaW4uY2FsbChhcmd1bWVudHMsIFwiXCIpO1xuICAgIH0sXG4gICAgXCIrXCI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UuY2FsbChhcmd1bWVudHMsIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoYSwgMTApICsgcGFyc2VGbG9hdChiLCAxMCk7XG4gICAgICB9LCAwKTtcbiAgICB9LFxuICAgIFwiKlwiOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUucmVkdWNlLmNhbGwoYXJndW1lbnRzLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGEsIDEwKSAqIHBhcnNlRmxvYXQoYiwgMTApO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBcIi1cIjogZnVuY3Rpb24oYSwgYikge1xuICAgICAgaWYoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtYTtcbiAgICAgIH1lbHNle1xuICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICB9XG4gICAgfSxcbiAgICBcIi9cIjogZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYSAvIGI7IH0sXG4gICAgXCJtaW5cIjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIFwibWF4XCI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBcIm1lcmdlXCI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UuY2FsbChhcmd1bWVudHMsIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICAgICAgfSwgW10pO1xuICAgIH0sXG4gICAgXCJ2YXJcIjogZnVuY3Rpb24oYSwgYikge1xuICAgICAgdmFyIG5vdF9mb3VuZCA9IChiID09PSB1bmRlZmluZWQpID8gbnVsbCA6IGI7XG4gICAgICB2YXIgc3ViX3Byb3BzID0gU3RyaW5nKGEpLnNwbGl0KFwiLlwiKTtcbiAgICAgIHZhciBkYXRhID0gdGhpcztcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzdWJfcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRGVzY2VuZGluZyBpbnRvIGRhdGFcbiAgICAgICAgZGF0YSA9IGRhdGFbc3ViX3Byb3BzW2ldXTtcbiAgICAgICAgaWYoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIG5vdF9mb3VuZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcbiAgICBcIm1pc3NpbmdcIjogZnVuY3Rpb24oKSB7XG4gICAgICAvKlxuICAgICAgTWlzc2luZyBjYW4gcmVjZWl2ZSBtYW55IGtleXMgYXMgbWFueSBhcmd1bWVudHMsIGxpa2Uge1wibWlzc2luZzpbMSwyXX1cbiAgICAgIE1pc3NpbmcgY2FuIGFsc28gcmVjZWl2ZSAqb25lKiBhcmd1bWVudCB0aGF0IGlzIGFuIGFycmF5IG9mIGtleXMsXG4gICAgICB3aGljaCB0eXBpY2FsbHkgaGFwcGVucyBpZiBpdCdzIGFjdHVhbGx5IGFjdGluZyBvbiB0aGUgb3V0cHV0IG9mIGFub3RoZXIgY29tbWFuZFxuICAgICAgKGxpa2UgJ2lmJyBvciAnbWVyZ2UnKVxuICAgICAgKi9cblxuICAgICAgdmFyIG1pc3NpbmcgPSBbXTtcbiAgICAgIHZhciBrZXlzID0gQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pID8gYXJndW1lbnRzWzBdIDogYXJndW1lbnRzO1xuXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgdmFyIHZhbHVlID0ganNvbkxvZ2ljLmFwcGx5KHtcInZhclwiOiBrZXl9LCB0aGlzKTtcbiAgICAgICAgaWYodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICBtaXNzaW5nLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWlzc2luZztcbiAgICB9LFxuICAgIFwibWlzc2luZ19zb21lXCI6IGZ1bmN0aW9uKG5lZWRfY291bnQsIG9wdGlvbnMpIHtcbiAgICAgIC8vIG1pc3Npbmdfc29tZSB0YWtlcyB0d28gYXJndW1lbnRzLCBob3cgbWFueSAobWluaW11bSkgaXRlbXMgbXVzdCBiZSBwcmVzZW50LCBhbmQgYW4gYXJyYXkgb2Yga2V5cyAoanVzdCBsaWtlICdtaXNzaW5nJykgdG8gY2hlY2sgZm9yIHByZXNlbmNlLlxuICAgICAgdmFyIGFyZV9taXNzaW5nID0ganNvbkxvZ2ljLmFwcGx5KHtcIm1pc3NpbmdcIjogb3B0aW9uc30sIHRoaXMpO1xuXG4gICAgICBpZihvcHRpb25zLmxlbmd0aCAtIGFyZV9taXNzaW5nLmxlbmd0aCA+PSBuZWVkX2NvdW50KSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1lbHNle1xuICAgICAgICByZXR1cm4gYXJlX21pc3Npbmc7XG4gICAgICB9XG4gICAgfSxcbiAgICBcIm1ldGhvZFwiOiBmdW5jdGlvbihvYmosIG1ldGhvZCwgYXJncykge1xuICAgICAgcmV0dXJuIG9ialttZXRob2RdLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgfSxcblxuICB9O1xuXG4gIGpzb25Mb2dpYy5pc19sb2dpYyA9IGZ1bmN0aW9uKGxvZ2ljKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGxvZ2ljICE9PSBudWxsICYmIHR5cGVvZiBsb2dpYyA9PT0gXCJvYmplY3RcIiAmJiAhIEFycmF5LmlzQXJyYXkobG9naWMpXG4gICAgKTtcbiAgfTtcblxuICAvKlxuICBUaGlzIGhlbHBlciB3aWxsIGRlZmVyIHRvIHRoZSBKc29uTG9naWMgc3BlYyBhcyBhIHRpZS1icmVha2VyIHdoZW4gZGlmZmVyZW50IGxhbmd1YWdlIGludGVycHJldGVycyBkZWZpbmUgZGlmZmVyZW50IGJlaGF2aW9yIGZvciB0aGUgdHJ1dGhpbmVzcyBvZiBwcmltaXRpdmVzLiAgRS5nLiwgUEhQIGNvbnNpZGVycyBlbXB0eSBhcnJheXMgdG8gYmUgZmFsc3ksIGJ1dCBKYXZhc2NyaXB0IGNvbnNpZGVycyB0aGVtIHRvIGJlIHRydXRoeS4gSnNvbkxvZ2ljLCBhcyBhbiBlY29zeXN0ZW0sIG5lZWRzIG9uZSBjb25zaXN0ZW50IGFuc3dlci5cblxuICBMaXRlcmFsIHwgSlMgICAgfCAgUEhQICB8ICBKc29uTG9naWNcbiAgLS0tLS0tLS0rLS0tLS0tLSstLS0tLS0tKy0tLS0tLS0tLS0tLS0tLVxuICBbXSAgICAgIHwgdHJ1ZSAgfCBmYWxzZSB8IGZhbHNlXG4gIFwiMFwiICAgICB8IHRydWUgIHwgZmFsc2UgfCB0cnVlXG4gICovXG4gIGpzb25Mb2dpYy50cnV0aHkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gISEgdmFsdWU7XG4gIH07XG5cblxuICBqc29uTG9naWMuZ2V0X29wZXJhdG9yID0gZnVuY3Rpb24obG9naWMpe1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhsb2dpYylbMF07XG4gIH07XG5cbiAganNvbkxvZ2ljLmdldF92YWx1ZXMgPSBmdW5jdGlvbihsb2dpYyl7XG4gICAgcmV0dXJuIGxvZ2ljWyBqc29uTG9naWMuZ2V0X29wZXJhdG9yKGxvZ2ljKSBdO1xuICB9O1xuXG4gIGpzb25Mb2dpYy5hcHBseSA9IGZ1bmN0aW9uKGxvZ2ljLCBkYXRhKSB7XG4gICAgLy8gRG9lcyB0aGlzIGFycmF5IGNvbnRhaW4gbG9naWM/IE9ubHkgb25lIHdheSB0byBmaW5kIG91dC5cbiAgICBpZihBcnJheS5pc0FycmF5KGxvZ2ljKSkge1xuICAgICAgcmV0dXJuIGxvZ2ljLm1hcChmdW5jdGlvbihsKSB7XG4gICAgICAgIHJldHVybiBqc29uTG9naWMuYXBwbHkobCwgZGF0YSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gWW91J3ZlIHJlY3Vyc2VkIHRvIGEgcHJpbWl0aXZlLCBzdG9wIVxuICAgIGlmKCAhIGpzb25Mb2dpYy5pc19sb2dpYyhsb2dpYykgKSB7XG4gICAgICByZXR1cm4gbG9naWM7XG4gICAgfVxuXG4gICAgZGF0YSA9IGRhdGEgfHwge307XG5cbiAgICB2YXIgb3AgPSBqc29uTG9naWMuZ2V0X29wZXJhdG9yKGxvZ2ljKTtcbiAgICB2YXIgdmFsdWVzID0gbG9naWNbb3BdO1xuICAgIHZhciBpO1xuICAgIHZhciBjdXJyZW50O1xuXG4gICAgLy8gZWFzeSBzeW50YXggZm9yIHVuYXJ5IG9wZXJhdG9ycywgbGlrZSB7XCJ2YXJcIiA6IFwieFwifSBpbnN0ZWFkIG9mIHN0cmljdCB7XCJ2YXJcIiA6IFtcInhcIl19XG4gICAgaWYoICEgQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICB2YWx1ZXMgPSBbdmFsdWVzXTtcbiAgICB9XG5cbiAgICAvLyAnaWYnLCAnYW5kJywgYW5kICdvcicgdmlvbGF0ZSB0aGUgbm9ybWFsIHJ1bGUgb2YgZGVwdGgtZmlyc3QgY2FsY3VsYXRpbmcgY29uc2VxdWVudHMsIGxldCBlYWNoIG1hbmFnZSByZWN1cnNpb24gYXMgbmVlZGVkLlxuICAgIGlmKG9wID09PSBcImlmXCIgfHwgb3AgPT0gXCI/OlwiKSB7XG4gICAgICAvKiAnaWYnIHNob3VsZCBiZSBjYWxsZWQgd2l0aCBhIG9kZCBudW1iZXIgb2YgcGFyYW1ldGVycywgMyBvciBncmVhdGVyXG4gICAgICBUaGlzIHdvcmtzIG9uIHRoZSBwYXR0ZXJuOlxuICAgICAgaWYoIDAgKXsgMSB9ZWxzZXsgMiB9O1xuICAgICAgaWYoIDAgKXsgMSB9ZWxzZSBpZiggMiApeyAzIH1lbHNleyA0IH07XG4gICAgICBpZiggMCApeyAxIH1lbHNlIGlmKCAyICl7IDMgfWVsc2UgaWYoIDQgKXsgNSB9ZWxzZXsgNiB9O1xuXG4gICAgICBUaGUgaW1wbGVtZW50YXRpb24gaXM6XG4gICAgICBGb3IgcGFpcnMgb2YgdmFsdWVzICgwLDEgdGhlbiAyLDMgdGhlbiA0LDUgZXRjKVxuICAgICAgSWYgdGhlIGZpcnN0IGV2YWx1YXRlcyB0cnV0aHksIGV2YWx1YXRlIGFuZCByZXR1cm4gdGhlIHNlY29uZFxuICAgICAgSWYgdGhlIGZpcnN0IGV2YWx1YXRlcyBmYWxzeSwganVtcCB0byB0aGUgbmV4dCBwYWlyIChlLmcsIDAsMSB0byAyLDMpXG4gICAgICBnaXZlbiBvbmUgcGFyYW1ldGVyLCBldmFsdWF0ZSBhbmQgcmV0dXJuIGl0LiAoaXQncyBhbiBFbHNlIGFuZCBhbGwgdGhlIElmL0Vsc2VJZiB3ZXJlIGZhbHNlKVxuICAgICAgZ2l2ZW4gMCBwYXJhbWV0ZXJzLCByZXR1cm4gTlVMTCAobm90IGdyZWF0IHByYWN0aWNlLCBidXQgdGhlcmUgd2FzIG5vIEVsc2UpXG4gICAgICAqL1xuICAgICAgZm9yKGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgICAgICBpZigganNvbkxvZ2ljLnRydXRoeSgganNvbkxvZ2ljLmFwcGx5KHZhbHVlc1tpXSwgZGF0YSkgKSApIHtcbiAgICAgICAgICByZXR1cm4ganNvbkxvZ2ljLmFwcGx5KHZhbHVlc1tpKzFdLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYodmFsdWVzLmxlbmd0aCA9PT0gaSsxKSByZXR1cm4ganNvbkxvZ2ljLmFwcGx5KHZhbHVlc1tpXSwgZGF0YSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9ZWxzZSBpZihvcCA9PT0gXCJhbmRcIikgeyAvLyBSZXR1cm4gZmlyc3QgZmFsc3ksIG9yIGxhc3RcbiAgICAgIGZvcihpPTA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKz0xKSB7XG4gICAgICAgIGN1cnJlbnQgPSBqc29uTG9naWMuYXBwbHkodmFsdWVzW2ldLCBkYXRhKTtcbiAgICAgICAgaWYoICEganNvbkxvZ2ljLnRydXRoeShjdXJyZW50KSkge1xuICAgICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudDsgLy8gTGFzdFxuICAgIH1lbHNlIGlmKG9wID09PSBcIm9yXCIpIHsvLyBSZXR1cm4gZmlyc3QgdHJ1dGh5LCBvciBsYXN0XG4gICAgICBmb3IoaT0wOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSs9MSkge1xuICAgICAgICBjdXJyZW50ID0ganNvbkxvZ2ljLmFwcGx5KHZhbHVlc1tpXSwgZGF0YSk7XG4gICAgICAgIGlmKCBqc29uTG9naWMudHJ1dGh5KGN1cnJlbnQpICkge1xuICAgICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudDsgLy8gTGFzdFxuICAgIH1cblxuXG4gICAgLy8gRXZlcnlvbmUgZWxzZSBnZXRzIGltbWVkaWF0ZSBkZXB0aC1maXJzdCByZWN1cnNpb25cbiAgICB2YWx1ZXMgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuIGpzb25Mb2dpYy5hcHBseSh2YWwsIGRhdGEpO1xuICAgIH0pO1xuXG5cbiAgICAvLyBUaGUgb3BlcmF0aW9uIGlzIGNhbGxlZCB3aXRoIFwiZGF0YVwiIGJvdW5kIHRvIGl0cyBcInRoaXNcIiBhbmQgXCJ2YWx1ZXNcIiBwYXNzZWQgYXMgYXJndW1lbnRzLlxuICAgIC8vIFN0cnVjdHVyZWQgY29tbWFuZHMgbGlrZSAlIG9yID4gY2FuIG5hbWUgZm9ybWFsIGFyZ3VtZW50cyB3aGlsZSBmbGV4aWJsZSBjb21tYW5kcyAobGlrZSBtaXNzaW5nIG9yIG1lcmdlKSBjYW4gb3BlcmF0ZSBvbiB0aGUgcHNldWRvLWFycmF5IGFyZ3VtZW50c1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0Z1bmN0aW9ucy9hcmd1bWVudHNcbiAgICBpZih0eXBlb2Ygb3BlcmF0aW9uc1tvcF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIG9wZXJhdGlvbnNbb3BdLmFwcGx5KGRhdGEsIHZhbHVlcyk7XG4gICAgfWVsc2UgaWYob3AuaW5kZXhPZihcIi5cIikgPiAwKSB7IC8vIENvbnRhaW5zIGEgZG90LCBhbmQgbm90IGluIHRoZSAwdGggcG9zaXRpb25cbiAgICAgIHZhciBzdWJfb3BzID0gU3RyaW5nKG9wKS5zcGxpdChcIi5cIik7XG4gICAgICB2YXIgb3BlcmF0aW9uID0gb3BlcmF0aW9ucztcbiAgICAgIGZvcihpID0gMDsgaSA8IHN1Yl9vcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRGVzY2VuZGluZyBpbnRvIG9wZXJhdGlvbnNcbiAgICAgICAgb3BlcmF0aW9uID0gb3BlcmF0aW9uW3N1Yl9vcHNbaV1dO1xuICAgICAgICBpZihvcGVyYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBvcGVyYXRpb24gXCIgKyBvcCArXG4gICAgICAgICAgXCIgKGZhaWxlZCBhdCBcIiArIHN1Yl9vcHMuc2xpY2UoMCwgaSsxKS5qb2luKFwiLlwiKSArIFwiKVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3BlcmF0aW9uLmFwcGx5KGRhdGEsIHZhbHVlcyk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIG9wZXJhdGlvbiBcIiArIG9wICk7XG4gIH07XG5cbiAganNvbkxvZ2ljLnVzZXNfZGF0YSA9IGZ1bmN0aW9uKGxvZ2ljKSB7XG4gICAgdmFyIGNvbGxlY3Rpb24gPSBbXTtcblxuICAgIGlmKCBqc29uTG9naWMuaXNfbG9naWMobG9naWMpICkge1xuICAgICAgdmFyIG9wID0ganNvbkxvZ2ljLmdldF9vcGVyYXRvcihsb2dpYyk7XG4gICAgICB2YXIgdmFsdWVzID0gbG9naWNbb3BdO1xuXG4gICAgICBpZiggISBBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgdmFsdWVzID0gW3ZhbHVlc107XG4gICAgICB9XG5cbiAgICAgIGlmKG9wID09PSBcInZhclwiKSB7XG4gICAgICAgIC8vIFRoaXMgZG9lc24ndCBjb3ZlciB0aGUgY2FzZSB3aGVyZSB0aGUgYXJnIHRvIHZhciBpcyBpdHNlbGYgYSBydWxlLlxuICAgICAgICBjb2xsZWN0aW9uLnB1c2godmFsdWVzWzBdKTtcbiAgICAgIH1lbHNle1xuICAgICAgICAvLyBSZWN1cnNpb24hXG4gICAgICAgIHZhbHVlcy5tYXAoZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgY29sbGVjdGlvbi5wdXNoLmFwcGx5KGNvbGxlY3Rpb24sIGpzb25Mb2dpYy51c2VzX2RhdGEodmFsKSApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlVbmlxdWUoY29sbGVjdGlvbik7XG4gIH07XG5cbiAganNvbkxvZ2ljLmFkZF9vcGVyYXRpb24gPSBmdW5jdGlvbihuYW1lLCBjb2RlKSB7XG4gICAgb3BlcmF0aW9uc1tuYW1lXSA9IGNvZGU7XG4gIH07XG5cblxuICBqc29uTG9naWMucnVsZV9saWtlID0gZnVuY3Rpb24ocnVsZSwgcGF0dGVybil7XG5cdFx0Ly9jb25zb2xlLmxvZyhcIklzIFwiLiBKU09OLnN0cmluZ2lmeShydWxlKSAuIFwiIGxpa2UgXCIgLiBKU09OLnN0cmluZ2lmeShwYXR0ZXJuKSAuIFwiP1wiKTtcblx0ICBpZihwYXR0ZXJuID09PSBydWxlKXsgcmV0dXJuIHRydWU7IH0gLy9UT0RPIDogRGVlcCBvYmplY3QgZXF1aXZhbGVuY3k/XG5cdCAgaWYocGF0dGVybiA9PT0gXCJAXCIpeyByZXR1cm4gdHJ1ZTsgfSAvL1dpbGRjYXJkIVxuXHQgIGlmKHBhdHRlcm4gPT09IFwibnVtYmVyXCIpeyByZXR1cm4gKHR5cGVvZiBydWxlID09PSAnbnVtYmVyJyk7IH1cblx0ICBpZihwYXR0ZXJuID09PSBcInN0cmluZ1wiKXsgcmV0dXJuICh0eXBlb2YgcnVsZSA9PT0gJ3N0cmluZycpOyB9XG5cdCAgaWYocGF0dGVybiA9PT0gXCJhcnJheVwiKXtcbiAgICAgIC8vIWxvZ2ljIHRlc3QgbWlnaHQgYmUgc3VwZXJmbHVvdXMgaW4gSmF2YVNjcmlwdFxuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocnVsZSkgJiYgISBqc29uTG9naWMuaXNfbG9naWMocnVsZSk7XG4gICAgfVxuXG5cdCAgaWYoanNvbkxvZ2ljLmlzX2xvZ2ljKHBhdHRlcm4pKXtcblx0ICAgIGlmKGpzb25Mb2dpYy5pc19sb2dpYyhydWxlKSl7XG5cdCAgICAgIHZhciBwYXR0ZXJuX29wID0ganNvbkxvZ2ljLmdldF9vcGVyYXRvcihwYXR0ZXJuKTtcbiAgICAgICAgdmFyIHJ1bGVfb3AgPSBqc29uTG9naWMuZ2V0X29wZXJhdG9yKHJ1bGUpO1xuXG5cdCAgICAgIGlmKHBhdHRlcm5fb3AgPT09IFwiQFwiIHx8IHBhdHRlcm5fb3AgPT09IHJ1bGVfb3Ape1xuXHRcdFx0XHRcdC8vZWNobyBcIlxcbk9wZXJhdG9ycyBtYXRjaCwgZ28gZGVlcGVyXFxuXCI7XG5cdCAgICAgICAgcmV0dXJuIGpzb25Mb2dpYy5ydWxlX2xpa2UoXG5cdFx0XHRcdFx0XHRqc29uTG9naWMuZ2V0X3ZhbHVlcyhydWxlLCBmYWxzZSksXG5cdFx0XHRcdFx0XHRqc29uTG9naWMuZ2V0X3ZhbHVlcyhwYXR0ZXJuLCBmYWxzZSlcblx0XHRcdFx0XHQpO1xuXHQgICAgICB9XG5cblx0ICAgIH1cblx0ICAgIHJldHVybiBmYWxzZTsgLy9wYXR0ZXJuIGlzIGxvZ2ljLCBydWxlIGlzbid0LCBjYW4ndCBiZSBlcVxuXHQgIH1cblxuXHQgIGlmKEFycmF5LmlzQXJyYXkocGF0dGVybikpe1xuXHQgICAgaWYoQXJyYXkuaXNBcnJheShydWxlKSl7XG5cdCAgICAgIGlmKHBhdHRlcm4ubGVuZ3RoICE9PSBydWxlLmxlbmd0aCl7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHQvKlxuXHRcdFx0XHRcdE5vdGUsIGFycmF5IG9yZGVyIE1BVFRFUlMsIGJlY2F1c2Ugd2UncmUgdXNpbmcgdGhpcyBhcnJheSB0ZXN0IGxvZ2ljIHRvIGNvbnNpZGVyIGFyZ3VtZW50cywgd2hlcmUgb3JkZXIgY2FuIG1hdHRlci4gKGUuZy4sICsgaXMgY29tbXV0YXRpdmUsIGJ1dCAnLScgb3IgJ2lmJyBvciAndmFyJyBhcmUgTk9UKVxuXHRcdFx0XHQqL1xuXHQgICAgICBmb3IodmFyIGkgPSAwIDsgaSA8IHBhdHRlcm4ubGVuZ3RoIDsgaSArPSAxKXtcblx0ICAgICAgICAvL0lmIGFueSBmYWlsLCB3ZSBmYWlsXG5cdCAgICAgICAgaWYoICEganNvbkxvZ2ljLnJ1bGVfbGlrZShydWxlW2ldLCBwYXR0ZXJuW2ldKSl7IHJldHVybiBmYWxzZTsgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB0cnVlOyAvL0lmIHRoZXkgKmFsbCogcGFzc2VkLCB3ZSBwYXNzXG5cdCAgICB9ZWxzZXtcblx0ICAgICAgcmV0dXJuIGZhbHNlOyAvL1BhdHRlcm4gaXMgYXJyYXksIHJ1bGUgaXNuJ3Rcblx0ICAgIH1cblxuXHQgIH1cblxuXHRcdC8vTm90IGxvZ2ljLCBub3QgYXJyYXksIG5vdCBhID09PSBtYXRjaCBmb3IgcnVsZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblxuXG4gIHJldHVybiBqc29uTG9naWM7XG59KSk7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFWaWV3O1xuIiwidmFyIGhhc2hDbGVhciA9IHJlcXVpcmUoJy4vX2hhc2hDbGVhcicpLFxuICAgIGhhc2hEZWxldGUgPSByZXF1aXJlKCcuL19oYXNoRGVsZXRlJyksXG4gICAgaGFzaEdldCA9IHJlcXVpcmUoJy4vX2hhc2hHZXQnKSxcbiAgICBoYXNoSGFzID0gcmVxdWlyZSgnLi9faGFzaEhhcycpLFxuICAgIGhhc2hTZXQgPSByZXF1aXJlKCcuL19oYXNoU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2g7XG4iLCJ2YXIgbGlzdENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVDbGVhcicpLFxuICAgIGxpc3RDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZURlbGV0ZScpLFxuICAgIGxpc3RDYWNoZUdldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUdldCcpLFxuICAgIGxpc3RDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUhhcycpLFxuICAgIGxpc3RDYWNoZVNldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTGlzdENhY2hlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcbiIsInZhciBtYXBDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVDbGVhcicpLFxuICAgIG1hcENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVEZWxldGUnKSxcbiAgICBtYXBDYWNoZUdldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlR2V0JyksXG4gICAgbWFwQ2FjaGVIYXMgPSByZXF1aXJlKCcuL19tYXBDYWNoZUhhcycpLFxuICAgIG1hcENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2FjaGU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldDtcbiIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyksXG4gICAgc2V0Q2FjaGVBZGQgPSByZXF1aXJlKCcuL19zZXRDYWNoZUFkZCcpLFxuICAgIHNldENhY2hlSGFzID0gcmVxdWlyZSgnLi9fc2V0Q2FjaGVIYXMnKTtcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldENhY2hlO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIHN0YWNrQ2xlYXIgPSByZXF1aXJlKCcuL19zdGFja0NsZWFyJyksXG4gICAgc3RhY2tEZWxldGUgPSByZXF1aXJlKCcuL19zdGFja0RlbGV0ZScpLFxuICAgIHN0YWNrR2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tHZXQnKSxcbiAgICBzdGFja0hhcyA9IHJlcXVpcmUoJy4vX3N0YWNrSGFzJyksXG4gICAgc3RhY2tTZXQgPSByZXF1aXJlKCcuL19zdGFja1NldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhY2s7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYWtNYXA7XG4iLCIvKipcbiAqIEFkZHMgdGhlIGtleS12YWx1ZSBgcGFpcmAgdG8gYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSBwYWlyIFRoZSBrZXktdmFsdWUgcGFpciB0byBhZGQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBtYXBgLlxuICovXG5mdW5jdGlvbiBhZGRNYXBFbnRyeShtYXAsIHBhaXIpIHtcbiAgLy8gRG9uJ3QgcmV0dXJuIGBtYXAuc2V0YCBiZWNhdXNlIGl0J3Mgbm90IGNoYWluYWJsZSBpbiBJRSAxMS5cbiAgbWFwLnNldChwYWlyWzBdLCBwYWlyWzFdKTtcbiAgcmV0dXJuIG1hcDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhZGRNYXBFbnRyeTtcbiIsIi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIGBzZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYWRkLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgc2V0YC5cbiAqL1xuZnVuY3Rpb24gYWRkU2V0RW50cnkoc2V0LCB2YWx1ZSkge1xuICAvLyBEb24ndCByZXR1cm4gYHNldC5hZGRgIGJlY2F1c2UgaXQncyBub3QgY2hhaW5hYmxlIGluIElFIDExLlxuICBzZXQuYWRkKHZhbHVlKTtcbiAgcmV0dXJuIHNldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhZGRTZXRFbnRyeTtcbiIsIi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcHBseTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlQWdncmVnYXRvcmAgZm9yIGFycmF5cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gKiBAcGFyYW0ge09iamVjdH0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgYWdncmVnYXRlZCBvYmplY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlBZ2dyZWdhdG9yKGFycmF5LCBzZXR0ZXIsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIHNldHRlcihhY2N1bXVsYXRvciwgdmFsdWUsIGl0ZXJhdGVlKHZhbHVlKSwgYXJyYXkpO1xuICB9XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUFnZ3JlZ2F0b3I7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlFYWNoO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RmlsdGVyO1xuIiwidmFyIGJhc2VUaW1lcyA9IHJlcXVpcmUoJy4vX2Jhc2VUaW1lcycpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUxpa2VLZXlzO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheU1hcDtcbiIsIi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVB1c2g7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UmVkdWNlKGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgYWNjdW11bGF0b3IgPSBhcnJheVsrK2luZGV4XTtcbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlSZWR1Y2U7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5U29tZTtcbiIsIi8qKlxuICogQ29udmVydHMgYW4gQVNDSUkgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFzY2lpVG9BcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5zcGxpdCgnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNjaWlUb0FycmF5O1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggd29yZHMgY29tcG9zZWQgb2YgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMuICovXG52YXIgcmVBc2NpaVdvcmQgPSAvW15cXHgwMC1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHg3Zl0rL2c7XG5cbi8qKlxuICogU3BsaXRzIGFuIEFTQ0lJIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAqL1xuZnVuY3Rpb24gYXNjaWlXb3JkcyhzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5tYXRjaChyZUFzY2lpV29yZCkgfHwgW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNjaWlXb3JkcztcbiIsInZhciBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFzc2lnblZhbHVlYCBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGFzc2lnblxuICogYHVuZGVmaW5lZGAgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmICgodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZXEob2JqZWN0W2tleV0sIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25NZXJnZVZhbHVlO1xuIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnblZhbHVlO1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc29jSW5kZXhPZjtcbiIsInZhciBiYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2Jhc2VFYWNoJyk7XG5cbi8qKlxuICogQWdncmVnYXRlcyBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgb24gYGFjY3VtdWxhdG9yYCB3aXRoIGtleXMgdHJhbnNmb3JtZWRcbiAqIGJ5IGBpdGVyYXRlZWAgYW5kIHZhbHVlcyBzZXQgYnkgYHNldHRlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGFnZ3JlZ2F0ZWQgb2JqZWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBZ2dyZWdhdG9yKGNvbGxlY3Rpb24sIHNldHRlciwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIHZhbHVlLCBpdGVyYXRlZSh2YWx1ZSksIGNvbGxlY3Rpb24pO1xuICB9KTtcbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBZ2dyZWdhdG9yO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnbjtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25JbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduSW47XG4iLCJ2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25WYWx1ZTtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYXJyYXlFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXlFYWNoJyksXG4gICAgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ24gPSByZXF1aXJlKCcuL19iYXNlQXNzaWduJyksXG4gICAgYmFzZUFzc2lnbkluID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnbkluJyksXG4gICAgY2xvbmVCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUJ1ZmZlcicpLFxuICAgIGNvcHlBcnJheSA9IHJlcXVpcmUoJy4vX2NvcHlBcnJheScpLFxuICAgIGNvcHlTeW1ib2xzID0gcmVxdWlyZSgnLi9fY29weVN5bWJvbHMnKSxcbiAgICBjb3B5U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fY29weVN5bWJvbHNJbicpLFxuICAgIGdldEFsbEtleXMgPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzJyksXG4gICAgZ2V0QWxsS2V5c0luID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5c0luJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaW5pdENsb25lQXJyYXkgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVBcnJheScpLFxuICAgIGluaXRDbG9uZUJ5VGFnID0gcmVxdWlyZSgnLi9faW5pdENsb25lQnlUYWcnKSxcbiAgICBpbml0Q2xvbmVPYmplY3QgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVPYmplY3QnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgQ0xPTkVfRkxBVF9GTEFHID0gMixcbiAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG52YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbmNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ10gPVxuY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPVxuY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50MzJUYWddID0gY2xvbmVhYmxlVGFnc1ttYXBUYWddID1cbmNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID0gY2xvbmVhYmxlVGFnc1tzeW1ib2xUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG5jbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCBhbmQgYF8uY2xvbmVEZWVwYCB3aGljaCB0cmFja3NcbiAqIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gRGVlcCBjbG9uZVxuICogIDIgLSBGbGF0dGVuIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gKiAgNCAtIENsb25lIHN5bWJvbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XG4gIHZhciByZXN1bHQsXG4gICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxuICAgICAgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRyxcbiAgICAgIGlzRnVsbCA9IGJpdG1hc2sgJiBDTE9ORV9TWU1CT0xTX0ZMQUc7XG5cbiAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gIH1cbiAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgaWYgKGlzQXJyKSB7XG4gICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgIGlmICghaXNEZWVwKSB7XG4gICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICB9XG4gICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgcmVzdWx0ID0gKGlzRmxhdCB8fCBpc0Z1bmMpID8ge30gOiBpbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhdFxuICAgICAgICAgID8gY29weVN5bWJvbHNJbih2YWx1ZSwgYmFzZUFzc2lnbkluKHJlc3VsdCwgdmFsdWUpKVxuICAgICAgICAgIDogY29weVN5bWJvbHModmFsdWUsIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWNsb25lYWJsZVRhZ3NbdGFnXSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGJhc2VDbG9uZSwgaXNEZWVwKTtcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQodmFsdWUpO1xuICBpZiAoc3RhY2tlZCkge1xuICAgIHJldHVybiBzdGFja2VkO1xuICB9XG4gIHN0YWNrLnNldCh2YWx1ZSwgcmVzdWx0KTtcblxuICB2YXIga2V5c0Z1bmMgPSBpc0Z1bGxcbiAgICA/IChpc0ZsYXQgPyBnZXRBbGxLZXlzSW4gOiBnZXRBbGxLZXlzKVxuICAgIDogKGlzRmxhdCA/IGtleXNJbiA6IGtleXMpO1xuXG4gIHZhciBwcm9wcyA9IGlzQXJyID8gdW5kZWZpbmVkIDoga2V5c0Z1bmModmFsdWUpO1xuICBhcnJheUVhY2gocHJvcHMgfHwgdmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGtleSA9IHN1YlZhbHVlO1xuICAgICAgc3ViVmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDbG9uZTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ3JlYXRlO1xuIiwidmFyIGJhc2VGb3JPd24gPSByZXF1aXJlKCcuL19iYXNlRm9yT3duJyksXG4gICAgY3JlYXRlQmFzZUVhY2ggPSByZXF1aXJlKCcuL19jcmVhdGVCYXNlRWFjaCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICovXG52YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRWFjaDtcbiIsInZhciBiYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2Jhc2VFYWNoJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsdGVyYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmlsdGVyO1xuIiwidmFyIGNyZWF0ZUJhc2VGb3IgPSByZXF1aXJlKCcuL19jcmVhdGVCYXNlRm9yJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yO1xuIiwidmFyIGJhc2VGb3IgPSByZXF1aXJlKCcuL19iYXNlRm9yJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvck93bjtcbiIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXQ7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldEFsbEtleXM7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgZ2V0UmF3VGFnID0gcmVxdWlyZSgnLi9fZ2V0UmF3VGFnJyksXG4gICAgb2JqZWN0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19vYmplY3RUb1N0cmluZycpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0VGFnO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUhhc0luO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNBcmd1bWVudHM7XG4iLCJ2YXIgYmFzZUlzRXF1YWxEZWVwID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWxEZWVwJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWw7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGVxdWFsQXJyYXlzID0gcmVxdWlyZSgnLi9fZXF1YWxBcnJheXMnKSxcbiAgICBlcXVhbEJ5VGFnID0gcmVxdWlyZSgnLi9fZXF1YWxCeVRhZycpLFxuICAgIGVxdWFsT2JqZWN0cyA9IHJlcXVpcmUoJy4vX2VxdWFsT2JqZWN0cycpLFxuICAgIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksXG4gICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgIG9iaklzT2JqID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNFcXVhbERlZXA7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTWF0Y2g7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTWFza2VkID0gcmVxdWlyZSgnLi9faXNNYXNrZWQnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmF0aXZlO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc1R5cGVkQXJyYXk7XG4iLCJ2YXIgYmFzZU1hdGNoZXMgPSByZXF1aXJlKCcuL19iYXNlTWF0Y2hlcycpLFxuICAgIGJhc2VNYXRjaGVzUHJvcGVydHkgPSByZXF1aXJlKCcuL19iYXNlTWF0Y2hlc1Byb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5JyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIHByb3BlcnR5ID0gcmVxdWlyZSgnLi9wcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLml0ZXJhdGVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBbdmFsdWU9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICovXG5mdW5jdGlvbiBiYXNlSXRlcmF0ZWUodmFsdWUpIHtcbiAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTYwMzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSlcbiAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXG4gICAgICA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJdGVyYXRlZTtcbiIsInZhciBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5cyA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXMnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzSW4gPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzSW4nKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICB9XG4gIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5c0luO1xuIiwidmFyIGJhc2VFYWNoID0gcmVxdWlyZSgnLi9fYmFzZUVhY2gnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXBgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWFwO1xuIiwidmFyIGJhc2VJc01hdGNoID0gcmVxdWlyZSgnLi9fYmFzZUlzTWF0Y2gnKSxcbiAgICBnZXRNYXRjaERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXRjaERhdGEnKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzO1xuIiwidmFyIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKSxcbiAgICBnZXQgPSByZXF1aXJlKCcuL2dldCcpLFxuICAgIGhhc0luID0gcmVxdWlyZSgnLi9oYXNJbicpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICBpc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19pc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hdGNoZXNQcm9wZXJ0eTtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYXNzaWduTWVyZ2VWYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnbk1lcmdlVmFsdWUnKSxcbiAgICBiYXNlRm9yID0gcmVxdWlyZSgnLi9fYmFzZUZvcicpLFxuICAgIGJhc2VNZXJnZURlZXAgPSByZXF1aXJlKCcuL19iYXNlTWVyZ2VEZWVwJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdlZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKG9iamVjdCA9PT0gc291cmNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGJhc2VGb3Ioc291cmNlLCBmdW5jdGlvbihzcmNWYWx1ZSwga2V5KSB7XG4gICAgaWYgKGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH0sIGtleXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1lcmdlO1xuIiwidmFyIGFzc2lnbk1lcmdlVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25NZXJnZVZhbHVlJyksXG4gICAgY2xvbmVCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUJ1ZmZlcicpLFxuICAgIGNsb25lVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Nsb25lVHlwZWRBcnJheScpLFxuICAgIGNvcHlBcnJheSA9IHJlcXVpcmUoJy4vX2NvcHlBcnJheScpLFxuICAgIGluaXRDbG9uZU9iamVjdCA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZU9iamVjdCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0FycmF5TGlrZU9iamVjdCA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2VPYmplY3QnKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vaXNQbGFpbk9iamVjdCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5JyksXG4gICAgdG9QbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vdG9QbGFpbk9iamVjdCcpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIG1lcmdlcyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIG1lcmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICBzcmNWYWx1ZSA9IHNvdXJjZVtrZXldLFxuICAgICAgc3RhY2tlZCA9IHN0YWNrLmdldChzcmNWYWx1ZSk7XG5cbiAgaWYgKHN0YWNrZWQpIHtcbiAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBzdGFja2VkKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgID8gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICA6IHVuZGVmaW5lZDtcblxuICB2YXIgaXNDb21tb24gPSBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gIGlmIChpc0NvbW1vbikge1xuICAgIHZhciBpc0FyciA9IGlzQXJyYXkoc3JjVmFsdWUpLFxuICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgaXNCdWZmZXIoc3JjVmFsdWUpLFxuICAgICAgICBpc1R5cGVkID0gIWlzQXJyICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTtcblxuICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgaWYgKGlzQXJyIHx8IGlzQnVmZiB8fCBpc1R5cGVkKSB7XG4gICAgICBpZiAoaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGNvcHlBcnJheShvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0J1ZmYpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZUJ1ZmZlcihzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc1R5cGVkKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVUeXBlZEFycmF5KHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBuZXdWYWx1ZSA9IFtdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICBpZiAoaXNBcmd1bWVudHMob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gdG9QbGFpbk9iamVjdChvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICghaXNPYmplY3Qob2JqVmFsdWUpIHx8IChzcmNJbmRleCAmJiBpc0Z1bmN0aW9uKG9ialZhbHVlKSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBpbml0Q2xvbmVPYmplY3Qoc3JjVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChpc0NvbW1vbikge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgbmV3VmFsdWUpO1xuICAgIG1lcmdlRnVuYyhuZXdWYWx1ZSwgc3JjVmFsdWUsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgfVxuICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1lcmdlRGVlcDtcbiIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpLFxuICAgIGJhc2VTZXQgPSByZXF1aXJlKCcuL19iYXNlU2V0JyksXG4gICAgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mICBgXy5waWNrQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0ge307XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgcGF0aCA9IHBhdGhzW2luZGV4XSxcbiAgICAgICAgdmFsdWUgPSBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG5cbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBwYXRoKSkge1xuICAgICAgYmFzZVNldChyZXN1bHQsIGNhc3RQYXRoKHBhdGgsIG9iamVjdCksIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUGlja0J5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUHJvcGVydHk7XG4iLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5RGVlcDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5T2Yob2JqZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUHJvcGVydHlPZjtcbiIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBvdmVyUmVzdCA9IHJlcXVpcmUoJy4vX292ZXJSZXN0JyksXG4gICAgc2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19zZXRUb1N0cmluZycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmVzdDtcbiIsInZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgcGF0aCBjcmVhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxLFxuICAgICAgbmVzdGVkID0gb2JqZWN0O1xuXG4gIHdoaWxlIChuZXN0ZWQgIT0gbnVsbCAmJiArK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKSxcbiAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZTtcblxuICAgIGlmIChpbmRleCAhPSBsYXN0SW5kZXgpIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IG5lc3RlZFtrZXldO1xuICAgICAgbmV3VmFsdWUgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmpWYWx1ZSwga2V5LCBuZXN0ZWQpIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBpc09iamVjdChvYmpWYWx1ZSlcbiAgICAgICAgICA/IG9ialZhbHVlXG4gICAgICAgICAgOiAoaXNJbmRleChwYXRoW2luZGV4ICsgMV0pID8gW10gOiB7fSk7XG4gICAgICB9XG4gICAgfVxuICAgIGFzc2lnblZhbHVlKG5lc3RlZCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgbmVzdGVkID0gbmVzdGVkW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2V0O1xuIiwidmFyIGNvbnN0YW50ID0gcmVxdWlyZSgnLi9jb25zdGFudCcpLFxuICAgIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fZGVmaW5lUHJvcGVydHknKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNldFRvU3RyaW5nO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zbGljZWAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2xpY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiAobGVuZ3RoICsgc3RhcnQpO1xuICB9XG4gIGVuZCA9IGVuZCA+IGxlbmd0aCA/IGxlbmd0aCA6IGVuZDtcbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuZ3RoO1xuICB9XG4gIGxlbmd0aCA9IHN0YXJ0ID4gZW5kID8gMCA6ICgoZW5kIC0gc3RhcnQpID4+PiAwKTtcbiAgc3RhcnQgPj4+PSAwO1xuXG4gIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBhcnJheVtpbmRleCArIHN0YXJ0XTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTbGljZTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRpbWVzO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRvU3RyaW5nO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmFyeTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhY2hlSGFzO1xuIiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYGlkZW50aXR5YCBpZiBpdCdzIG5vdCBhIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGNhc3QgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhc3RGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgPyB2YWx1ZSA6IGlkZW50aXR5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhc3RGdW5jdGlvbjtcbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHN0cmluZ1RvUGF0aCA9IHJlcXVpcmUoJy4vX3N0cmluZ1RvUGF0aCcpLFxuICAgIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhc3RQYXRoO1xuIiwidmFyIGJhc2VTbGljZSA9IHJlcXVpcmUoJy4vX2Jhc2VTbGljZScpO1xuXG4vKipcbiAqIENhc3RzIGBhcnJheWAgdG8gYSBzbGljZSBpZiBpdCdzIG5lZWRlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHNsaWNlLlxuICovXG5mdW5jdGlvbiBjYXN0U2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQ7XG4gIHJldHVybiAoIXN0YXJ0ICYmIGVuZCA+PSBsZW5ndGgpID8gYXJyYXkgOiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhc3RTbGljZTtcbiIsInZhciBVaW50OEFycmF5ID0gcmVxdWlyZSgnLi9fVWludDhBcnJheScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgYXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUFycmF5QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVBcnJheUJ1ZmZlcjtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICBidWZmZXIuY29weShyZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQnVmZmVyO1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBkYXRhVmlld2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhVmlldyBUaGUgZGF0YSB2aWV3IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBkYXRhIHZpZXcuXG4gKi9cbmZ1bmN0aW9uIGNsb25lRGF0YVZpZXcoZGF0YVZpZXcsIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcihkYXRhVmlldy5idWZmZXIpIDogZGF0YVZpZXcuYnVmZmVyO1xuICByZXR1cm4gbmV3IGRhdGFWaWV3LmNvbnN0cnVjdG9yKGJ1ZmZlciwgZGF0YVZpZXcuYnl0ZU9mZnNldCwgZGF0YVZpZXcuYnl0ZUxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVEYXRhVmlldztcbiIsInZhciBhZGRNYXBFbnRyeSA9IHJlcXVpcmUoJy4vX2FkZE1hcEVudHJ5JyksXG4gICAgYXJyYXlSZWR1Y2UgPSByZXF1aXJlKCcuL19hcnJheVJlZHVjZScpLFxuICAgIG1hcFRvQXJyYXkgPSByZXF1aXJlKCcuL19tYXBUb0FycmF5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfREVFUF9GTEFHID0gMTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNsb25lRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2xvbmUgdmFsdWVzLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBtYXAuXG4gKi9cbmZ1bmN0aW9uIGNsb25lTWFwKG1hcCwgaXNEZWVwLCBjbG9uZUZ1bmMpIHtcbiAgdmFyIGFycmF5ID0gaXNEZWVwID8gY2xvbmVGdW5jKG1hcFRvQXJyYXkobWFwKSwgQ0xPTkVfREVFUF9GTEFHKSA6IG1hcFRvQXJyYXkobWFwKTtcbiAgcmV0dXJuIGFycmF5UmVkdWNlKGFycmF5LCBhZGRNYXBFbnRyeSwgbmV3IG1hcC5jb25zdHJ1Y3Rvcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVNYXA7XG4iLCIvKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUZsYWdzID0gL1xcdyokLztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHJlZ2V4cGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWdleHAgVGhlIHJlZ2V4cCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCByZWdleHAuXG4gKi9cbmZ1bmN0aW9uIGNsb25lUmVnRXhwKHJlZ2V4cCkge1xuICB2YXIgcmVzdWx0ID0gbmV3IHJlZ2V4cC5jb25zdHJ1Y3RvcihyZWdleHAuc291cmNlLCByZUZsYWdzLmV4ZWMocmVnZXhwKSk7XG4gIHJlc3VsdC5sYXN0SW5kZXggPSByZWdleHAubGFzdEluZGV4O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lUmVnRXhwO1xuIiwidmFyIGFkZFNldEVudHJ5ID0gcmVxdWlyZSgnLi9fYWRkU2V0RW50cnknKSxcbiAgICBhcnJheVJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5UmVkdWNlJyksXG4gICAgc2V0VG9BcnJheSA9IHJlcXVpcmUoJy4vX3NldFRvQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgc2V0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNsb25lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2xvbmVGdW5jIFRoZSBmdW5jdGlvbiB0byBjbG9uZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHNldC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVTZXQoc2V0LCBpc0RlZXAsIGNsb25lRnVuYykge1xuICB2YXIgYXJyYXkgPSBpc0RlZXAgPyBjbG9uZUZ1bmMoc2V0VG9BcnJheShzZXQpLCBDTE9ORV9ERUVQX0ZMQUcpIDogc2V0VG9BcnJheShzZXQpO1xuICByZXR1cm4gYXJyYXlSZWR1Y2UoYXJyYXksIGFkZFNldEVudHJ5LCBuZXcgc2V0LmNvbnN0cnVjdG9yKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVNldDtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBgc3ltYm9sYCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzeW1ib2wgVGhlIHN5bWJvbCBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc3ltYm9sIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVTeW1ib2woc3ltYm9sKSB7XG4gIHJldHVybiBzeW1ib2xWYWx1ZU9mID8gT2JqZWN0KHN5bWJvbFZhbHVlT2YuY2FsbChzeW1ib2wpKSA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lU3ltYm9sO1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weUFycmF5O1xuIiwidmFyIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKTtcblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIGlmIChpc05ldykge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weU9iamVjdDtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyk7XG5cbi8qKlxuICogQ29waWVzIG93biBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5U3ltYm9scyhzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5U3ltYm9scztcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGdldFN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHNJbicpO1xuXG4vKipcbiAqIENvcGllcyBvd24gYW5kIGluaGVyaXRlZCBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5U3ltYm9sc0luKHNvdXJjZSwgb2JqZWN0KSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9sc0luKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVN5bWJvbHNJbjtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVKc0RhdGE7XG4iLCJ2YXIgYXJyYXlBZ2dyZWdhdG9yID0gcmVxdWlyZSgnLi9fYXJyYXlBZ2dyZWdhdG9yJyksXG4gICAgYmFzZUFnZ3JlZ2F0b3IgPSByZXF1aXJlKCcuL19iYXNlQWdncmVnYXRvcicpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5ncm91cEJ5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYWNjdW11bGF0b3IgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2luaXRpYWxpemVyXSBUaGUgYWNjdW11bGF0b3Igb2JqZWN0IGluaXRpYWxpemVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWdncmVnYXRvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQWdncmVnYXRvcihzZXR0ZXIsIGluaXRpYWxpemVyKSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5QWdncmVnYXRvciA6IGJhc2VBZ2dyZWdhdG9yLFxuICAgICAgICBhY2N1bXVsYXRvciA9IGluaXRpYWxpemVyID8gaW5pdGlhbGl6ZXIoKSA6IHt9O1xuXG4gICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgc2V0dGVyLCBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCBhY2N1bXVsYXRvcik7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQWdncmVnYXRvcjtcbiIsInZhciBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCcuL19pc0l0ZXJhdGVlQ2FsbCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXG4gICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgIGxlbmd0aCA9IDE7XG4gICAgfVxuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFzc2lnbmVyO1xuIiwidmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgYmFzZUVhY2hgIG9yIGBiYXNlRWFjaFJpZ2h0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VFYWNoO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUZvcjtcbiIsInZhciBjYXN0U2xpY2UgPSByZXF1aXJlKCcuL19jYXN0U2xpY2UnKSxcbiAgICBoYXNVbmljb2RlID0gcmVxdWlyZSgnLi9faGFzVW5pY29kZScpLFxuICAgIHN0cmluZ1RvQXJyYXkgPSByZXF1aXJlKCcuL19zdHJpbmdUb0FycmF5JyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ubG93ZXJGaXJzdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBgU3RyaW5nYCBjYXNlIG1ldGhvZCB0byB1c2UuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVDYXNlRmlyc3QobWV0aG9kTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcblxuICAgIHZhciBzdHJTeW1ib2xzID0gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgICA/IHN0cmluZ1RvQXJyYXkoc3RyaW5nKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgY2hyID0gc3RyU3ltYm9sc1xuICAgICAgPyBzdHJTeW1ib2xzWzBdXG4gICAgICA6IHN0cmluZy5jaGFyQXQoMCk7XG5cbiAgICB2YXIgdHJhaWxpbmcgPSBzdHJTeW1ib2xzXG4gICAgICA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAxKS5qb2luKCcnKVxuICAgICAgOiBzdHJpbmcuc2xpY2UoMSk7XG5cbiAgICByZXR1cm4gY2hyW21ldGhvZE5hbWVdKCkgKyB0cmFpbGluZztcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVDYXNlRmlyc3Q7XG4iLCJ2YXIgYXJyYXlSZWR1Y2UgPSByZXF1aXJlKCcuL19hcnJheVJlZHVjZScpLFxuICAgIGRlYnVyciA9IHJlcXVpcmUoJy4vZGVidXJyJyksXG4gICAgd29yZHMgPSByZXF1aXJlKCcuL3dvcmRzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc0Fwb3MgPSBcIlsnXFx1MjAxOV1cIjtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYXBvc3Ryb3BoZXMuICovXG52YXIgcmVBcG9zID0gUmVnRXhwKHJzQXBvcywgJ2cnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5jYW1lbENhc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY29tYmluZSBlYWNoIHdvcmQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3VuZGVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVDb21wb3VuZGVyKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICByZXR1cm4gYXJyYXlSZWR1Y2Uod29yZHMoZGVidXJyKHN0cmluZykucmVwbGFjZShyZUFwb3MsICcnKSksIGNhbGxiYWNrLCAnJyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQ29tcG91bmRlcjtcbiIsInZhciBiYXNlUHJvcGVydHlPZiA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eU9mJyk7XG5cbi8qKiBVc2VkIHRvIG1hcCBMYXRpbiBVbmljb2RlIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy4gKi9cbnZhciBkZWJ1cnJlZExldHRlcnMgPSB7XG4gIC8vIExhdGluLTEgU3VwcGxlbWVudCBibG9jay5cbiAgJ1xceGMwJzogJ0EnLCAgJ1xceGMxJzogJ0EnLCAnXFx4YzInOiAnQScsICdcXHhjMyc6ICdBJywgJ1xceGM0JzogJ0EnLCAnXFx4YzUnOiAnQScsXG4gICdcXHhlMCc6ICdhJywgICdcXHhlMSc6ICdhJywgJ1xceGUyJzogJ2EnLCAnXFx4ZTMnOiAnYScsICdcXHhlNCc6ICdhJywgJ1xceGU1JzogJ2EnLFxuICAnXFx4YzcnOiAnQycsICAnXFx4ZTcnOiAnYycsXG4gICdcXHhkMCc6ICdEJywgICdcXHhmMCc6ICdkJyxcbiAgJ1xceGM4JzogJ0UnLCAgJ1xceGM5JzogJ0UnLCAnXFx4Y2EnOiAnRScsICdcXHhjYic6ICdFJyxcbiAgJ1xceGU4JzogJ2UnLCAgJ1xceGU5JzogJ2UnLCAnXFx4ZWEnOiAnZScsICdcXHhlYic6ICdlJyxcbiAgJ1xceGNjJzogJ0knLCAgJ1xceGNkJzogJ0knLCAnXFx4Y2UnOiAnSScsICdcXHhjZic6ICdJJyxcbiAgJ1xceGVjJzogJ2knLCAgJ1xceGVkJzogJ2knLCAnXFx4ZWUnOiAnaScsICdcXHhlZic6ICdpJyxcbiAgJ1xceGQxJzogJ04nLCAgJ1xceGYxJzogJ24nLFxuICAnXFx4ZDInOiAnTycsICAnXFx4ZDMnOiAnTycsICdcXHhkNCc6ICdPJywgJ1xceGQ1JzogJ08nLCAnXFx4ZDYnOiAnTycsICdcXHhkOCc6ICdPJyxcbiAgJ1xceGYyJzogJ28nLCAgJ1xceGYzJzogJ28nLCAnXFx4ZjQnOiAnbycsICdcXHhmNSc6ICdvJywgJ1xceGY2JzogJ28nLCAnXFx4ZjgnOiAnbycsXG4gICdcXHhkOSc6ICdVJywgICdcXHhkYSc6ICdVJywgJ1xceGRiJzogJ1UnLCAnXFx4ZGMnOiAnVScsXG4gICdcXHhmOSc6ICd1JywgICdcXHhmYSc6ICd1JywgJ1xceGZiJzogJ3UnLCAnXFx4ZmMnOiAndScsXG4gICdcXHhkZCc6ICdZJywgICdcXHhmZCc6ICd5JywgJ1xceGZmJzogJ3knLFxuICAnXFx4YzYnOiAnQWUnLCAnXFx4ZTYnOiAnYWUnLFxuICAnXFx4ZGUnOiAnVGgnLCAnXFx4ZmUnOiAndGgnLFxuICAnXFx4ZGYnOiAnc3MnLFxuICAvLyBMYXRpbiBFeHRlbmRlZC1BIGJsb2NrLlxuICAnXFx1MDEwMCc6ICdBJywgICdcXHUwMTAyJzogJ0EnLCAnXFx1MDEwNCc6ICdBJyxcbiAgJ1xcdTAxMDEnOiAnYScsICAnXFx1MDEwMyc6ICdhJywgJ1xcdTAxMDUnOiAnYScsXG4gICdcXHUwMTA2JzogJ0MnLCAgJ1xcdTAxMDgnOiAnQycsICdcXHUwMTBhJzogJ0MnLCAnXFx1MDEwYyc6ICdDJyxcbiAgJ1xcdTAxMDcnOiAnYycsICAnXFx1MDEwOSc6ICdjJywgJ1xcdTAxMGInOiAnYycsICdcXHUwMTBkJzogJ2MnLFxuICAnXFx1MDEwZSc6ICdEJywgICdcXHUwMTEwJzogJ0QnLCAnXFx1MDEwZic6ICdkJywgJ1xcdTAxMTEnOiAnZCcsXG4gICdcXHUwMTEyJzogJ0UnLCAgJ1xcdTAxMTQnOiAnRScsICdcXHUwMTE2JzogJ0UnLCAnXFx1MDExOCc6ICdFJywgJ1xcdTAxMWEnOiAnRScsXG4gICdcXHUwMTEzJzogJ2UnLCAgJ1xcdTAxMTUnOiAnZScsICdcXHUwMTE3JzogJ2UnLCAnXFx1MDExOSc6ICdlJywgJ1xcdTAxMWInOiAnZScsXG4gICdcXHUwMTFjJzogJ0cnLCAgJ1xcdTAxMWUnOiAnRycsICdcXHUwMTIwJzogJ0cnLCAnXFx1MDEyMic6ICdHJyxcbiAgJ1xcdTAxMWQnOiAnZycsICAnXFx1MDExZic6ICdnJywgJ1xcdTAxMjEnOiAnZycsICdcXHUwMTIzJzogJ2cnLFxuICAnXFx1MDEyNCc6ICdIJywgICdcXHUwMTI2JzogJ0gnLCAnXFx1MDEyNSc6ICdoJywgJ1xcdTAxMjcnOiAnaCcsXG4gICdcXHUwMTI4JzogJ0knLCAgJ1xcdTAxMmEnOiAnSScsICdcXHUwMTJjJzogJ0knLCAnXFx1MDEyZSc6ICdJJywgJ1xcdTAxMzAnOiAnSScsXG4gICdcXHUwMTI5JzogJ2knLCAgJ1xcdTAxMmInOiAnaScsICdcXHUwMTJkJzogJ2knLCAnXFx1MDEyZic6ICdpJywgJ1xcdTAxMzEnOiAnaScsXG4gICdcXHUwMTM0JzogJ0onLCAgJ1xcdTAxMzUnOiAnaicsXG4gICdcXHUwMTM2JzogJ0snLCAgJ1xcdTAxMzcnOiAnaycsICdcXHUwMTM4JzogJ2snLFxuICAnXFx1MDEzOSc6ICdMJywgICdcXHUwMTNiJzogJ0wnLCAnXFx1MDEzZCc6ICdMJywgJ1xcdTAxM2YnOiAnTCcsICdcXHUwMTQxJzogJ0wnLFxuICAnXFx1MDEzYSc6ICdsJywgICdcXHUwMTNjJzogJ2wnLCAnXFx1MDEzZSc6ICdsJywgJ1xcdTAxNDAnOiAnbCcsICdcXHUwMTQyJzogJ2wnLFxuICAnXFx1MDE0Myc6ICdOJywgICdcXHUwMTQ1JzogJ04nLCAnXFx1MDE0Nyc6ICdOJywgJ1xcdTAxNGEnOiAnTicsXG4gICdcXHUwMTQ0JzogJ24nLCAgJ1xcdTAxNDYnOiAnbicsICdcXHUwMTQ4JzogJ24nLCAnXFx1MDE0Yic6ICduJyxcbiAgJ1xcdTAxNGMnOiAnTycsICAnXFx1MDE0ZSc6ICdPJywgJ1xcdTAxNTAnOiAnTycsXG4gICdcXHUwMTRkJzogJ28nLCAgJ1xcdTAxNGYnOiAnbycsICdcXHUwMTUxJzogJ28nLFxuICAnXFx1MDE1NCc6ICdSJywgICdcXHUwMTU2JzogJ1InLCAnXFx1MDE1OCc6ICdSJyxcbiAgJ1xcdTAxNTUnOiAncicsICAnXFx1MDE1Nyc6ICdyJywgJ1xcdTAxNTknOiAncicsXG4gICdcXHUwMTVhJzogJ1MnLCAgJ1xcdTAxNWMnOiAnUycsICdcXHUwMTVlJzogJ1MnLCAnXFx1MDE2MCc6ICdTJyxcbiAgJ1xcdTAxNWInOiAncycsICAnXFx1MDE1ZCc6ICdzJywgJ1xcdTAxNWYnOiAncycsICdcXHUwMTYxJzogJ3MnLFxuICAnXFx1MDE2Mic6ICdUJywgICdcXHUwMTY0JzogJ1QnLCAnXFx1MDE2Nic6ICdUJyxcbiAgJ1xcdTAxNjMnOiAndCcsICAnXFx1MDE2NSc6ICd0JywgJ1xcdTAxNjcnOiAndCcsXG4gICdcXHUwMTY4JzogJ1UnLCAgJ1xcdTAxNmEnOiAnVScsICdcXHUwMTZjJzogJ1UnLCAnXFx1MDE2ZSc6ICdVJywgJ1xcdTAxNzAnOiAnVScsICdcXHUwMTcyJzogJ1UnLFxuICAnXFx1MDE2OSc6ICd1JywgICdcXHUwMTZiJzogJ3UnLCAnXFx1MDE2ZCc6ICd1JywgJ1xcdTAxNmYnOiAndScsICdcXHUwMTcxJzogJ3UnLCAnXFx1MDE3Myc6ICd1JyxcbiAgJ1xcdTAxNzQnOiAnVycsICAnXFx1MDE3NSc6ICd3JyxcbiAgJ1xcdTAxNzYnOiAnWScsICAnXFx1MDE3Nyc6ICd5JywgJ1xcdTAxNzgnOiAnWScsXG4gICdcXHUwMTc5JzogJ1onLCAgJ1xcdTAxN2InOiAnWicsICdcXHUwMTdkJzogJ1onLFxuICAnXFx1MDE3YSc6ICd6JywgICdcXHUwMTdjJzogJ3onLCAnXFx1MDE3ZSc6ICd6JyxcbiAgJ1xcdTAxMzInOiAnSUonLCAnXFx1MDEzMyc6ICdpaicsXG4gICdcXHUwMTUyJzogJ09lJywgJ1xcdTAxNTMnOiAnb2UnLFxuICAnXFx1MDE0OSc6IFwiJ25cIiwgJ1xcdTAxN2YnOiAncydcbn07XG5cbi8qKlxuICogVXNlZCBieSBgXy5kZWJ1cnJgIHRvIGNvbnZlcnQgTGF0aW4tMSBTdXBwbGVtZW50IGFuZCBMYXRpbiBFeHRlbmRlZC1BXG4gKiBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBsZXR0ZXIgVGhlIG1hdGNoZWQgbGV0dGVyIHRvIGRlYnVyci5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIGxldHRlci5cbiAqL1xudmFyIGRlYnVyckxldHRlciA9IGJhc2VQcm9wZXJ0eU9mKGRlYnVycmVkTGV0dGVycyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVidXJyTGV0dGVyO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0eTtcbiIsInZhciBTZXRDYWNoZSA9IHJlcXVpcmUoJy4vX1NldENhY2hlJyksXG4gICAgYXJyYXlTb21lID0gcmVxdWlyZSgnLi9fYXJyYXlTb21lJyksXG4gICAgY2FjaGVIYXMgPSByZXF1aXJlKCcuL19jYWNoZUhhcycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgc2VlbiA9IChiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRykgPyBuZXcgU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoc2Vlbikge1xuICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsQXJyYXlzO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5JyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyksXG4gICAgZXF1YWxBcnJheXMgPSByZXF1aXJlKCcuL19lcXVhbEFycmF5cycpLFxuICAgIG1hcFRvQXJyYXkgPSByZXF1aXJlKCcuL19tYXBUb0FycmF5JyksXG4gICAgc2V0VG9BcnJheSA9IHJlcXVpcmUoJy4vX3NldFRvQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRztcblxuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEJ5VGFnO1xuIiwidmFyIGdldEFsbEtleXMgPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsT2JqZWN0cztcbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnJlZUdsb2JhbDtcbiIsInZhciBiYXNlR2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRBbGxLZXlzJyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWxsS2V5cztcbiIsInZhciBiYXNlR2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRBbGxLZXlzJyksXG4gICAgZ2V0U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9sc0luJyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNJbiwgZ2V0U3ltYm9sc0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbGxLZXlzSW47XG4iLCJ2YXIgaXNLZXlhYmxlID0gcmVxdWlyZSgnLi9faXNLZXlhYmxlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXBEYXRhO1xuIiwidmFyIGlzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX2lzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWF0Y2hEYXRhO1xuIiwidmFyIGJhc2VJc05hdGl2ZSA9IHJlcXVpcmUoJy4vX2Jhc2VJc05hdGl2ZScpLFxuICAgIGdldFZhbHVlID0gcmVxdWlyZSgnLi9fZ2V0VmFsdWUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROYXRpdmU7XG4iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UHJvdG90eXBlO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UmF3VGFnO1xuIiwidmFyIGFycmF5RmlsdGVyID0gcmVxdWlyZSgnLi9fYXJyYXlGaWx0ZXInKSxcbiAgICBzdHViQXJyYXkgPSByZXF1aXJlKCcuL3N0dWJBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U3ltYm9scztcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpLFxuICAgIHN0dWJBcnJheSA9IHJlcXVpcmUoJy4vc3R1YkFycmF5Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHNJbiA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgd2hpbGUgKG9iamVjdCkge1xuICAgIGFycmF5UHVzaChyZXN1bHQsIGdldFN5bWJvbHMob2JqZWN0KSk7XG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlKG9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U3ltYm9sc0luO1xuIiwidmFyIERhdGFWaWV3ID0gcmVxdWlyZSgnLi9fRGF0YVZpZXcnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBQcm9taXNlID0gcmVxdWlyZSgnLi9fUHJvbWlzZScpLFxuICAgIFNldCA9IHJlcXVpcmUoJy4vX1NldCcpLFxuICAgIFdlYWtNYXAgPSByZXF1aXJlKCcuL19XZWFrTWFwJyksXG4gICAgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VGFnO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VmFsdWU7XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgfVxuICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzUGF0aDtcbiIsIi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbnZhciByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSxcbiAgICByc1ZhclJhbmdlID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZic7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc1pXSiA9ICdcXFxcdTIwMGQnO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB3aXRoIFt6ZXJvLXdpZHRoIGpvaW5lcnMgb3IgY29kZSBwb2ludHMgZnJvbSB0aGUgYXN0cmFsIHBsYW5lc10oaHR0cDovL2Vldi5lZS9ibG9nLzIwMTUvMDkvMTIvZGFyay1jb3JuZXJzLW9mLXVuaWNvZGUvKS4gKi9cbnZhciByZUhhc1VuaWNvZGUgPSBSZWdFeHAoJ1snICsgcnNaV0ogKyByc0FzdHJhbFJhbmdlICArIHJzQ29tYm9SYW5nZSArIHJzVmFyUmFuZ2UgKyAnXScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBVbmljb2RlIHN5bWJvbHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgc3ltYm9sIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1VuaWNvZGUoc3RyaW5nKSB7XG4gIHJldHVybiByZUhhc1VuaWNvZGUudGVzdChzdHJpbmcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1VuaWNvZGU7XG4iLCIvKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB0aGF0IG5lZWQgYSBtb3JlIHJvYnVzdCByZWdleHAgdG8gbWF0Y2ggd29yZHMuICovXG52YXIgcmVIYXNVbmljb2RlV29yZCA9IC9bYS16XVtBLVpdfFtBLVpdezIsfVthLXpdfFswLTldW2EtekEtWl18W2EtekEtWl1bMC05XXxbXmEtekEtWjAtOSBdLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgYSB3b3JkIGNvbXBvc2VkIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSB3b3JkIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1VuaWNvZGVXb3JkKHN0cmluZykge1xuICByZXR1cm4gcmVIYXNVbmljb2RlV29yZC50ZXN0KHN0cmluZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzVW5pY29kZVdvcmQ7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaERlbGV0ZTtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hHZXQ7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoSGFzO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoU2V0O1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgLy8gQWRkIHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgaWYgKGxlbmd0aCAmJiB0eXBlb2YgYXJyYXlbMF0gPT0gJ3N0cmluZycgJiYgaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgJ2luZGV4JykpIHtcbiAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUFycmF5O1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyksXG4gICAgY2xvbmVEYXRhVmlldyA9IHJlcXVpcmUoJy4vX2Nsb25lRGF0YVZpZXcnKSxcbiAgICBjbG9uZU1hcCA9IHJlcXVpcmUoJy4vX2Nsb25lTWFwJyksXG4gICAgY2xvbmVSZWdFeHAgPSByZXF1aXJlKCcuL19jbG9uZVJlZ0V4cCcpLFxuICAgIGNsb25lU2V0ID0gcmVxdWlyZSgnLi9fY2xvbmVTZXQnKSxcbiAgICBjbG9uZVN5bWJvbCA9IHJlcXVpcmUoJy4vX2Nsb25lU3ltYm9sJyksXG4gICAgY2xvbmVUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fY2xvbmVUeXBlZEFycmF5Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNsb25lRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2xvbmUgdmFsdWVzLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgY2xvbmVGdW5jLCBpc0RlZXApIHtcbiAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIHJldHVybiBjbG9uZUFycmF5QnVmZmVyKG9iamVjdCk7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIHJldHVybiBjbG9uZURhdGFWaWV3KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgZmxvYXQzMlRhZzogY2FzZSBmbG9hdDY0VGFnOlxuICAgIGNhc2UgaW50OFRhZzogY2FzZSBpbnQxNlRhZzogY2FzZSBpbnQzMlRhZzpcbiAgICBjYXNlIHVpbnQ4VGFnOiBjYXNlIHVpbnQ4Q2xhbXBlZFRhZzogY2FzZSB1aW50MTZUYWc6IGNhc2UgdWludDMyVGFnOlxuICAgICAgcmV0dXJuIGNsb25lVHlwZWRBcnJheShvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHJldHVybiBjbG9uZU1hcChvYmplY3QsIGlzRGVlcCwgY2xvbmVGdW5jKTtcblxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVJlZ0V4cChvYmplY3QpO1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICByZXR1cm4gY2xvbmVTZXQob2JqZWN0LCBpc0RlZXAsIGNsb25lRnVuYyk7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVN5bWJvbChvYmplY3QpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lQnlUYWc7XG4iLCJ2YXIgYmFzZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX2Jhc2VDcmVhdGUnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVPYmplY3Q7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJlxuICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0l0ZXJhdGVlQ2FsbDtcbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleWFibGU7XG4iLCJ2YXIgY29yZUpzRGF0YSA9IHJlcXVpcmUoJy4vX2NvcmVKc0RhdGEnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc01hc2tlZDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1Byb3RvdHlwZTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaWN0Q29tcGFyYWJsZTtcbiIsIi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVDbGVhcjtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZURlbGV0ZTtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVHZXQ7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUhhcztcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZVNldDtcbiIsInZhciBIYXNoID0gcmVxdWlyZSgnLi9fSGFzaCcpLFxuICAgIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVDbGVhcjtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZURlbGV0ZTtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVHZXQ7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUhhcztcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVTZXQ7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcFRvQXJyYXk7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0Y2hlc1N0cmljdENvbXBhcmFibGU7XG4iLCJ2YXIgbWVtb2l6ZSA9IHJlcXVpcmUoJy4vbWVtb2l6ZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG52YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZUNhcHBlZDtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVDcmVhdGU7XG4iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXM7XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzSW47XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVVdGlsO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb2JqZWN0VG9TdHJpbmc7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyQXJnO1xuIiwidmFyIGFwcGx5ID0gcmVxdWlyZSgnLi9fYXBwbHknKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyUmVzdDtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcbiIsIi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENhY2hlQWRkO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENhY2hlSGFzO1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb0FycmF5O1xuIiwidmFyIGJhc2VTZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX2Jhc2VTZXRUb1N0cmluZycpLFxuICAgIHNob3J0T3V0ID0gcmVxdWlyZSgnLi9fc2hvcnRPdXQnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb1N0cmluZztcbiIsIi8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cbnZhciBIT1RfQ09VTlQgPSA4MDAsXG4gICAgSE9UX1NQQU4gPSAxNjtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU5vdyA9IERhdGUubm93O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxuICogb2YgYGZ1bmNgIHdoZW4gaXQncyBjYWxsZWQgYEhPVF9DT1VOVGAgb3IgbW9yZSB0aW1lcyBpbiBgSE9UX1NQQU5gXG4gKiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gIHZhciBjb3VudCA9IDAsXG4gICAgICBsYXN0Q2FsbGVkID0gMDtcblxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksXG4gICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG9ydE91dDtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0NsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrRGVsZXRlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrR2V0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0hhcztcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrU2V0O1xuIiwidmFyIGFzY2lpVG9BcnJheSA9IHJlcXVpcmUoJy4vX2FzY2lpVG9BcnJheScpLFxuICAgIGhhc1VuaWNvZGUgPSByZXF1aXJlKCcuL19oYXNVbmljb2RlJyksXG4gICAgdW5pY29kZVRvQXJyYXkgPSByZXF1aXJlKCcuL191bmljb2RlVG9BcnJheScpO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBzdHJpbmdUb0FycmF5KHN0cmluZykge1xuICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgPyB1bmljb2RlVG9BcnJheShzdHJpbmcpXG4gICAgOiBhc2NpaVRvQXJyYXkoc3RyaW5nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdUb0FycmF5O1xuIiwidmFyIG1lbW9pemVDYXBwZWQgPSByZXF1aXJlKCcuL19tZW1vaXplQ2FwcGVkJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUxlYWRpbmdEb3QgPSAvXlxcLi8sXG4gICAgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHJlTGVhZGluZ0RvdC50ZXN0KHN0cmluZykpIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdUb1BhdGg7XG4iLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvS2V5O1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU291cmNlO1xuIiwiLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xudmFyIHJzQXN0cmFsUmFuZ2UgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZicsXG4gICAgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgcmVDb21ib0hhbGZNYXJrc1JhbmdlID0gJ1xcXFx1ZmUyMC1cXFxcdWZlMmYnLFxuICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZicsXG4gICAgcnNDb21ib1JhbmdlID0gcnNDb21ib01hcmtzUmFuZ2UgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlLFxuICAgIHJzVmFyUmFuZ2UgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQXN0cmFsID0gJ1snICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICByc0NvbWJvID0gJ1snICsgcnNDb21ib1JhbmdlICsgJ10nLFxuICAgIHJzRml0eiA9ICdcXFxcdWQ4M2NbXFxcXHVkZmZiLVxcXFx1ZGZmZl0nLFxuICAgIHJzTW9kaWZpZXIgPSAnKD86JyArIHJzQ29tYm8gKyAnfCcgKyByc0ZpdHogKyAnKScsXG4gICAgcnNOb25Bc3RyYWwgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICByc1JlZ2lvbmFsID0gJyg/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn0nLFxuICAgIHJzU3VyclBhaXIgPSAnW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdJyxcbiAgICByc1pXSiA9ICdcXFxcdTIwMGQnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgcmVnZXhlcy4gKi9cbnZhciByZU9wdE1vZCA9IHJzTW9kaWZpZXIgKyAnPycsXG4gICAgcnNPcHRWYXIgPSAnWycgKyByc1ZhclJhbmdlICsgJ10/JyxcbiAgICByc09wdEpvaW4gPSAnKD86JyArIHJzWldKICsgJyg/OicgKyBbcnNOb25Bc3RyYWwsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzT3B0VmFyICsgcmVPcHRNb2QgKyAnKSonLFxuICAgIHJzU2VxID0gcnNPcHRWYXIgKyByZU9wdE1vZCArIHJzT3B0Sm9pbixcbiAgICByc1N5bWJvbCA9ICcoPzonICsgW3JzTm9uQXN0cmFsICsgcnNDb21ibyArICc/JywgcnNDb21ibywgcnNSZWdpb25hbCwgcnNTdXJyUGFpciwgcnNBc3RyYWxdLmpvaW4oJ3wnKSArICcpJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggW3N0cmluZyBzeW1ib2xzXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC11bmljb2RlKS4gKi9cbnZhciByZVVuaWNvZGUgPSBSZWdFeHAocnNGaXR6ICsgJyg/PScgKyByc0ZpdHogKyAnKXwnICsgcnNTeW1ib2wgKyByc1NlcSwgJ2cnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVuaWNvZGUgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHVuaWNvZGVUb0FycmF5KHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZSkgfHwgW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pY29kZVRvQXJyYXk7XG4iLCIvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsXG4gICAgcnNEaW5nYmF0UmFuZ2UgPSAnXFxcXHUyNzAwLVxcXFx1MjdiZicsXG4gICAgcnNMb3dlclJhbmdlID0gJ2EtelxcXFx4ZGYtXFxcXHhmNlxcXFx4ZjgtXFxcXHhmZicsXG4gICAgcnNNYXRoT3BSYW5nZSA9ICdcXFxceGFjXFxcXHhiMVxcXFx4ZDdcXFxceGY3JyxcbiAgICByc05vbkNoYXJSYW5nZSA9ICdcXFxceDAwLVxcXFx4MmZcXFxceDNhLVxcXFx4NDBcXFxceDViLVxcXFx4NjBcXFxceDdiLVxcXFx4YmYnLFxuICAgIHJzUHVuY3R1YXRpb25SYW5nZSA9ICdcXFxcdTIwMDAtXFxcXHUyMDZmJyxcbiAgICByc1NwYWNlUmFuZ2UgPSAnIFxcXFx0XFxcXHgwYlxcXFxmXFxcXHhhMFxcXFx1ZmVmZlxcXFxuXFxcXHJcXFxcdTIwMjhcXFxcdTIwMjlcXFxcdTE2ODBcXFxcdTE4MGVcXFxcdTIwMDBcXFxcdTIwMDFcXFxcdTIwMDJcXFxcdTIwMDNcXFxcdTIwMDRcXFxcdTIwMDVcXFxcdTIwMDZcXFxcdTIwMDdcXFxcdTIwMDhcXFxcdTIwMDlcXFxcdTIwMGFcXFxcdTIwMmZcXFxcdTIwNWZcXFxcdTMwMDAnLFxuICAgIHJzVXBwZXJSYW5nZSA9ICdBLVpcXFxceGMwLVxcXFx4ZDZcXFxceGQ4LVxcXFx4ZGUnLFxuICAgIHJzVmFyUmFuZ2UgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJyxcbiAgICByc0JyZWFrUmFuZ2UgPSByc01hdGhPcFJhbmdlICsgcnNOb25DaGFyUmFuZ2UgKyByc1B1bmN0dWF0aW9uUmFuZ2UgKyByc1NwYWNlUmFuZ2U7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc0Fwb3MgPSBcIlsnXFx1MjAxOV1cIixcbiAgICByc0JyZWFrID0gJ1snICsgcnNCcmVha1JhbmdlICsgJ10nLFxuICAgIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UgKyAnXScsXG4gICAgcnNEaWdpdHMgPSAnXFxcXGQrJyxcbiAgICByc0RpbmdiYXQgPSAnWycgKyByc0RpbmdiYXRSYW5nZSArICddJyxcbiAgICByc0xvd2VyID0gJ1snICsgcnNMb3dlclJhbmdlICsgJ10nLFxuICAgIHJzTWlzYyA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgcnNCcmVha1JhbmdlICsgcnNEaWdpdHMgKyByc0RpbmdiYXRSYW5nZSArIHJzTG93ZXJSYW5nZSArIHJzVXBwZXJSYW5nZSArICddJyxcbiAgICByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJyxcbiAgICByc01vZGlmaWVyID0gJyg/OicgKyByc0NvbWJvICsgJ3wnICsgcnNGaXR6ICsgJyknLFxuICAgIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgcnNSZWdpb25hbCA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JyxcbiAgICByc1N1cnJQYWlyID0gJ1tcXFxcdWQ4MDAtXFxcXHVkYmZmXVtcXFxcdWRjMDAtXFxcXHVkZmZmXScsXG4gICAgcnNVcHBlciA9ICdbJyArIHJzVXBwZXJSYW5nZSArICddJyxcbiAgICByc1pXSiA9ICdcXFxcdTIwMGQnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgcmVnZXhlcy4gKi9cbnZhciByc01pc2NMb3dlciA9ICcoPzonICsgcnNMb3dlciArICd8JyArIHJzTWlzYyArICcpJyxcbiAgICByc01pc2NVcHBlciA9ICcoPzonICsgcnNVcHBlciArICd8JyArIHJzTWlzYyArICcpJyxcbiAgICByc09wdENvbnRyTG93ZXIgPSAnKD86JyArIHJzQXBvcyArICcoPzpkfGxsfG18cmV8c3x0fHZlKSk/JyxcbiAgICByc09wdENvbnRyVXBwZXIgPSAnKD86JyArIHJzQXBvcyArICcoPzpEfExMfE18UkV8U3xUfFZFKSk/JyxcbiAgICByZU9wdE1vZCA9IHJzTW9kaWZpZXIgKyAnPycsXG4gICAgcnNPcHRWYXIgPSAnWycgKyByc1ZhclJhbmdlICsgJ10/JyxcbiAgICByc09wdEpvaW4gPSAnKD86JyArIHJzWldKICsgJyg/OicgKyBbcnNOb25Bc3RyYWwsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzT3B0VmFyICsgcmVPcHRNb2QgKyAnKSonLFxuICAgIHJzT3JkTG93ZXIgPSAnXFxcXGQqKD86KD86MXN0fDJuZHwzcmR8KD8hWzEyM10pXFxcXGR0aClcXFxcYiknLFxuICAgIHJzT3JkVXBwZXIgPSAnXFxcXGQqKD86KD86MVNUfDJORHwzUkR8KD8hWzEyM10pXFxcXGRUSClcXFxcYiknLFxuICAgIHJzU2VxID0gcnNPcHRWYXIgKyByZU9wdE1vZCArIHJzT3B0Sm9pbixcbiAgICByc0Vtb2ppID0gJyg/OicgKyBbcnNEaW5nYmF0LCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc1NlcTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggY29tcGxleCBvciBjb21wb3VuZCB3b3Jkcy4gKi9cbnZhciByZVVuaWNvZGVXb3JkID0gUmVnRXhwKFtcbiAgcnNVcHBlciArICc/JyArIHJzTG93ZXIgKyAnKycgKyByc09wdENvbnRyTG93ZXIgKyAnKD89JyArIFtyc0JyZWFrLCByc1VwcGVyLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgcnNNaXNjVXBwZXIgKyAnKycgKyByc09wdENvbnRyVXBwZXIgKyAnKD89JyArIFtyc0JyZWFrLCByc1VwcGVyICsgcnNNaXNjTG93ZXIsICckJ10uam9pbignfCcpICsgJyknLFxuICByc1VwcGVyICsgJz8nICsgcnNNaXNjTG93ZXIgKyAnKycgKyByc09wdENvbnRyTG93ZXIsXG4gIHJzVXBwZXIgKyAnKycgKyByc09wdENvbnRyVXBwZXIsXG4gIHJzT3JkVXBwZXIsXG4gIHJzT3JkTG93ZXIsXG4gIHJzRGlnaXRzLFxuICByc0Vtb2ppXG5dLmpvaW4oJ3wnKSwgJ2cnKTtcblxuLyoqXG4gKiBTcGxpdHMgYSBVbmljb2RlIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAqL1xuZnVuY3Rpb24gdW5pY29kZVdvcmRzKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZVdvcmQpIHx8IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVuaWNvZGVXb3JkcztcbiIsInZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBjcmVhdGVBc3NpZ25lciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUFzc2lnbmVyJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIHRvIHRoZVxuICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gKiBTdWJzZXF1ZW50IHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAgYW5kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgT2JqZWN0LmFzc2lnbmBdKGh0dHBzOi8vbWRuLmlvL09iamVjdC9hc3NpZ24pLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAc2VlIF8uYXNzaWduSW5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIGZ1bmN0aW9uIEJhcigpIHtcbiAqICAgdGhpcy5jID0gMztcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmIgPSAyO1xuICogQmFyLnByb3RvdHlwZS5kID0gNDtcbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMCB9LCBuZXcgRm9vLCBuZXcgQmFyKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICovXG52YXIgYXNzaWduID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgaWYgKGlzUHJvdG90eXBlKHNvdXJjZSkgfHwgaXNBcnJheUxpa2Uoc291cmNlKSkge1xuICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgfVxuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ247XG4iLCJ2YXIgY2FwaXRhbGl6ZSA9IHJlcXVpcmUoJy4vY2FwaXRhbGl6ZScpLFxuICAgIGNyZWF0ZUNvbXBvdW5kZXIgPSByZXF1aXJlKCcuL19jcmVhdGVDb21wb3VuZGVyJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gW2NhbWVsIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhbWVsQ2FzZSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhbWVsIGNhc2VkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5jYW1lbENhc2UoJ0ZvbyBCYXInKTtcbiAqIC8vID0+ICdmb29CYXInXG4gKlxuICogXy5jYW1lbENhc2UoJy0tZm9vLWJhci0tJyk7XG4gKiAvLyA9PiAnZm9vQmFyJ1xuICpcbiAqIF8uY2FtZWxDYXNlKCdfX0ZPT19CQVJfXycpO1xuICogLy8gPT4gJ2Zvb0JhcidcbiAqL1xudmFyIGNhbWVsQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICB3b3JkID0gd29yZC50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gY2FwaXRhbGl6ZSh3b3JkKSA6IHdvcmQpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gY2FtZWxDYXNlO1xuIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpLFxuICAgIHVwcGVyRmlyc3QgPSByZXF1aXJlKCcuL3VwcGVyRmlyc3QnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIHVwcGVyIGNhc2UgYW5kIHRoZSByZW1haW5pbmdcbiAqIHRvIGxvd2VyIGNhc2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY2FwaXRhbGl6ZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhcGl0YWxpemVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5jYXBpdGFsaXplKCdGUkVEJyk7XG4gKiAvLyA9PiAnRnJlZCdcbiAqL1xuZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHVwcGVyRmlyc3QodG9TdHJpbmcoc3RyaW5nKS50b0xvd2VyQ2FzZSgpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXBpdGFsaXplO1xuIiwidmFyIGJhc2VDbG9uZSA9IHJlcXVpcmUoJy4vX2Jhc2VDbG9uZScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYHZhbHVlYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGVcbiAqIFtzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobV0oaHR0cHM6Ly9tZG4uaW8vU3RydWN0dXJlZF9jbG9uZV9hbGdvcml0aG0pXG4gKiBhbmQgc3VwcG9ydHMgY2xvbmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLCBkYXRlIG9iamVjdHMsIG1hcHMsXG4gKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWRcbiAqIGFycmF5cy4gVGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhcmUgY2xvbmVkXG4gKiBhcyBwbGFpbiBvYmplY3RzLiBBbiBlbXB0eSBvYmplY3QgaXMgcmV0dXJuZWQgZm9yIHVuY2xvbmVhYmxlIHZhbHVlcyBzdWNoXG4gKiBhcyBlcnJvciBvYmplY3RzLCBmdW5jdGlvbnMsIERPTSBub2RlcywgYW5kIFdlYWtNYXBzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKiBAc2VlIF8uY2xvbmVEZWVwXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICpcbiAqIHZhciBzaGFsbG93ID0gXy5jbG9uZShvYmplY3RzKTtcbiAqIGNvbnNvbGUubG9nKHNoYWxsb3dbMF0gPT09IG9iamVjdHNbMF0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjbG9uZSh2YWx1ZSkge1xuICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xuIiwidmFyIGJhc2VDbG9uZSA9IHJlcXVpcmUoJy4vX2Jhc2VDbG9uZScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBjbG9uZXMgYHZhbHVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDEuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmVjdXJzaXZlbHkgY2xvbmUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gKiBAc2VlIF8uY2xvbmVcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gKlxuICogdmFyIGRlZXAgPSBfLmNsb25lRGVlcChvYmplY3RzKTtcbiAqIGNvbnNvbGUubG9nKGRlZXBbMF0gPT09IG9iamVjdHNbMF0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gY2xvbmVEZWVwKHZhbHVlKSB7XG4gIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVEZWVwO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29uc3RhbnQ7XG4iLCJ2YXIgZGVidXJyTGV0dGVyID0gcmVxdWlyZSgnLi9fZGVidXJyTGV0dGVyJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIExhdGluIFVuaWNvZGUgbGV0dGVycyAoZXhjbHVkaW5nIG1hdGhlbWF0aWNhbCBvcGVyYXRvcnMpLiAqL1xudmFyIHJlTGF0aW4gPSAvW1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHhmZlxcdTAxMDAtXFx1MDE3Zl0vZztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xudmFyIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UgKyAnXSc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpIGFuZFxuICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrcyBmb3Igc3ltYm9sc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzX2Zvcl9TeW1ib2xzKS5cbiAqL1xudmFyIHJlQ29tYm9NYXJrID0gUmVnRXhwKHJzQ29tYm8sICdnJyk7XG5cbi8qKlxuICogRGVidXJycyBgc3RyaW5nYCBieSBjb252ZXJ0aW5nXG4gKiBbTGF0aW4tMSBTdXBwbGVtZW50XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbi0xX1N1cHBsZW1lbnRfKFVuaWNvZGVfYmxvY2spI0NoYXJhY3Rlcl90YWJsZSlcbiAqIGFuZCBbTGF0aW4gRXh0ZW5kZWQtQV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW5fRXh0ZW5kZWQtQSlcbiAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycyBhbmQgcmVtb3ZpbmdcbiAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZGVidXJyLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlYnVycignZMOpasOgIHZ1Jyk7XG4gKiAvLyA9PiAnZGVqYSB2dSdcbiAqL1xuZnVuY3Rpb24gZGVidXJyKHN0cmluZykge1xuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICByZXR1cm4gc3RyaW5nICYmIHN0cmluZy5yZXBsYWNlKHJlTGF0aW4sIGRlYnVyckxldHRlcikucmVwbGFjZShyZUNvbWJvTWFyaywgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlYnVycjtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mb3JFYWNoJyk7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcTtcbiIsInZhciBhcnJheUVhY2ggPSByZXF1aXJlKCcuL19hcnJheUVhY2gnKSxcbiAgICBiYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2Jhc2VFYWNoJyksXG4gICAgY2FzdEZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fY2FzdEZ1bmN0aW9uJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggZWxlbWVudC5cbiAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogKipOb3RlOioqIEFzIHdpdGggb3RoZXIgXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMsIG9iamVjdHMgd2l0aCBhIFwibGVuZ3RoXCJcbiAqIHByb3BlcnR5IGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciB1c2UgYF8uZm9ySW5gXG4gKiBvciBgXy5mb3JPd25gIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBhbGlhcyBlYWNoXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqIEBzZWUgXy5mb3JFYWNoUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogXy5mb3JFYWNoKFsxLCAyXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAqICAgY29uc29sZS5sb2codmFsdWUpO1xuICogfSk7XG4gKiAvLyA9PiBMb2dzIGAxYCB0aGVuIGAyYC5cbiAqXG4gKiBfLmZvckVhY2goeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gKiB9KTtcbiAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RWFjaCA6IGJhc2VFYWNoO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBjYXN0RnVuY3Rpb24oaXRlcmF0ZWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoO1xuIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXQ7XG4iLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgY3JlYXRlQWdncmVnYXRvciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUFnZ3JlZ2F0b3InKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgb3JkZXIgb2YgZ3JvdXBlZCB2YWx1ZXNcbiAqIGlzIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gYGNvbGxlY3Rpb25gLiBUaGUgY29ycmVzcG9uZGluZ1xuICogdmFsdWUgb2YgZWFjaCBrZXkgaXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlXG4gKiBrZXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5ncm91cEJ5KFs2LjEsIDQuMiwgNi4zXSwgTWF0aC5mbG9vcik7XG4gKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi4zXSB9XG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmdyb3VwQnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAqIC8vID0+IHsgJzMnOiBbJ29uZScsICd0d28nXSwgJzUnOiBbJ3RocmVlJ10gfVxuICovXG52YXIgZ3JvdXBCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xuICAgIHJlc3VsdFtrZXldLnB1c2godmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgW3ZhbHVlXSk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdyb3VwQnk7XG4iLCJ2YXIgYmFzZUhhc0luID0gcmVxdWlyZSgnLi9fYmFzZUhhc0luJyksXG4gICAgaGFzUGF0aCA9IHJlcXVpcmUoJy4vX2hhc1BhdGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0luO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eTtcbiIsInZhciBiYXNlSXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL19iYXNlSXNBcmd1bWVudHMnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcbiIsInZhciBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2VPYmplY3Q7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKSxcbiAgICBzdHViRmFsc2UgPSByZXF1aXJlKCcuL3N0dWJGYWxzZScpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCdWZmZXI7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTnVtYmVyYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqICoqTm90ZToqKiBUbyBleGNsdWRlIGBJbmZpbml0eWAsIGAtSW5maW5pdHlgLCBhbmQgYE5hTmAsIHdoaWNoIGFyZVxuICogY2xhc3NpZmllZCBhcyBudW1iZXJzLCB1c2UgdGhlIGBfLmlzRmluaXRlYCBtZXRob2QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc051bWJlcigzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOdW1iZXIoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBudW1iZXJUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTnVtYmVyO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQbGFpbk9iamVjdDtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N5bWJvbDtcbiIsInZhciBiYXNlSXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fYmFzZUlzVHlwZWRBcnJheScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXMgPSByZXF1aXJlKCcuL19iYXNlS2V5cycpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzO1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzSW4nKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c0luO1xuIiwidmFyIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICBiYXNlTWFwID0gcmVxdWlyZSgnLi9fYmFzZU1hcCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydVxuICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gKiBgXy5ldmVyeWAsIGBfLmZpbHRlcmAsIGBfLm1hcGAsIGBfLm1hcFZhbHVlc2AsIGBfLnJlamVjdGAsIGFuZCBgXy5zb21lYC5cbiAqXG4gKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAqIGBhcnlgLCBgY2h1bmtgLCBgY3VycnlgLCBgY3VycnlSaWdodGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBldmVyeWAsXG4gKiBgZmlsbGAsIGBpbnZlcnRgLCBgcGFyc2VJbnRgLCBgcmFuZG9tYCwgYHJhbmdlYCwgYHJhbmdlUmlnaHRgLCBgcmVwZWF0YCxcbiAqIGBzYW1wbGVTaXplYCwgYHNsaWNlYCwgYHNvbWVgLCBgc29ydEJ5YCwgYHNwbGl0YCwgYHRha2VgLCBgdGFrZVJpZ2h0YCxcbiAqIGB0ZW1wbGF0ZWAsIGB0cmltYCwgYHRyaW1FbmRgLCBgdHJpbVN0YXJ0YCwgYW5kIGB3b3Jkc2BcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gKiAgIHJldHVybiBuICogbjtcbiAqIH1cbiAqXG4gKiBfLm1hcChbNCwgOF0sIHNxdWFyZSk7XG4gKiAvLyA9PiBbMTYsIDY0XVxuICpcbiAqIF8ubWFwKHsgJ2EnOiA0LCAnYic6IDggfSwgc3F1YXJlKTtcbiAqIC8vID0+IFsxNiwgNjRdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJyB9XG4gKiBdO1xuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5tYXAodXNlcnMsICd1c2VyJyk7XG4gKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAqL1xuZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5TWFwIDogYmFzZU1hcDtcbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgYmFzZUl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwO1xuIiwidmFyIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemU7XG4iLCJ2YXIgYmFzZU1lcmdlID0gcmVxdWlyZSgnLi9fYmFzZU1lcmdlJyksXG4gICAgY3JlYXRlQXNzaWduZXIgPSByZXF1aXJlKCcuL19jcmVhdGVBc3NpZ25lcicpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBtZXJnZXMgb3duIGFuZFxuICogaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgaW50byB0aGVcbiAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgIGFyZVxuICogc2tpcHBlZCBpZiBhIGRlc3RpbmF0aW9uIHZhbHVlIGV4aXN0cy4gQXJyYXkgYW5kIHBsYWluIG9iamVjdCBwcm9wZXJ0aWVzXG4gKiBhcmUgbWVyZ2VkIHJlY3Vyc2l2ZWx5LiBPdGhlciBvYmplY3RzIGFuZCB2YWx1ZSB0eXBlcyBhcmUgb3ZlcnJpZGRlbiBieVxuICogYXNzaWdubWVudC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LiBTdWJzZXF1ZW50XG4gKiBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC41LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHtcbiAqICAgJ2EnOiBbeyAnYic6IDIgfSwgeyAnZCc6IDQgfV1cbiAqIH07XG4gKlxuICogdmFyIG90aGVyID0ge1xuICogICAnYSc6IFt7ICdjJzogMyB9LCB7ICdlJzogNSB9XVxuICogfTtcbiAqXG4gKiBfLm1lcmdlKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4geyAnYSc6IFt7ICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2QnOiA0LCAnZSc6IDUgfV0gfVxuICovXG52YXIgbWVyZ2UgPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpIHtcbiAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZXJnZTtcbiIsIi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbmVnYXRlcyB0aGUgcmVzdWx0IG9mIHRoZSBwcmVkaWNhdGUgYGZ1bmNgLiBUaGVcbiAqIGBmdW5jYCBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZVxuICogY3JlYXRlZCBmdW5jdGlvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlIHRvIG5lZ2F0ZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG5lZ2F0ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIGlzRXZlbihuKSB7XG4gKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICogfVxuICpcbiAqIF8uZmlsdGVyKFsxLCAyLCAzLCA0LCA1LCA2XSwgXy5uZWdhdGUoaXNFdmVuKSk7XG4gKiAvLyA9PiBbMSwgMywgNV1cbiAqL1xuZnVuY3Rpb24gbmVnYXRlKHByZWRpY2F0ZSkge1xuICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcyk7XG4gICAgICBjYXNlIDE6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSk7XG4gICAgICBjYXNlIDI6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICBjYXNlIDM6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgfVxuICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5lZ2F0ZTtcbiIsInZhciBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICBuZWdhdGUgPSByZXF1aXJlKCcuL25lZ2F0ZScpLFxuICAgIHBpY2tCeSA9IHJlcXVpcmUoJy4vcGlja0J5Jyk7XG5cbi8qKlxuICogVGhlIG9wcG9zaXRlIG9mIGBfLnBpY2tCeWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mXG4gKiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBgb2JqZWN0YCB0aGF0XG4gKiBgcHJlZGljYXRlYCBkb2Vzbid0IHJldHVybiB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0d29cbiAqIGFyZ3VtZW50czogKHZhbHVlLCBrZXkpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICpcbiAqIF8ub21pdEJ5KG9iamVjdCwgXy5pc051bWJlcik7XG4gKiAvLyA9PiB7ICdiJzogJzInIH1cbiAqL1xuZnVuY3Rpb24gb21pdEJ5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gIHJldHVybiBwaWNrQnkob2JqZWN0LCBuZWdhdGUoYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSkpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvbWl0Qnk7XG4iLCJ2YXIgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGJhc2VQaWNrQnkgPSByZXF1aXJlKCcuL19iYXNlUGlja0J5JyksXG4gICAgZ2V0QWxsS2V5c0luID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5c0luJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGBvYmplY3RgIHByb3BlcnRpZXMgYHByZWRpY2F0ZWAgcmV0dXJuc1xuICogdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKHZhbHVlLCBrZXkpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICpcbiAqIF8ucGlja0J5KG9iamVjdCwgXy5pc051bWJlcik7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAqL1xuZnVuY3Rpb24gcGlja0J5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICB2YXIgcHJvcHMgPSBhcnJheU1hcChnZXRBbGxLZXlzSW4ob2JqZWN0KSwgZnVuY3Rpb24ocHJvcCkge1xuICAgIHJldHVybiBbcHJvcF07XG4gIH0pO1xuICBwcmVkaWNhdGUgPSBiYXNlSXRlcmF0ZWUocHJlZGljYXRlKTtcbiAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwcm9wcywgZnVuY3Rpb24odmFsdWUsIHBhdGgpIHtcbiAgICByZXR1cm4gcHJlZGljYXRlKHZhbHVlLCBwYXRoWzBdKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGlja0J5O1xuIiwidmFyIGJhc2VQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eScpLFxuICAgIGJhc2VQcm9wZXJ0eURlZXAgPSByZXF1aXJlKCcuL19iYXNlUHJvcGVydHlEZWVwJyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbXG4gKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAqIF07XG4gKlxuICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICogLy8gPT4gWzIsIDFdXG4gKlxuICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAqIC8vID0+IFsxLCAyXVxuICovXG5mdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHByb3BlcnR5O1xuIiwidmFyIGFycmF5RmlsdGVyID0gcmVxdWlyZSgnLi9fYXJyYXlGaWx0ZXInKSxcbiAgICBiYXNlRmlsdGVyID0gcmVxdWlyZSgnLi9fYmFzZUZpbHRlcicpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBuZWdhdGUgPSByZXF1aXJlKCcuL25lZ2F0ZScpO1xuXG4vKipcbiAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5maWx0ZXJgOyB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmBcbiAqIHRoYXQgYHByZWRpY2F0ZWAgZG9lcyAqKm5vdCoqIHJldHVybiB0cnV0aHkgZm9yLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqIEBzZWUgXy5maWx0ZXJcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9XG4gKiBdO1xuICpcbiAqIF8ucmVqZWN0KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5yZWplY3QodXNlcnMsIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLnJlamVjdCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8ucmVqZWN0KHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gKi9cbmZ1bmN0aW9uIHJlamVjdChjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBuZWdhdGUoYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZWplY3Q7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJBcnJheTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmdcbiAqIGtleWVkIHByb3BlcnRpZXMgb2YgYHZhbHVlYCB0byBvd24gcHJvcGVydGllcyBvZiB0aGUgcGxhaW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAqL1xuZnVuY3Rpb24gdG9QbGFpbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY29weU9iamVjdCh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9QbGFpbk9iamVjdDtcbiIsInZhciBiYXNlVG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlVG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU3RyaW5nO1xuIiwidmFyIGNyZWF0ZUNhc2VGaXJzdCA9IHJlcXVpcmUoJy4vX2NyZWF0ZUNhc2VGaXJzdCcpO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gdXBwZXIgY2FzZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy51cHBlckZpcnN0KCdmcmVkJyk7XG4gKiAvLyA9PiAnRnJlZCdcbiAqXG4gKiBfLnVwcGVyRmlyc3QoJ0ZSRUQnKTtcbiAqIC8vID0+ICdGUkVEJ1xuICovXG52YXIgdXBwZXJGaXJzdCA9IGNyZWF0ZUNhc2VGaXJzdCgndG9VcHBlckNhc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB1cHBlckZpcnN0O1xuIiwidmFyIGFzY2lpV29yZHMgPSByZXF1aXJlKCcuL19hc2NpaVdvcmRzJyksXG4gICAgaGFzVW5pY29kZVdvcmQgPSByZXF1aXJlKCcuL19oYXNVbmljb2RlV29yZCcpLFxuICAgIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpLFxuICAgIHVuaWNvZGVXb3JkcyA9IHJlcXVpcmUoJy4vX3VuaWNvZGVXb3JkcycpO1xuXG4vKipcbiAqIFNwbGl0cyBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbcGF0dGVybl0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggd29yZHMuXG4gKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcyddXG4gKlxuICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnLCAvW14sIF0rL2cpO1xuICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICcmJywgJ3BlYmJsZXMnXVxuICovXG5mdW5jdGlvbiB3b3JkcyhzdHJpbmcsIHBhdHRlcm4sIGd1YXJkKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIHBhdHRlcm4gPSBndWFyZCA/IHVuZGVmaW5lZCA6IHBhdHRlcm47XG5cbiAgaWYgKHBhdHRlcm4gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBoYXNVbmljb2RlV29yZChzdHJpbmcpID8gdW5pY29kZVdvcmRzKHN0cmluZykgOiBhc2NpaVdvcmRzKHN0cmluZyk7XG4gIH1cbiAgcmV0dXJuIHN0cmluZy5tYXRjaChwYXR0ZXJuKSB8fCBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3b3JkcztcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApIHtcclxuICBhcHAuY29uZmlnKFtcclxuICAgICdmb3JtaW9Db21wb25lbnRzUHJvdmlkZXInLFxyXG4gICAgZnVuY3Rpb24oZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyKSB7XHJcbiAgICAgIGZvcm1pb0NvbXBvbmVudHNQcm92aWRlci5yZWdpc3RlcignYWRkcmVzcycsIHtcclxuICAgICAgICBpY29uOiAnZmEgZmEtaG9tZScsXHJcbiAgICAgICAgdmlld3M6IFtcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0Rpc3BsYXknLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2FkZHJlc3MvZGlzcGxheS5odG1sJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1ZhbGlkYXRpb24nLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2FkZHJlc3MvdmFsaWRhdGUuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdBUEknLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9hcGkuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdMYXlvdXQnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9sYXlvdXQuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdDb25kaXRpb25hbCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY29tbW9uL2NvbmRpdGlvbmFsLmh0bWwnXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBkb2N1bWVudGF0aW9uOiAnaHR0cDovL2hlbHAuZm9ybS5pby91c2VyZ3VpZGUvI2FkZHJlc3MnXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIF0pO1xyXG4gIGFwcC5ydW4oW1xyXG4gICAgJyR0ZW1wbGF0ZUNhY2hlJyxcclxuICAgIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgICAgIC8vIENyZWF0ZSB0aGUgc2V0dGluZ3MgbWFya3VwLlxyXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL2FkZHJlc3MvZGlzcGxheS5odG1sJyxcclxuICAgICAgICAnPG5nLWZvcm0+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJsYWJlbFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInBsYWNlaG9sZGVyXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiY3VzdG9tQ2xhc3NcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJ0YWJpbmRleFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPicgK1xyXG4gICAgICAgICAgICAnPGxhYmVsIGZvcj1cIm1hcFJlZ2lvblwiIGZvcm0tYnVpbGRlci10b29sdGlwPVwiVGhlIHJlZ2lvbiBiaWFzIHRvIHVzZSBmb3IgdGhpcyBzZWFyY2guIFNlZSA8YSBocmVmPVxcJ2h0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL21hcHMvZG9jdW1lbnRhdGlvbi9nZW9jb2RpbmcvaW50cm8jUmVnaW9uQ29kZXNcXCcgdGFyZ2V0PVxcJ19ibGFua1xcJz5SZWdpb24gQmlhc2luZzwvYT4gZm9yIG1vcmUgaW5mb3JtYXRpb24uXCI+UmVnaW9uIEJpYXM8L2xhYmVsPicgK1xyXG4gICAgICAgICAgICAnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBpZD1cIm1hcFJlZ2lvblwiIG5hbWU9XCJtYXBSZWdpb25cIiBuZy1tb2RlbD1cImNvbXBvbmVudC5tYXAucmVnaW9uXCIgcGxhY2Vob2xkZXI9XCJEYWxsYXNcIiAvPicgK1xyXG4gICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgJzxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+JyArXHJcbiAgICAgICAgICAgICc8bGFiZWwgZm9yPVwibWFwS2V5XCIgZm9ybS1idWlsZGVyLXRvb2x0aXA9XCJUaGUgQVBJIGtleSBmb3IgR29vZ2xlIE1hcHMuIFNlZSA8YSBocmVmPVxcJ2h0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL21hcHMvZG9jdW1lbnRhdGlvbi9nZW9jb2RpbmcvZ2V0LWFwaS1rZXlcXCcgdGFyZ2V0PVxcJ19ibGFua1xcJz5HZXQgYW4gQVBJIEtleTwvYT4gZm9yIG1vcmUgaW5mb3JtYXRpb24uXCI+R29vZ2xlIE1hcHMgQVBJIEtleTwvbGFiZWw+JyArXHJcbiAgICAgICAgICAgICc8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwibWFwS2V5XCIgbmFtZT1cIm1hcEtleVwiIG5nLW1vZGVsPVwiY29tcG9uZW50Lm1hcC5rZXlcIiBwbGFjZWhvbGRlcj1cInh4eHh4eHh4eHh4eHh4eHh4eHgteHh4eHh4eHh4eHh4eHh4eHh4eFwiLz4nICtcclxuICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cIm11bHRpcGxlXCIgbGFiZWw9XCJBbGxvdyBNdWx0aXBsZSBBZGRyZXNzZXNcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJjbGVhck9uSGlkZVwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInByb3RlY3RlZFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInBlcnNpc3RlbnRcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJoaWRkZW5cIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJkaXNhYmxlZFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInRhYmxlVmlld1wiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAnPC9uZy1mb3JtPidcclxuICAgICAgKTtcclxuXHJcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvYWRkcmVzcy92YWxpZGF0ZS5odG1sJyxcclxuICAgICAgICAnPG5nLWZvcm0+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJ2YWxpZGF0ZS5yZXF1aXJlZFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInVuaXF1ZVwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAnPC9uZy1mb3JtPidcclxuICAgICAgKTtcclxuICAgIH1cclxuICBdKTtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwcCkge1xyXG4gIGFwcC5jb25maWcoW1xyXG4gICAgJ2Zvcm1pb0NvbXBvbmVudHNQcm92aWRlcicsXHJcbiAgICAnRk9STV9PUFRJT05TJyxcclxuICAgIGZ1bmN0aW9uKFxyXG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIsXHJcbiAgICAgIEZPUk1fT1BUSU9OU1xyXG4gICAgKSB7XHJcbiAgICAgIGZvcm1pb0NvbXBvbmVudHNQcm92aWRlci5yZWdpc3RlcignYnV0dG9uJywge1xyXG4gICAgICAgIG9uRWRpdDogWyckc2NvcGUnLCBmdW5jdGlvbigkc2NvcGUpIHtcclxuICAgICAgICAgICRzY29wZS5hY3Rpb25zID0gRk9STV9PUFRJT05TLmFjdGlvbnM7XHJcbiAgICAgICAgICAkc2NvcGUuc2l6ZXMgPSBGT1JNX09QVElPTlMuc2l6ZXM7XHJcbiAgICAgICAgICAkc2NvcGUudGhlbWVzID0gRk9STV9PUFRJT05TLnRoZW1lcztcclxuICAgICAgICB9XSxcclxuICAgICAgICBpY29uOiAnZmEgZmEtc3RvcCcsXHJcbiAgICAgICAgdmlld3M6IFtcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0Rpc3BsYXknLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2J1dHRvbi9kaXNwbGF5Lmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQVBJJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jb21tb24vYXBpLmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnTGF5b3V0JyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jb21tb24vbGF5b3V0Lmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQ29uZGl0aW9uYWwnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9jb25kaXRpb25hbC5odG1sJ1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgZG9jdW1lbnRhdGlvbjogJ2h0dHA6Ly9oZWxwLmZvcm0uaW8vdXNlcmd1aWRlLyNidXR0b24nXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIF0pO1xyXG4gIGFwcC5ydW4oW1xyXG4gICAgJyR0ZW1wbGF0ZUNhY2hlJyxcclxuICAgIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgICAgIC8vIENyZWF0ZSB0aGUgc2V0dGluZ3MgbWFya3VwLlxyXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL2J1dHRvbi9kaXNwbGF5Lmh0bWwnLFxyXG4gICAgICAgICc8bmctZm9ybT4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImxhYmVsXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+JyArXHJcbiAgICAgICAgICAgICc8bGFiZWwgZm9yPVwiYWN0aW9uXCIgZm9ybS1idWlsZGVyLXRvb2x0aXA9XCJUaGlzIGlzIHRoZSBhY3Rpb24gdG8gYmUgcGVyZm9ybWVkIGJ5IHRoaXMgYnV0dG9uLlwiPnt7XFwnQWN0aW9uXFwnIHzCoGZvcm1pb1RyYW5zbGF0ZX19PC9sYWJlbD4nICtcclxuICAgICAgICAgICAgJzxzZWxlY3QgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBpZD1cImFjdGlvblwiIG5hbWU9XCJhY3Rpb25cIiBuZy1vcHRpb25zPVwiYWN0aW9uLm5hbWUgYXMgYWN0aW9uLnRpdGxlIGZvciBhY3Rpb24gaW4gYWN0aW9uc1wiIG5nLW1vZGVsPVwiY29tcG9uZW50LmFjdGlvblwiPjwvc2VsZWN0PicgK1xyXG4gICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgJzxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCIgbmctaWY9XCJjb21wb25lbnQuYWN0aW9uID09PSBcXCdldmVudFxcJ1wiPicgK1xyXG4gICAgICAgICAgJyAgPGxhYmVsIGZvcj1cImV2ZW50XCIgZm9ybS1idWlsZGVyLXRvb2x0aXA9XCJUaGUgZXZlbnQgdG8gZmlyZSB3aGVuIHRoZSBidXR0b24gaXMgY2xpY2tlZC5cIj57e1xcJ0J1dHRvbiBFdmVudFxcJyB8wqBmb3JtaW9UcmFuc2xhdGV9fTwvbGFiZWw+JyArXHJcbiAgICAgICAgICAnICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwiZXZlbnRcIiBuYW1lPVwiZXZlbnRcIiBuZy1tb2RlbD1cImNvbXBvbmVudC5ldmVudFwiIHBsYWNlaG9sZGVyPVwiZXZlbnRcIiAvPicgK1xyXG4gICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgJzxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+JyArXHJcbiAgICAgICAgICAgICc8bGFiZWwgZm9yPVwidGhlbWVcIiBmb3JtLWJ1aWxkZXItdG9vbHRpcD1cIlRoZSBjb2xvciB0aGVtZSBvZiB0aGlzIHBhbmVsLlwiPnt7XFwnVGhlbWVcXCcgfMKgZm9ybWlvVHJhbnNsYXRlfX08L2xhYmVsPicgK1xyXG4gICAgICAgICAgICAnPHNlbGVjdCBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwidGhlbWVcIiBuYW1lPVwidGhlbWVcIiBuZy1vcHRpb25zPVwidGhlbWUubmFtZSBhcyB0aGVtZS50aXRsZSBmb3IgdGhlbWUgaW4gdGhlbWVzXCIgbmctbW9kZWw9XCJjb21wb25lbnQudGhlbWVcIj48L3NlbGVjdD4nICtcclxuICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPicgK1xyXG4gICAgICAgICAgICAnPGxhYmVsIGZvcj1cInNpemVcIiBmb3JtLWJ1aWxkZXItdG9vbHRpcD1cIlRoZSBzaXplIG9mIHRoaXMgYnV0dG9uLlwiPnt7XFwnU2l6ZVxcJyB8wqBmb3JtaW9UcmFuc2xhdGV9fTwvbGFiZWw+JyArXHJcbiAgICAgICAgICAgICc8c2VsZWN0IGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJzaXplXCIgbmFtZT1cInNpemVcIiBuZy1vcHRpb25zPVwic2l6ZS5uYW1lIGFzIHNpemUudGl0bGUgZm9yIHNpemUgaW4gc2l6ZXNcIiBuZy1tb2RlbD1cImNvbXBvbmVudC5zaXplXCI+PC9zZWxlY3Q+JyArXHJcbiAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJsZWZ0SWNvblwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInJpZ2h0SWNvblwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImN1c3RvbUNsYXNzXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwidGFiaW5kZXhcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJibG9ja1wiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImRpc2FibGVPbkludmFsaWRcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgJzwvbmctZm9ybT4nXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApIHtcclxuICBhcHAuY29uZmlnKFtcclxuICAgICdmb3JtaW9Db21wb25lbnRzUHJvdmlkZXInLFxyXG4gICAgZnVuY3Rpb24oZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyKSB7XHJcbiAgICAgIGZvcm1pb0NvbXBvbmVudHNQcm92aWRlci5yZWdpc3RlcignY2hlY2tib3gnLCB7XHJcbiAgICAgICAgaWNvbjogJ2ZhIGZhLWNoZWNrLXNxdWFyZScsXHJcbiAgICAgICAgb25FZGl0OiBbJyRzY29wZScsIGZ1bmN0aW9uKCRzY29wZSkge1xyXG4gICAgICAgICAgJHNjb3BlLmlucHV0VHlwZXMgPSBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBuYW1lOiAnY2hlY2tib3gnLFxyXG4gICAgICAgICAgICAgIHRpdGxlOiAnQ2hlY2tib3gnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBuYW1lOiAncmFkaW8nLFxyXG4gICAgICAgICAgICAgIHRpdGxlOiAnUmFkaW8nXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIF07XHJcbiAgICAgICAgfV0sXHJcbiAgICAgICAgdmlld3M6IFtcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0Rpc3BsYXknLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NoZWNrYm94L2Rpc3BsYXkuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdEYXRhJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jb21tb24vZGF0YS5odG1sJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1ZhbGlkYXRpb24nLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NoZWNrYm94L3ZhbGlkYXRlLmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQVBJJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jb21tb24vYXBpLmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnTGF5b3V0JyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jb21tb24vbGF5b3V0Lmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQ29uZGl0aW9uYWwnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9jb25kaXRpb25hbC5odG1sJ1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgZG9jdW1lbnRhdGlvbjogJ2h0dHA6Ly9oZWxwLmZvcm0uaW8vdXNlcmd1aWRlLyNjaGVja2JveCdcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbiAgYXBwLnJ1bihbXHJcbiAgICAnJHRlbXBsYXRlQ2FjaGUnLFxyXG4gICAgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAgICAgLy8gQ3JlYXRlIHRoZSBzZXR0aW5ncyBtYXJrdXAuXHJcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvY2hlY2tib3gvZGlzcGxheS5odG1sJyxcclxuICAgICAgICAnPG5nLWZvcm0+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJsYWJlbFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPicgK1xyXG4gICAgICAgICAgICAnPGxhYmVsIGZvcj1cImlucHV0VHlwZVwiIGZvcm0tYnVpbGRlci10b29sdGlwPVwiVGhpcyBpcyB0aGUgaW5wdXQgdHlwZSB1c2VkIGZvciB0aGlzIGNoZWNrYm94LlwiPklucHV0IFR5cGU8L2xhYmVsPicgK1xyXG4gICAgICAgICAgICAnPHNlbGVjdCBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwiaW5wdXRUeXBlXCIgbmFtZT1cImlucHV0VHlwZVwiIG5nLW9wdGlvbnM9XCJpbnB1dFR5cGUubmFtZSBhcyBpbnB1dFR5cGUudGl0bGUgZm9yIGlucHV0VHlwZSBpbiBpbnB1dFR5cGVzXCIgbmctbW9kZWw9XCJjb21wb25lbnQuaW5wdXRUeXBlXCI+PC9zZWxlY3Q+JyArXHJcbiAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAnPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIiBuZy1pZj1cImNvbXBvbmVudC5pbnB1dFR5cGUgPT09IFxcJ3JhZGlvXFwnXCI+JyArXHJcbiAgICAgICAgICAnICA8bGFiZWwgZm9yPVwibmFtZVwiIGZvcm0tYnVpbGRlci10b29sdGlwPVwiVGhlIGtleSB1c2VkIHRvIHRyaWdnZXIgdGhlIHJhZGlvIGJ1dHRvbiB0b2dnbGUuXCI+UmFkaW8gS2V5PC9sYWJlbD4nICtcclxuICAgICAgICAgICcgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJuYW1lXCIgbmFtZT1cIm5hbWVcIiBuZy1tb2RlbD1cImNvbXBvbmVudC5uYW1lXCIgcGxhY2Vob2xkZXI9XCJ7eyBjb21wb25lbnQua2V5IH19XCIgLz4nICtcclxuICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiIG5nLWlmPVwiY29tcG9uZW50LmlucHV0VHlwZSA9PT0gXFwncmFkaW9cXCdcIj4nICtcclxuICAgICAgICAgICcgIDxsYWJlbCBmb3I9XCJ2YWx1ZVwiIGZvcm0tYnVpbGRlci10b29sdGlwPVwiVGhlIHZhbHVlIHVzZWQgd2l0aCB0aGlzIHJhZGlvIGJ1dHRvbi5cIj5SYWRpbyBWYWx1ZTwvbGFiZWw+JyArXHJcbiAgICAgICAgICAnICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwidmFsdWVcIiBuYW1lPVwidmFsdWVcIiBuZy1tb2RlbD1cImNvbXBvbmVudC52YWx1ZVwiIHBsYWNlaG9sZGVyPVwie3sgY29tcG9uZW50LnZhbHVlIH19XCIgLz4nICtcclxuICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImRhdGFncmlkTGFiZWxcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJjdXN0b21DbGFzc1wiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInRhYmluZGV4XCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiY2xlYXJPbkhpZGVcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJwcm90ZWN0ZWRcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJwZXJzaXN0ZW50XCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiaGlkZGVuXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiZGlzYWJsZWRcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJ0YWJsZVZpZXdcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgJzwvbmctZm9ybT4nXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL2NoZWNrYm94L3ZhbGlkYXRlLmh0bWwnLFxyXG4gICAgICAgICc8bmctZm9ybT4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInZhbGlkYXRlLnJlcXVpcmVkXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uLWN1c3RvbS12YWxpZGF0aW9uPjwvZm9ybS1idWlsZGVyLW9wdGlvbi1jdXN0b20tdmFsaWRhdGlvbj4nICtcclxuICAgICAgICAnPC9uZy1mb3JtPidcclxuICAgICAgKTtcclxuICAgIH1cclxuICBdKTtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwcCkge1xyXG4gIGFwcC5jb25maWcoW1xyXG4gICAgJ2Zvcm1pb0NvbXBvbmVudHNQcm92aWRlcicsXHJcbiAgICBmdW5jdGlvbihmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIpIHtcclxuICAgICAgZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyLnJlZ2lzdGVyKCdjb2x1bW5zJywge1xyXG4gICAgICAgIG9uRWRpdDogWyckc2NvcGUnLCBmdW5jdGlvbigkc2NvcGUpIHtcclxuICAgICAgICAgICRzY29wZS5yZW1vdmVDb2x1bW4gPSBmdW5jdGlvbihpbmRleCkge1xyXG4gICAgICAgICAgICAkc2NvcGUuY29tcG9uZW50LmNvbHVtbnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgICAkc2NvcGUuYWRkQ29sdW1uID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICRzY29wZS5jb21wb25lbnQuY29sdW1ucy5wdXNoKHtjb21wb25lbnRzOiBbXSwgd2lkdGg6IDEsIG9mZnNldDogMCwgcHVzaDogMCwgcHVsbDogMH0pO1xyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XSxcclxuICAgICAgICBmYnRlbXBsYXRlOiAnZm9ybWlvL2Zvcm1idWlsZGVyL2NvbHVtbnMuaHRtbCcsXHJcbiAgICAgICAgaWNvbjogJ2ZhIGZhLWNvbHVtbnMnLFxyXG4gICAgICAgIGRvY3VtZW50YXRpb246ICdodHRwOi8vaGVscC5mb3JtLmlvL3VzZXJndWlkZS8jY29sdW1ucycsXHJcbiAgICAgICAgbm9EbmRPdmVybGF5OiB0cnVlLFxyXG4gICAgICAgIGNvbmZpcm1SZW1vdmU6IHRydWUsXHJcbiAgICAgICAgdmlld3M6IFtcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0Rpc3BsYXknLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbHVtbnMvZGlzcGxheS5odG1sJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0FQSScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY29tbW9uL2FwaS5odG1sJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0NvbmRpdGlvbmFsJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jb21tb24vY29uZGl0aW9uYWwuaHRtbCdcclxuICAgICAgICAgIH1cclxuICAgICAgICBdXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIF0pO1xyXG4gIGFwcC5ydW4oW1xyXG4gICAgJyR0ZW1wbGF0ZUNhY2hlJyxcclxuICAgIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2Zvcm1idWlsZGVyL2NvbHVtbnMuaHRtbCcsXHJcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJyb3dcIj4nICtcclxuICAgICAgICAgICc8ZGl2IG5nLXNob3c9XCJjb2x1bW4ud2lkdGhcIiBuZy1jbGFzcz1cIlxcJ2NvbC14cy1cXCcgKyBjb2x1bW4ud2lkdGggKyBcXCcgY29sLXhzLW9mZnNldC1cXCcgKyBjb2x1bW4ub2Zmc2V0ICsgXFwnIGNvbC14cy1wdXNoLVxcJyArIGNvbHVtbi5wdXNoICsgXFwnIGNvbC14cy1wdWxsLVxcJyArIGNvbHVtbi5wdWxsXCIgY29tcG9uZW50LWZvcm0tZ3JvdXBcIiBuZy1yZXBlYXQ9XCJjb2x1bW4gaW4gY29tcG9uZW50LmNvbHVtbnNcIj4nICtcclxuICAgICAgICAgICAgJzxmb3JtLWJ1aWxkZXItbGlzdCBjbGFzcz1cImZvcm1pby1jb2x1bW5cIiBjb21wb25lbnQ9XCJjb2x1bW5cIiBmb3JtPVwiZm9ybVwiIGZvcm1pbz1cIjo6Zm9ybWlvXCI+PC9mb3JtLWJ1aWxkZXItbGlzdD4nICtcclxuICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAnPC9kaXY+J1xyXG4gICAgICApO1xyXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL2NvbHVtbnMvZGlzcGxheS5odG1sJyxcclxuICAgICAgICAnPG5nLWZvcm0+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJjdXN0b21DbGFzc1wiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPicgK1xyXG4gICAgICAgICAgICAnPGxhYmVsIGZvcm0tYnVpbGRlci10b29sdGlwPVwiVGhlIHdpZHRoLCBvZmZzZXQsIHB1c2ggYW5kIHB1bGwgc2V0dGluZ3MgZm9yIHRoZSBjb2x1bW5zXCI+e3tcXCdDb2x1bW4gUHJvcGVydGllc1xcJyB8wqBmb3JtaW9UcmFuc2xhdGV9fTwvbGFiZWw+JyArXHJcbiAgICAgICAgICAgICc8dGFibGUgY2xhc3M9XCJ0YWJsZSB0YWJsZS1jb25kZW5zZWRcIj4nICtcclxuICAgICAgICAgICAgICAnPHRoZWFkPicgK1xyXG4gICAgICAgICAgICAgICAgJzx0cj4nICtcclxuICAgICAgICAgICAgICAgICAgJzx0aCBjbGFzcz1cImNvbC14cy0yXCI+e3tcXCdDb2x1bW5cXCcgfMKgZm9ybWlvVHJhbnNsYXRlfX08L3RoPicgK1xyXG4gICAgICAgICAgICAgICAgICAnPHRoIGNsYXNzPVwiY29sLXhzLTJcIj57e1xcJ1dpZHRoXFwnIHzCoGZvcm1pb1RyYW5zbGF0ZX19PC90aD4nICtcclxuICAgICAgICAgICAgICAgICAgJzx0aCBjbGFzcz1cImNvbC14cy0yXCI+e3tcXCdPZmZzZXRcXCcgfMKgZm9ybWlvVHJhbnNsYXRlfX08L3RoPicgK1xyXG4gICAgICAgICAgICAgICAgICAnPHRoIGNsYXNzPVwiY29sLXhzLTJcIj57e1xcJ1B1c2hcXCcgfMKgZm9ybWlvVHJhbnNsYXRlfX08L3RoPicgK1xyXG4gICAgICAgICAgICAgICAgICAnPHRoIGNsYXNzPVwiY29sLXhzLTJcIj57e1xcJ1B1bGxcXCcgfMKgZm9ybWlvVHJhbnNsYXRlfX08L3RoPicgK1xyXG4gICAgICAgICAgICAgICAgICAnPHRoIGNsYXNzPVwiY29sLXhzLTFcIj48L3RoPicgK1xyXG4gICAgICAgICAgICAgICAgJzwvdHI+JyArXHJcbiAgICAgICAgICAgICAgJzwvdGhlYWQ+JyArXHJcbiAgICAgICAgICAgICAgJzx0Ym9keT4nICtcclxuICAgICAgICAgICAgICAgICc8dHIgbmctcmVwZWF0PVwiY29sdW1uIGluIGNvbXBvbmVudC5jb2x1bW5zIHRyYWNrIGJ5ICRpbmRleFwiPicgK1xyXG4gICAgICAgICAgICAgICAgICAnPHRkIGNsYXNzPVwiY29sLXhzLTJcIj48aW5wdXQgdHlwZT1cIm51bWJlclwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgbmctdmFsdWU9XCIkaW5kZXggKyAxXCIgZGlzYWJsZWQvPjwvdGQ+JyArXHJcbiAgICAgICAgICAgICAgICAgICc8dGQgY2xhc3M9XCJjb2wteHMtMlwiPjxpbnB1dCB0eXBlPVwibnVtYmVyXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBtaW49XCIwXCIgbWF4PVwiMTJcIiBuZy1tb2RlbD1cImNvbHVtbi53aWR0aFwiLz48L3RkPicgK1xyXG4gICAgICAgICAgICAgICAgICAnPHRkIGNsYXNzPVwiY29sLXhzLTJcIj48aW5wdXQgdHlwZT1cIm51bWJlclwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgbWluPVwiMFwiIG1heD1cIjEyXCIgbmctbW9kZWw9XCJjb2x1bW4ub2Zmc2V0XCIvPjwvdGQ+JyArXHJcbiAgICAgICAgICAgICAgICAgICc8dGQgY2xhc3M9XCJjb2wteHMtMlwiPjxpbnB1dCB0eXBlPVwibnVtYmVyXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBtaW49XCIwXCIgbWF4PVwiMTJcIiBuZy1tb2RlbD1cImNvbHVtbi5wdXNoXCIvPjwvdGQ+JyArXHJcbiAgICAgICAgICAgICAgICAgICc8dGQgY2xhc3M9XCJjb2wteHMtMlwiPjxpbnB1dCB0eXBlPVwibnVtYmVyXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBtaW49XCIwXCIgbWF4PVwiMTJcIiBuZy1tb2RlbD1cImNvbHVtbi5wdWxsXCIvPjwvdGQ+JyArXHJcbiAgICAgICAgICAgICAgICAgICc8dGQgY2xhc3M9XCJjb2wteHMtMVwiPjxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1kYW5nZXIgYnRuLXhzXCIgbmctY2xpY2s9XCJyZW1vdmVDb2x1bW4oJGluZGV4KVwiIHRhYmluZGV4PVwiLTFcIj48c3BhbiBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tcmVtb3ZlLWNpcmNsZVwiPjwvc3Bhbj48L2J1dHRvbj48L3RkPicgK1xyXG4gICAgICAgICAgICAgICAgJzwvdHI+JyArXHJcbiAgICAgICAgICAgICAgJzwvdGJvZHk+JyArXHJcbiAgICAgICAgICAgICc8L3RhYmxlPicgK1xyXG4gICAgICAgICAgICAnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG5cIiBuZy1jbGljaz1cImFkZENvbHVtbigpXCI+e3tcXCdBZGQgQ29sdW1uXFwnIHzCoGZvcm1pb1RyYW5zbGF0ZX19PC9idXR0b24+JyArXHJcbiAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgJzwvbmctZm9ybT4nXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApIHtcclxuICBhcHAucnVuKFtcclxuICAgICckdGVtcGxhdGVDYWNoZScsXHJcbiAgICBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICAgICAvLyBDcmVhdGUgdGhlIGNvbXBvbmVudCBtYXJrdXAuXHJcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvc2V0dGluZ3MuaHRtbCcsXHJcbiAgICAgICAgJzxmb3JtIGlkPVwiY29tcG9uZW50LXNldHRpbmdzXCIgbm92YWxpZGF0ZT4nICtcclxuICAgICAgICAgICc8ZGl2IGNsYXNzPVwicm93XCI+JyArXHJcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiY29sLW1kLTZcIj4nICtcclxuICAgICAgICAgICAgICAnPHAgY2xhc3M9XCJsZWFkXCIgbmctaWY9XCI6OmZvcm1Db21wb25lbnQudGl0bGVcIiBzdHlsZT1cIm1hcmdpbi10b3A6MTBweDtcIj57ezo6Zm9ybUNvbXBvbmVudC50aXRsZX19IHt7XFwnQ29tcG9uZW50XFwnIHzCoGZvcm1pb1RyYW5zbGF0ZX19PC9wPicgK1xyXG4gICAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiY29sLW1kLTZcIj4nICtcclxuICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cInB1bGwtcmlnaHRcIiBuZy1pZj1cIjo6Zm9ybUNvbXBvbmVudC5kb2N1bWVudGF0aW9uXCIgc3R5bGU9XCJtYXJnaW4tdG9wOjEwcHg7IG1hcmdpbi1yaWdodDoyMHB4O1wiPicgK1xyXG4gICAgICAgICAgICAgICAgJzxhIG5nLWhyZWY9XCJ7eyA6OmZvcm1Db21wb25lbnQuZG9jdW1lbnRhdGlvbiB9fVwiIHRhcmdldD1cIl9ibGFua1wiPjxpIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1uZXctd2luZG93XCI+PC9pPiB7e1xcJ0hlbHAhXFwnIHzCoGZvcm1pb1RyYW5zbGF0ZX19PC9hPicgK1xyXG4gICAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgJzxkaXYgY2xhc3M9XCJyb3dcIj4nICtcclxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJjb2wteHMtNlwiPicgK1xyXG4gICAgICAgICAgICAgICc8dWliLXRhYnNldD4nICtcclxuICAgICAgICAgICAgICAgICc8dWliLXRhYiBuZy1yZXBlYXQ9XCJ2aWV3IGluIDo6Zm9ybUNvbXBvbmVudC52aWV3c1wiIGhlYWRpbmc9XCJ7eyA6OnZpZXcubmFtZSB8wqBmb3JtaW9UcmFuc2xhdGUgfX1cIj48bmctaW5jbHVkZSBzcmM9XCI6OnZpZXcudGVtcGxhdGVcIj48L25nLWluY2x1ZGU+PC91aWItdGFiPicgK1xyXG4gICAgICAgICAgICAgICc8L3VpYi10YWJzZXQ+JyArXHJcbiAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJjb2wteHMtNlwiPicgK1xyXG4gICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwicGFuZWwgcGFuZWwtZGVmYXVsdCBwcmV2aWV3LXBhbmVsXCIgc3R5bGU9XCJtYXJnaW4tdG9wOjQ0cHg7XCI+JyArXHJcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cInBhbmVsLWhlYWRpbmdcIj57e1xcJ1ByZXZpZXdcXCcgfMKgZm9ybWlvVHJhbnNsYXRlfX08L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwicGFuZWwtYm9keVwiPicgK1xyXG4gICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIiBuZy1pZj1cImNvbXBvbmVudC53eXNpd3lnICYmIGVkaXRvclZpc2libGVcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPGxhYmVsIGZvcj1cImVkaXRvci1wcmV2aWV3XCIgY2xhc3M9XCJjb250cm9sLWxhYmVsXCIgbmctaWY9XCJjb21wb25lbnQubGFiZWxcIj57eyBjb21wb25lbnQubGFiZWwgfX08L2xhYmVsPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8dGV4dGFyZWEgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBpZD1cImVkaXRvci1wcmV2aWV3XCIgbmctaWY9XCJjb21wb25lbnQud3lzaXd5ZyAmJiBlZGl0b3JWaXNpYmxlXCIgY2tlZGl0b3I9XCJjb21wb25lbnQud3lzaXd5Z1wiPjwvdGV4dGFyZWE+JyArXHJcbiAgICAgICAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICAgJzxmb3JtaW8tY29tcG9uZW50IG5nLWlmPVwiIWNvbXBvbmVudC53eXNpd3lnXCIgY29tcG9uZW50PVwiY29tcG9uZW50XCIgZGF0YT1cInt9XCIgZm9ybWlvPVwiOjpmb3JtaW9cIj48L2Zvcm1pby1jb21wb25lbnQ+JyArXHJcbiAgICAgICAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICc8Zm9ybWlvLXNldHRpbmdzLWluZm8gY29tcG9uZW50PVwiY29tcG9uZW50XCIgZGF0YT1cInt9XCIgZm9ybWlvPVwiOjpmb3JtaW9cIj48L2Zvcm1pby1zZXR0aW5ncy1pbmZvPicgK1xyXG4gICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPicgK1xyXG4gICAgICAgICAgICAgICAgJzxidXR0b24gdHlwZT1cInN1Ym1pdFwiIGNsYXNzPVwiYnRuIGJ0bi1zdWNjZXNzXCIgbmctY2xpY2s9XCJjbG9zZVRoaXNEaWFsb2codHJ1ZSlcIj57e1xcJ1NhdmVcXCcgfMKgZm9ybWlvVHJhbnNsYXRlfX08L2J1dHRvbj4mbmJzcDsnICtcclxuICAgICAgICAgICAgICAgICc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tZGVmYXVsdFwiIG5nLWNsaWNrPVwiY2xvc2VUaGlzRGlhbG9nKGZhbHNlKVwiIG5nLWlmPVwiIWNvbXBvbmVudC5pc05ld1wiPnt7XFwnQ2FuY2VsXFwnIHzCoGZvcm1pb1RyYW5zbGF0ZX19PC9idXR0b24+Jm5ic3A7JyArXHJcbiAgICAgICAgICAgICAgICAnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLWRhbmdlclwiIG5nLWNsaWNrPVwicmVtb3ZlQ29tcG9uZW50KGNvbXBvbmVudCwgZm9ybUNvbXBvbmVudHNbY29tcG9uZW50LnR5cGVdLmNvbmZpcm1SZW1vdmUpOyBjbG9zZVRoaXNEaWFsb2coZmFsc2UpXCI+e3tcXCdSZW1vdmVcXCcgfMKgZm9ybWlvVHJhbnNsYXRlfX08L2J1dHRvbj4nICtcclxuICAgICAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAnPC9mb3JtPidcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIENyZWF0ZSB0aGUgY29tbW9uIEFQSSB0YWIgbWFya3VwLlxyXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9kYXRhLmh0bWwnLFxyXG4gICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImRlZmF1bHRWYWx1ZVwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAnPHVpYi1hY2NvcmRpb24+JyArXHJcbiAgICAgICAgJyAgPGRpdiB1aWItYWNjb3JkaW9uLWdyb3VwIGhlYWRpbmc9XCJDdXN0b20gRGVmYXVsdCBWYWx1ZVwiIGNsYXNzPVwicGFuZWwgcGFuZWwtZGVmYXVsdFwiPicgK1xyXG4gICAgICAgICcgICAgPHVpYi1hY2NvcmRpb24+JyArXHJcbiAgICAgICAgJyAgICAgIDxkaXYgdWliLWFjY29yZGlvbi1ncm91cCBoZWFkaW5nPVwiSmF2YVNjcmlwdCBEZWZhdWx0XCIgY2xhc3M9XCJwYW5lbCBwYW5lbC1kZWZhdWx0XCIgaXMtb3Blbj1cInRydWVcIj4nICtcclxuICAgICAgICAnICAgICAgICA8dGV4dGFyZWEgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiByb3dzPVwiNVwiIGlkPVwiY3VzdG9tRGVmYXVsdFZhbHVlXCIgbmFtZT1cImN1c3RvbURlZmF1bHRWYWx1ZVwiIG5nLW1vZGVsPVwiY29tcG9uZW50LmN1c3RvbURlZmF1bHRWYWx1ZVwiIHBsYWNlaG9sZGVyPVwiLyoqKiBFeGFtcGxlIENvZGUgKioqL1xcbnZhbHVlID0gZGF0YVtcXCdteWtleVxcJ10gKyBkYXRhW1xcJ2Fub3RoZXJLZXlcXCddO1wiPjwvdGV4dGFyZWE+JyArXHJcbiAgICAgICAgJyAgICAgICAgPHNtYWxsPicgK1xyXG4gICAgICAgICcgICAgICAgICAgPHA+RW50ZXIgY3VzdG9tIGRlZmF1bHQgdmFsdWUgY29kZS48L3A+JyArXHJcbiAgICAgICAgJyAgICAgICAgICA8cD5Zb3UgbXVzdCBhc3NpZ24gdGhlIDxzdHJvbmc+dmFsdWU8L3N0cm9uZz4gdmFyaWFibGUgYXMgdGhlIHJlc3VsdCB5b3Ugd2FudCBmb3IgdGhlIGRlZmF1bHQgdmFsdWUuPC9wPicgK1xyXG4gICAgICAgICcgICAgICAgICAgPHA+VGhlIGdsb2JhbCB2YXJpYWJsZSA8c3Ryb25nPmRhdGE8L3N0cm9uZz4gaXMgcHJvdmlkZWQsIGFuZCBhbGxvd3MgeW91IHRvIGFjY2VzcyB0aGUgZGF0YSBvZiBhbnkgZm9ybSBjb21wb25lbnQsIGJ5IHVzaW5nIGl0cyBBUEkga2V5LjwvcD4nICtcclxuICAgICAgICAnICAgICAgICAgIDxwPkRlZmF1bHQgVmFsdWVzIGFyZSBvbmx5IGNhbGN1bGF0ZWQgb24gZm9ybSBsb2FkLiBVc2UgQ2FsY3VsYXRlZCBWYWx1ZSBmb3IgYSB2YWx1ZSB0aGF0IHdpbGwgdXBkYXRlIHdpdGggdGhlIGZvcm0uPC9wPicgK1xyXG4gICAgICAgICcgICAgICAgIDwvc21hbGw+JyArXHJcbiAgICAgICAgJyAgICAgIDwvZGl2PicgK1xyXG4gICAgICAgICcgICAgICA8ZGl2IHVpYi1hY2NvcmRpb24tZ3JvdXAgaGVhZGluZz1cIkpTT05Mb2dpYyBEZWZhdWx0XCIgY2xhc3M9XCJwYW5lbCBwYW5lbC1kZWZhdWx0XCI+JyArXHJcbiAgICAgICAgJyAgICAgICAgPHNtYWxsPicgK1xyXG4gICAgICAgICcgICAgICAgICAgPHA+RXhlY3V0ZSBjdXN0b20gZGVmYXVsdCB2YWx1ZSB1c2luZyA8YSBocmVmPVwiaHR0cDovL2pzb25sb2dpYy5jb20vXCI+SlNPTkxvZ2ljPC9hPi48L3A+JyArXHJcbiAgICAgICAgJyAgICAgICAgICA8cD5TdWJtaXNzaW9uIGRhdGEgaXMgYXZhaWxhYmxlIGFzIEpzb25Mb2dpYyB2YXJpYWJsZXMsIHdpdGggdGhlIHNhbWUgYXBpIGtleSBhcyB5b3VyIGNvbXBvbmVudHMuPC9wPicgK1xyXG4gICAgICAgICcgICAgICAgICAgPHA+PGEgaHJlZj1cImh0dHA6Ly9mb3JtaW8uZ2l0aHViLmlvL2Zvcm1pby5qcy9hcHAvZXhhbXBsZXMvY2FsY3VsYXRlZC5odG1sXCIgdGFyZ2V0PVwiX2JsYW5rXCI+Q2xpY2sgaGVyZSBmb3IgYW4gZXhhbXBsZTwvYT48L3A+JyArXHJcbiAgICAgICAgJyAgICAgICAgPC9zbWFsbD4nICtcclxuICAgICAgICAnICAgICAgICA8dGV4dGFyZWEgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiByb3dzPVwiNVwiIGlkPVwianNvblwiIG5hbWU9XCJqc29uXCIganNvbi1pbnB1dCBuZy1tb2RlbD1cImNvbXBvbmVudC5jdXN0b21EZWZhdWx0VmFsdWVcIiBwbGFjZWhvbGRlcj1cXCd7IC4uLiB9XFwnPjwvdGV4dGFyZWE+JyArXHJcbiAgICAgICAgJyAgICAgIDwvZGl2PicgK1xyXG4gICAgICAgICcgICAgPC91aWItYWNjb3JkaW9uPicgK1xyXG4gICAgICAgICcgIDwvZGl2PicgK1xyXG4gICAgICAgICcgIDxkaXYgdWliLWFjY29yZGlvbi1ncm91cCBoZWFkaW5nPVwiQ2FsY3VsYXRlZCBWYWx1ZVwiIGNsYXNzPVwicGFuZWwgcGFuZWwtZGVmYXVsdFwiPicgK1xyXG4gICAgICAgICcgICAgPHVpYi1hY2NvcmRpb24+JyArXHJcbiAgICAgICAgJyAgICAgIDxkaXYgdWliLWFjY29yZGlvbi1ncm91cCBoZWFkaW5nPVwiSmF2YVNjcmlwdCBWYWx1ZVwiIGNsYXNzPVwicGFuZWwgcGFuZWwtZGVmYXVsdFwiIGlzLW9wZW49XCJ0cnVlXCI+JyArXHJcbiAgICAgICAgJyAgICAgICAgPHRleHRhcmVhIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgcm93cz1cIjVcIiBpZD1cImNhbGN1bGF0ZVZhbHVlXCIgbmFtZT1cImNhbGN1bGF0ZVZhbHVlXCIgbmctbW9kZWw9XCJjb21wb25lbnQuY2FsY3VsYXRlVmFsdWVcIiBwbGFjZWhvbGRlcj1cIi8qKiogRXhhbXBsZSBDb2RlICoqKi9cXG52YWx1ZSA9IGRhdGFbXFwnbXlrZXlcXCddICsgZGF0YVtcXCdhbm90aGVyS2V5XFwnXTtcIj48L3RleHRhcmVhPicgK1xyXG4gICAgICAgICcgICAgICAgIDxzbWFsbD4nICtcclxuICAgICAgICAnICAgICAgICAgIDxwPkVudGVyIGNvZGUgdG8gY2FsY3VsYXRlIGEgdmFsdWUuPC9wPicgK1xyXG4gICAgICAgICcgICAgICAgICAgPHA+WW91IG11c3QgYXNzaWduIHRoZSA8c3Ryb25nPnZhbHVlPC9zdHJvbmc+IHZhcmlhYmxlIGFzIHRoZSByZXN1bHQgeW91IHdhbnQgZm9yIHRoZSBkZWZhdWx0IHZhbHVlLjwvcD4nICtcclxuICAgICAgICAnICAgICAgICAgIDxwPlRoZSBnbG9iYWwgdmFyaWFibGUgPHN0cm9uZz5kYXRhPC9zdHJvbmc+IGlzIHByb3ZpZGVkLCBhbmQgYWxsb3dzIHlvdSB0byBhY2Nlc3MgdGhlIGRhdGEgb2YgYW55IGZvcm0gY29tcG9uZW50LCBieSB1c2luZyBpdHMgQVBJIGtleS48L3A+JyArXHJcbiAgICAgICAgJyAgICAgICAgPC9zbWFsbD4nICtcclxuICAgICAgICAnICAgICAgPC9kaXY+JyArXHJcbiAgICAgICAgJyAgICAgIDxkaXYgdWliLWFjY29yZGlvbi1ncm91cCBoZWFkaW5nPVwiSlNPTkxvZ2ljIFZhbHVlXCIgY2xhc3M9XCJwYW5lbCBwYW5lbC1kZWZhdWx0XCI+JyArXHJcbiAgICAgICAgJyAgICAgICAgPHNtYWxsPicgK1xyXG4gICAgICAgICcgICAgICAgICAgPHA+RXhlY3V0ZSBjdXN0b20gY2FsY3VsYXRpb24gbG9naWMgd2l0aCBKU09OIGFuZCA8YSBocmVmPVwiaHR0cDovL2pzb25sb2dpYy5jb20vXCI+SlNPTkxvZ2ljPC9hPi48L3A+JyArXHJcbiAgICAgICAgJyAgICAgICAgICA8cD5TdWJtaXNzaW9uIGRhdGEgaXMgYXZhaWxhYmxlIGFzIEpzb25Mb2dpYyB2YXJpYWJsZXMsIHdpdGggdGhlIHNhbWUgYXBpIGtleSBhcyB5b3VyIGNvbXBvbmVudHMuPC9wPicgK1xyXG4gICAgICAgICcgICAgICAgICAgPHA+PGEgaHJlZj1cImh0dHA6Ly9mb3JtaW8uZ2l0aHViLmlvL2Zvcm1pby5qcy9hcHAvZXhhbXBsZXMvY2FsY3VsYXRlZC5odG1sXCIgdGFyZ2V0PVwiX2JsYW5rXCI+Q2xpY2sgaGVyZSBmb3IgYW4gZXhhbXBsZTwvYT48L3A+JyArXHJcbiAgICAgICAgJyAgICAgICAgPC9zbWFsbD4nICtcclxuICAgICAgICAnICAgICAgICA8dGV4dGFyZWEgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiByb3dzPVwiNVwiIGlkPVwianNvblwiIG5hbWU9XCJqc29uXCIganNvbi1pbnB1dCBuZy1tb2RlbD1cImNvbXBvbmVudC5jYWxjdWxhdGVWYWx1ZVwiIHBsYWNlaG9sZGVyPVxcJ3sgLi4uIH1cXCc+PC90ZXh0YXJlYT4nICtcclxuICAgICAgICAnICAgICAgPC9kaXY+JyArXHJcbiAgICAgICAgJyAgICA8L3VpYi1hY2NvcmRpb24+JyArXHJcbiAgICAgICAgJyAgPC9kaXY+JyArXHJcbiAgICAgICAgJzwvdWliLWFjY29yZGlvbj4nXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBDcmVhdGUgdGhlIGNvbW1vbiBBUEkgdGFiIG1hcmt1cC5cclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9jb21tb24vYXBpLmh0bWwnLFxyXG4gICAgICAgICc8bmctZm9ybT4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbi1rZXk+PC9mb3JtLWJ1aWxkZXItb3B0aW9uLWtleT4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbi10YWdzPjwvZm9ybS1idWlsZGVyLW9wdGlvbi10YWdzPicgK1xyXG4gICAgICAgICc8L25nLWZvcm0+J1xyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gQ3JlYXRlIHRoZSBjb21tb24gTGF5b3V0IHRhYiBtYXJrdXAuXHJcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvY29tbW9uL2xheW91dC5odG1sJyxcclxuICAgICAgICAnPG5nLWZvcm0+JyArXHJcbiAgICAgICAgICAvLyBOZWVkIHRvIHVzZSBhcnJheSBub3RhdGlvbiB0byBoYXZlIGRhc2ggaW4gbmFtZVxyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwic3R5bGVbXFwnbWFyZ2luLXRvcFxcJ11cIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJzdHlsZVtcXCdtYXJnaW4tcmlnaHRcXCddXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwic3R5bGVbXFwnbWFyZ2luLWJvdHRvbVxcJ11cIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJzdHlsZVtcXCdtYXJnaW4tbGVmdFxcJ11cIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPHVpYi1hY2NvcmRpb24+JyArXHJcbiAgICAgICAgICAnICA8ZGl2IHVpYi1hY2NvcmRpb24tZ3JvdXAgaGVhZGluZz1cIk92ZXJsYXlcIiBjbGFzcz1cInBhbmVsIHBhbmVsLWRlZmF1bHRcIj4nICtcclxuICAgICAgICAgICcgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj4nICtcclxuICAgICAgICAgICcgICAgICA8bGFiZWwgZm9yPVwib3ZlcmxheS1zdHlsZVwiPlN0eWxlPC9sYWJlbD4nICtcclxuICAgICAgICAgICcgICAgICA8aW5wdXQgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBpZD1cIm92ZXJsYXktc3R5bGVcIiBuYW1lPVwib3ZlcmxheS1zdHlsZVwiIG5nLW1vZGVsPVwiY29tcG9uZW50Lm92ZXJsYXkuc3R5bGVcIj48L2lucHV0PicgK1xyXG4gICAgICAgICAgJyAgICA8L2Rpdj4nICtcclxuICAgICAgICAgICcgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj4nICtcclxuICAgICAgICAgICcgICAgICA8bGFiZWwgZm9yPVwib3ZlcmxheS1sZWZ0XCI+TGVmdDwvbGFiZWw+JyArXHJcbiAgICAgICAgICAnICAgICAgPGlucHV0IGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJvdmVybGF5LWxlZnRcIiBuYW1lPVwib3ZlcmxheS1sZWZ0XCIgbmctbW9kZWw9XCJjb21wb25lbnQub3ZlcmxheS5sZWZ0XCI+PC9pbnB1dD4nICtcclxuICAgICAgICAgICcgICAgPC9kaXY+JyArXHJcbiAgICAgICAgICAnICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+JyArXHJcbiAgICAgICAgICAnICAgICAgPGxhYmVsIGZvcj1cIm92ZXJsYXktcmlnaHRcIj5Ub3A8L2xhYmVsPicgK1xyXG4gICAgICAgICAgJyAgICAgIDxpbnB1dCBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwib3ZlcmxheS10b3BcIiBuYW1lPVwib3ZlcmxheS10b3BcIiBuZy1tb2RlbD1cImNvbXBvbmVudC5vdmVybGF5LnRvcFwiPjwvaW5wdXQ+JyArXHJcbiAgICAgICAgICAnICAgIDwvZGl2PicgK1xyXG4gICAgICAgICAgJyAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPicgK1xyXG4gICAgICAgICAgJyAgICAgIDxsYWJlbCBmb3I9XCJvdmVybGF5LXdpZHRoXCI+V2lkdGg8L2xhYmVsPicgK1xyXG4gICAgICAgICAgJyAgICAgIDxpbnB1dCBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwib3ZlcmxheS13aWR0aFwiIG5hbWU9XCJvdmVybGF5LXdpZHRoXCIgbmctbW9kZWw9XCJjb21wb25lbnQub3ZlcmxheS53aWR0aFwiPjwvaW5wdXQ+JyArXHJcbiAgICAgICAgICAnICAgIDwvZGl2PicgK1xyXG4gICAgICAgICAgJyAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPicgK1xyXG4gICAgICAgICAgJyAgICAgIDxsYWJlbCBmb3I9XCJvdmVybGF5LWhlaWdodFwiPkhlaWdodDwvbGFiZWw+JyArXHJcbiAgICAgICAgICAnICAgICAgPGlucHV0IGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJvdmVybGF5LWhlaWdodFwiIG5hbWU9XCJvdmVybGF5LWhlaWdodFwiIG5nLW1vZGVsPVwiY29tcG9uZW50Lm92ZXJsYXkuaGVpZ2h0XCI+PC9pbnB1dD4nICtcclxuICAgICAgICAgICcgICAgPC9kaXY+JyArXHJcbiAgICAgICAgICAnICA8L2Rpdj4nICtcclxuICAgICAgICAgICc8L3VpYi1hY2NvcmRpb24+JyArXHJcbiAgICAgICAgJzwvbmctZm9ybT4nXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBDcmVhdGUgdGhlIGNvbW1vbiBMYXlvdXQgdGFiIG1hcmt1cC5cclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9jb21tb24vY29uZGl0aW9uYWwuaHRtbCcsXHJcbiAgICAgICAgJzxmb3JtLWJ1aWxkZXItY29uZGl0aW9uYWw+PC9mb3JtLWJ1aWxkZXItY29uZGl0aW9uYWw+J1xyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIF0pO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwKSB7XHJcbiAgYXBwLmNvbmZpZyhbXHJcbiAgICAnZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyJyxcclxuICAgIGZ1bmN0aW9uKGZvcm1pb0NvbXBvbmVudHNQcm92aWRlcikge1xyXG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ2NvbnRhaW5lcicsIHtcclxuICAgICAgICBmYnRlbXBsYXRlOiAnZm9ybWlvL2Zvcm1idWlsZGVyL2NvbnRhaW5lci5odG1sJyxcclxuICAgICAgICB2aWV3czogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnRGlzcGxheScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY29udGFpbmVyL2Rpc3BsYXkuaHRtbCdcclxuICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgbmFtZTogJ0FQSScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY29tbW9uL2FwaS5odG1sJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0NvbmRpdGlvbmFsJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jb21tb24vY29uZGl0aW9uYWwuaHRtbCdcclxuICAgICAgICAgIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIGRvY3VtZW50YXRpb246ICdodHRwOi8vaGVscC5mb3JtLmlvL3VzZXJndWlkZS8jY29udGFpbmVyJyxcclxuICAgICAgICBub0RuZE92ZXJsYXk6IHRydWUsXHJcbiAgICAgICAgY29uZmlybVJlbW92ZTogdHJ1ZVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICBdKTtcclxuXHJcbiAgYXBwLnJ1bihbXHJcbiAgICAnJHRlbXBsYXRlQ2FjaGUnLFxyXG4gICAgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9jb250YWluZXIvZGlzcGxheS5odG1sJyxcclxuICAgICAgICAnPG5nLWZvcm0+JyArXHJcbiAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwibGFiZWxcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiY3VzdG9tQ2xhc3NcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiY2xlYXJPbkhpZGVcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwicHJvdGVjdGVkXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInBlcnNpc3RlbnRcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwidGFibGVWaWV3XCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICc8L25nLWZvcm0+J1xyXG4gICAgICApO1xyXG5cclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vZm9ybWJ1aWxkZXIvY29udGFpbmVyLmh0bWwnLFxyXG4gICAgICAgICc8ZmllbGRzZXQ+JyArXHJcbiAgICAgICAgJzxsYWJlbCBuZy1pZj1cImNvbXBvbmVudC5sYWJlbFwiIGNsYXNzPVwiY29udHJvbC1sYWJlbFwiPnt7IGNvbXBvbmVudC5sYWJlbCB9fTwvbGFiZWw+JyArXHJcbiAgICAgICAgJzxmb3JtLWJ1aWxkZXItbGlzdCBjb21wb25lbnQ9XCJjb21wb25lbnRcIiBmb3JtPVwiZm9ybVwiIGZvcm1pbz1cIjo6Zm9ybWlvXCI+PC9mb3JtLWJ1aWxkZXItbGlzdD4nICtcclxuICAgICAgICAnPC9maWVsZHNldD4nXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApIHtcclxuICBhcHAuY29uZmlnKFtcclxuICAgICdmb3JtaW9Db21wb25lbnRzUHJvdmlkZXInLFxyXG4gICAgZnVuY3Rpb24oZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyKSB7XHJcbiAgICAgIGZvcm1pb0NvbXBvbmVudHNQcm92aWRlci5yZWdpc3RlcignY29udGVudCcsIHtcclxuICAgICAgICBmYnRlbXBsYXRlOiAnZm9ybWlvL2Zvcm1idWlsZGVyL2NvbnRlbnQuaHRtbCcsXHJcbiAgICAgICAgaWNvbjogJ2ZhIGZhLWh0bWw1JyxcclxuICAgICAgICBkb2N1bWVudGF0aW9uOiAnaHR0cDovL2hlbHAuZm9ybS5pby91c2VyZ3VpZGUvI2NvbnRlbnQtY29tcG9uZW50JyxcclxuICAgICAgICBjb250cm9sbGVyOiBmdW5jdGlvbihzZXR0aW5ncywgJHNjb3BlKSB7XHJcbiAgICAgICAgICAkc2NvcGUuY2tlZGl0b3JPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBhbGxvd2VkQ29udGVudDogdHJ1ZSxcclxuICAgICAgICAgICAgdG9vbGJhckdyb3VwczogIFtcclxuICAgICAgICAgICAgICB7bmFtZTogJ2Jhc2ljc3R5bGVzJywgZ3JvdXBzOiBbJ2Jhc2ljc3R5bGVzJywgJ2NsZWFudXAnXX0sXHJcbiAgICAgICAgICAgICAge25hbWU6ICdwYXJhZ3JhcGgnLCBncm91cHM6IFsnbGlzdCcsICdpbmRlbnQnLCAnYmxvY2tzJywgJ2FsaWduJywgJ2JpZGknLCAncGFyYWdyYXBoJywgJy0nLCAnSnVzdGlmeUxlZnQnLCAnSnVzdGlmeUNlbnRlcicsICdKdXN0aWZ5UmlnaHQnLCAnSnVzdGlmeUJsb2NrJ119LFxyXG4gICAgICAgICAgICAgIHtuYW1lOiAnbGlua3MnLCBncm91cHM6IFsnbGlua3MnXX0sXHJcbiAgICAgICAgICAgICAge25hbWU6ICdpbnNlcnQnLCBncm91cHM6IFsnaW5zZXJ0J119LFxyXG4gICAgICAgICAgICAgICcvJyxcclxuICAgICAgICAgICAgICB7bmFtZTogJ3N0eWxlcycsIGdyb3VwczogWydTdHlsZXMnLCAnRm9ybWF0JywgJ0ZvbnQnLCAnRm9udFNpemUnXX0sXHJcbiAgICAgICAgICAgICAge25hbWU6ICdjb2xvcnMnLCBncm91cHM6IFsnY29sb3JzJ119LFxyXG4gICAgICAgICAgICAgIHtuYW1lOiAnY2xpcGJvYXJkJywgZ3JvdXBzOiBbJ2NsaXBib2FyZCcsICd1bmRvJ119LFxyXG4gICAgICAgICAgICAgIHtuYW1lOiAnZWRpdGluZycsIGdyb3VwczogWydmaW5kJywgJ3NlbGVjdGlvbicsICdzcGVsbGNoZWNrZXInLCAnZWRpdGluZyddfSxcclxuICAgICAgICAgICAgICB7bmFtZTogJ2RvY3VtZW50JywgZ3JvdXBzOiBbJ21vZGUnLCAnZG9jdW1lbnQnLCAnZG9jdG9vbHMnXX0sXHJcbiAgICAgICAgICAgICAge25hbWU6ICdvdGhlcnMnLCBncm91cHM6IFsnb3RoZXJzJ119LFxyXG4gICAgICAgICAgICAgIHtuYW1lOiAndG9vbHMnLCBncm91cHM6IFsndG9vbHMnXX1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgZXh0cmFQbHVnaW5zOiAnanVzdGlmeSxmb250JyxcclxuICAgICAgICAgICAgcmVtb3ZlQnV0dG9uczogJ0N1dCxDb3B5LFBhc3RlLFVuZGVybGluZSxTdWJzY3JpcHQsU3VwZXJzY3JpcHQsU2NheXQsQWJvdXQnLFxyXG4gICAgICAgICAgICB1aUNvbG9yOiAnI2VlZWVlZScsXHJcbiAgICAgICAgICAgIGhlaWdodDogJzQwMHB4JyxcclxuICAgICAgICAgICAgd2lkdGg6ICcxMDAlJ1xyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgICRzY29wZS4kd2F0Y2goJ2NvbXBvbmVudC5odG1sJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICRzY29wZS4kZW1pdCgnZm9ybUJ1aWxkZXI6dXBkYXRlJyk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHZpZXdzOiBbXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdEaXNwbGF5JyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jb21tb24vZGlzcGxheS5odG1sJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0FQSScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY29tbW9uL2FwaS5odG1sJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0NvbmRpdGlvbmFsJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jb21tb24vY29uZGl0aW9uYWwuaHRtbCdcclxuICAgICAgICAgIH1cclxuICAgICAgICBdXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIF0pO1xyXG4gIGFwcC5ydW4oW1xyXG4gICAgJyR0ZW1wbGF0ZUNhY2hlJyxcclxuICAgIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2Zvcm1idWlsZGVyL2NvbnRlbnQuaHRtbCcsXHJcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+JyArXHJcbiAgICAgICAgICAnPHRleHRhcmVhIGNrZWRpdG9yPVwiY2tlZGl0b3JPcHRpb25zXCIgbmctbW9kZWw9XCJjb21wb25lbnQuaHRtbFwiPjx0ZXh0YXJlYT4nICtcclxuICAgICAgICAnPC9kaXY+J1xyXG4gICAgICApO1xyXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9kaXNwbGF5Lmh0bWwnLFxyXG4gICAgICAgICc8bmctZm9ybT4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImN1c3RvbUNsYXNzXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICc8L25nLWZvcm0+J1xyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIF0pO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwKSB7XHJcbiAgYXBwLmNvbmZpZyhbXHJcbiAgICAnZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyJyxcclxuICAgIGZ1bmN0aW9uKGZvcm1pb0NvbXBvbmVudHNQcm92aWRlcikge1xyXG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ2N1cnJlbmN5Jywge1xyXG4gICAgICAgIGljb246ICdmYSBmYS11c2QnLFxyXG4gICAgICAgIHZpZXdzOiBbXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdEaXNwbGF5JyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jdXJyZW5jeS9kaXNwbGF5Lmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnRGF0YScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY29tbW9uL2RhdGEuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdWYWxpZGF0aW9uJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jdXJyZW5jeS92YWxpZGF0ZS5odG1sJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0FQSScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY29tbW9uL2FwaS5odG1sJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0xheW91dCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY29tbW9uL2xheW91dC5odG1sJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0NvbmRpdGlvbmFsJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jb21tb24vY29uZGl0aW9uYWwuaHRtbCdcclxuICAgICAgICAgIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIGRvY3VtZW50YXRpb246ICdodHRwOi8vaGVscC5mb3JtLmlvL3VzZXJndWlkZS8jY3VycmVuY3knXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIF0pO1xyXG4gIGFwcC5ydW4oW1xyXG4gICAgJyR0ZW1wbGF0ZUNhY2hlJyxcclxuICAgIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgICAgIC8vIENyZWF0ZSB0aGUgc2V0dGluZ3MgbWFya3VwLlxyXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL2N1cnJlbmN5L2Rpc3BsYXkuaHRtbCcsXHJcbiAgICAgICAgJzxuZy1mb3JtPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwibGFiZWxcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJwbGFjZWhvbGRlclwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImRlc2NyaXB0aW9uXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwicHJlZml4XCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwic3VmZml4XCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiY3VzdG9tQ2xhc3NcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJ0YWJpbmRleFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cIm11bHRpcGxlXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiY2xlYXJPbkhpZGVcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJkaXNhYmxlZFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImhpZGRlblwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInRhYmxlVmlld1wiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAnPC9uZy1mb3JtPidcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIENyZWF0ZSB0aGUgQVBJIG1hcmt1cC5cclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9jdXJyZW5jeS92YWxpZGF0ZS5odG1sJyxcclxuICAgICAgICAnPG5nLWZvcm0+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJ2YWxpZGF0ZS5yZXF1aXJlZFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbi1jdXN0b20tdmFsaWRhdGlvbj48L2Zvcm0tYnVpbGRlci1vcHRpb24tY3VzdG9tLXZhbGlkYXRpb24+JyArXHJcbiAgICAgICAgJzwvbmctZm9ybT4nXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApIHtcclxuICBhcHAuY29uZmlnKFtcclxuICAgICdmb3JtaW9Db21wb25lbnRzUHJvdmlkZXInLFxyXG4gICAgZnVuY3Rpb24oZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyKSB7XHJcbiAgICAgIGZvcm1pb0NvbXBvbmVudHNQcm92aWRlci5yZWdpc3RlcignY3VzdG9tJywge1xyXG4gICAgICAgIGljb246ICdmYSBmYS1jdWJlcycsXHJcbiAgICAgICAgdmlld3M6IFtcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0Rpc3BsYXknLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2N1c3RvbS9kaXNwbGF5Lmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQ29uZGl0aW9uYWwnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9jb25kaXRpb25hbC5odG1sJ1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgZG9jdW1lbnRhdGlvbjogJ2h0dHA6Ly9oZWxwLmZvcm0uaW8vdXNlcmd1aWRlLyNjdXN0b20nXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIF0pO1xyXG5cclxuICBhcHAuY29udHJvbGxlcignY3VzdG9tQ29tcG9uZW50JywgW1xyXG4gICAgJyRzY29wZScsXHJcbiAgICAnZm9ybWlvQ29tcG9uZW50cycsXHJcbiAgICBmdW5jdGlvbihcclxuICAgICAgJHNjb3BlLFxyXG4gICAgICBmb3JtaW9Db21wb25lbnRzXHJcbiAgICApIHtcclxuICAgICAgLy8gQmVjYXVzZSBvZiB0aGUgd2VpcmRuZXNzZXMgb2YgcHJvdG90eXBlIGluaGVyaXRlbmNlLCBjb21wb25lbnRzIGNhbid0IHVwZGF0ZSB0aGVtc2VsdmVzLCBvbmx5IHRoZWlyIHByb3BlcnRpZXMuXHJcbiAgICAgIHZhciBjdXJyZW50S2V5ID0gJHNjb3BlLmNvbXBvbmVudC5rZXk7XHJcbiAgICAgICRzY29wZS5jdXN0b21Db21wb25lbnQgPSBhbmd1bGFyLmNvcHkoJHNjb3BlLmNvbXBvbmVudCk7XHJcbiAgICAgICRzY29wZS4kd2F0Y2goJ2N1c3RvbUNvbXBvbmVudCcsIGZ1bmN0aW9uKG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgaWYgKG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICAvLyBEb24ndCBhbGxvdyBhIHR5cGUgb2YgYSByZWFsIHR5cGUuXHJcbiAgICAgICAgICBuZXdWYWx1ZS50eXBlID0gKGZvcm1pb0NvbXBvbmVudHMuY29tcG9uZW50cy5oYXNPd25Qcm9wZXJ0eShuZXdWYWx1ZS50eXBlKSA/ICdjdXN0b20nIDogbmV3VmFsdWUudHlwZSk7XHJcbiAgICAgICAgICAvLyBFbnN1cmUgc29tZSBrZXkgc2V0dGluZ3MgYXJlIHNldC5cclxuICAgICAgICAgIG5ld1ZhbHVlLmtleSA9IG5ld1ZhbHVlLmtleSB8fCBuZXdWYWx1ZS50eXBlO1xyXG4gICAgICAgICAgbmV3VmFsdWUucHJvdGVjdGVkID0gKG5ld1ZhbHVlLmhhc093blByb3BlcnR5KCdwcm90ZWN0ZWQnKSA/IG5ld1ZhbHVlLnByb3RlY3RlZCA6IGZhbHNlKTtcclxuICAgICAgICAgIG5ld1ZhbHVlLnBlcnNpc3RlbnQgPSAobmV3VmFsdWUuaGFzT3duUHJvcGVydHkoJ3BlcnNpc3RlbnQnKSA/IG5ld1ZhbHVlLnBlcnNpc3RlbnQgOiB0cnVlKTtcclxuICAgICAgICAgICRzY29wZS51cGRhdGVDb21wb25lbnQobmV3VmFsdWUsIGN1cnJlbnRLZXkpO1xyXG4gICAgICAgICAgY3VycmVudEtleSA9IG5ld1ZhbHVlLmtleTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIF0pO1xyXG5cclxuICBhcHAucnVuKFtcclxuICAgICckdGVtcGxhdGVDYWNoZScsXHJcbiAgICBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICAgICAvLyBDcmVhdGUgdGhlIHNldHRpbmdzIG1hcmt1cC5cclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9jdXN0b20vZGlzcGxheS5odG1sJyxcclxuICAgICAgICAnPG5nLWZvcm0+JyArXHJcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+JyArXHJcbiAgICAgICAgJzxwPkN1c3RvbSBjb21wb25lbnRzIGNhbiBiZSB1c2VkIHRvIHJlbmRlciBzcGVjaWFsIGZpZWxkcyBvciB3aWRnZXRzIGluc2lkZSB5b3VyIGFwcC4gRm9yIGluZm9ybWF0aW9uIG9uIGhvdyB0byBkaXNwbGF5IGluIGFuIGFwcCwgc2VlIDxhIGhyZWY9XCJodHRwOi8vaGVscC5mb3JtLmlvL3VzZXJndWlkZS8jY3VzdG9tXCIgdGFyZ2V0PVwiX2JsYW5rXCI+Y3VzdG9tIGNvbXBvbmVudCBkb2N1bWVudGF0aW9uPC9hPi48L3A+JyArXHJcbiAgICAgICAgJzxsYWJlbCBmb3I9XCJqc29uXCIgZm9ybS1idWlsZGVyLXRvb2x0aXA9XCJFbnRlciB0aGUgSlNPTiBmb3IgdGhpcyBjdXN0b20gZWxlbWVudC5cIj5DdXN0b20gRWxlbWVudCBKU09OPC9sYWJlbD4nICtcclxuICAgICAgICAnPHRleHRhcmVhIG5nLWNvbnRyb2xsZXI9XCJjdXN0b21Db21wb25lbnRcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwianNvblwiIG5hbWU9XCJqc29uXCIganNvbi1pbnB1dCBuZy1tb2RlbD1cImN1c3RvbUNvbXBvbmVudFwiIHBsYWNlaG9sZGVyPVwie31cIiByb3dzPVwiMTBcIj48L3RleHRhcmVhPicgK1xyXG4gICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAnPC9uZy1mb3JtPidcclxuICAgICAgKTtcclxuICAgIH1cclxuICBdKTtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwcCkge1xyXG4gIGFwcC5jb25maWcoW1xyXG4gICAgJ2Zvcm1pb0NvbXBvbmVudHNQcm92aWRlcicsXHJcbiAgICBmdW5jdGlvbihmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIpIHtcclxuICAgICAgZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyLnJlZ2lzdGVyKCdkYXRhZ3JpZCcsIHtcclxuICAgICAgICBmYnRlbXBsYXRlOiAnZm9ybWlvL2Zvcm1idWlsZGVyL2RhdGFncmlkLmh0bWwnLFxyXG4gICAgICAgIGljb246ICdmYSBmYS10aCcsXHJcbiAgICAgICAgdmlld3M6IFtcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0Rpc3BsYXknLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2RhdGFncmlkL2Rpc3BsYXkuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdWYWxpZGF0aW9uJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9kYXRhZ3JpZC92YWxpZGF0ZS5odG1sJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0FQSScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY29tbW9uL2FwaS5odG1sJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0NvbmRpdGlvbmFsJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jb21tb24vY29uZGl0aW9uYWwuaHRtbCdcclxuICAgICAgICAgIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIGRvY3VtZW50YXRpb246ICdodHRwOi8vaGVscC5mb3JtLmlvL3VzZXJndWlkZS8jZGF0YWdyaWQnLFxyXG4gICAgICAgIG5vRG5kT3ZlcmxheTogdHJ1ZSxcclxuICAgICAgICBjb25maXJtUmVtb3ZlOiB0cnVlXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIF0pO1xyXG5cclxuICBhcHAucnVuKFtcclxuICAgICckdGVtcGxhdGVDYWNoZScsXHJcbiAgICBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL2RhdGFncmlkL2Rpc3BsYXkuaHRtbCcsXHJcbiAgICAgICAgJzxuZy1mb3JtPicgK1xyXG4gICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImxhYmVsXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImFkZEFub3RoZXJcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiY3VzdG9tQ2xhc3NcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwic3RyaXBlZFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJib3JkZXJlZFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJob3ZlclwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJjb25kZW5zZWRcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiY2xlYXJPbkhpZGVcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwicHJvdGVjdGVkXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInBlcnNpc3RlbnRcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiaGlkZGVuXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImRpc2FibGVkXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInRhYmxlVmlld1wiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAnPC9uZy1mb3JtPidcclxuICAgICAgKTtcclxuXHJcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvZGF0YWdyaWQvdmFsaWRhdGUuaHRtbCcsXHJcbiAgICAgICAgJzxuZy1mb3JtPicgK1xyXG4gICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInZhbGlkYXRlLm1pbkxlbmd0aFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJ2YWxpZGF0ZS5tYXhMZW5ndGhcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uLWN1c3RvbS12YWxpZGF0aW9uPjwvZm9ybS1idWlsZGVyLW9wdGlvbi1jdXN0b20tdmFsaWRhdGlvbj4nICtcclxuICAgICAgICAnPC9uZy1mb3JtPidcclxuICAgICAgKTtcclxuICAgIH1cclxuICBdKTtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwcCkge1xyXG4gIGFwcC5jb25maWcoW1xyXG4gICAgJ2Zvcm1pb0NvbXBvbmVudHNQcm92aWRlcicsXHJcbiAgICBmdW5jdGlvbihmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIpIHtcclxuICAgICAgZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyLnJlZ2lzdGVyKCdkYXRldGltZScsIHtcclxuICAgICAgICBvbkVkaXQ6IFsnJHNjb3BlJywgZnVuY3Rpb24oJHNjb3BlKSB7XHJcbiAgICAgICAgICAvLyBGT1ItMzQgLSBVcGRhdGUgMTJociB0aW1lIGRpc3BsYXkgaW4gdGhlIGZpZWxkLCBub3Qgb25seSB0aW1lIHBpY2tlci5cclxuICAgICAgICAgICRzY29wZS4kd2F0Y2goJ2NvbXBvbmVudC50aW1lUGlja2VyLnNob3dNZXJpZGlhbicsIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBfb2xkID0gdmFsdWUgPyAnSEgnIDogJ2hoJztcclxuICAgICAgICAgICAgdmFyIF9uZXcgPSAhdmFsdWUgPyAnSEgnIDogJ2hoJztcclxuXHJcbiAgICAgICAgICAgIGlmICgkc2NvcGUuY29tcG9uZW50LmVuYWJsZVRpbWUpIHtcclxuICAgICAgICAgICAgICAkc2NvcGUuY29tcG9uZW50LmZvcm1hdCA9ICRzY29wZS5jb21wb25lbnQuZm9ybWF0LnRvU3RyaW5nKCkucmVwbGFjZShfb2xkLCBfbmV3KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgJHNjb3BlLnNldEZvcm1hdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgc3RkRm9ybWF0RGF0ZVRpbWUgPSAneXl5eS1NTS1kZCBISDptbSc7XHJcbiAgICAgICAgICAgIHZhciBzdGRGb3JtYXREYXRlICAgICA9ICd5eXl5LU1NLWRkJztcclxuICAgICAgICAgICAgdmFyIHN0ZEZvcm1hdFRpbWUgICAgID0gJ0hIOm1tJztcclxuICAgICAgICAgICAgaWYgKCRzY29wZS5jb21wb25lbnQudGltZVBpY2tlci5zaG93TWVyaWRpYW4pIHtcclxuICAgICAgICAgICAgICAgIHN0ZEZvcm1hdERhdGVUaW1lID0gJ3l5eXktTU0tZGQgaGg6bW0nO1xyXG4gICAgICAgICAgICAgICAgc3RkRm9ybWF0VGltZSAgICAgPSAnaGg6bW0nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzdGRGb3JtYXRzICAgICAgICA9IFtzdGRGb3JtYXREYXRlVGltZSwgc3RkRm9ybWF0RGF0ZSwgc3RkRm9ybWF0VGltZV07XHJcblxyXG4gICAgICAgICAgICBpZiAoJHNjb3BlLmNvbXBvbmVudC5lbmFibGVEYXRlICYmICRzY29wZS5jb21wb25lbnQuZW5hYmxlVGltZSAmJiBzdGRGb3JtYXRzLmluZGV4T2YoJHNjb3BlLmNvbXBvbmVudC5mb3JtYXQpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICRzY29wZS5jb21wb25lbnQuZm9ybWF0ID0gc3RkRm9ybWF0RGF0ZVRpbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoJHNjb3BlLmNvbXBvbmVudC5lbmFibGVEYXRlICYmICEkc2NvcGUuY29tcG9uZW50LmVuYWJsZVRpbWUgJiYgc3RkRm9ybWF0cy5pbmRleE9mKCRzY29wZS5jb21wb25lbnQuZm9ybWF0KSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAkc2NvcGUuY29tcG9uZW50LmZvcm1hdCA9IHN0ZEZvcm1hdERhdGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoISRzY29wZS5jb21wb25lbnQuZW5hYmxlRGF0ZSAmJiAkc2NvcGUuY29tcG9uZW50LmVuYWJsZVRpbWUgJiYgc3RkRm9ybWF0cy5pbmRleE9mKCRzY29wZS5jb21wb25lbnQuZm9ybWF0KSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAkc2NvcGUuY29tcG9uZW50LmZvcm1hdCA9IHN0ZEZvcm1hdFRpbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH07XHJcbiAgICAgICAgICAkc2NvcGUuc3RhcnRpbmdEYXlzID0gWydTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheSddO1xyXG4gICAgICAgICAgJHNjb3BlLm1vZGVzID0gW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgbmFtZTogJ2RheScsXHJcbiAgICAgICAgICAgICAgbGFiZWw6ICdEYXknXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBuYW1lOiAnbW9udGgnLFxyXG4gICAgICAgICAgICAgIGxhYmVsOiAnTW9udGgnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBuYW1lOiAneWVhcicsXHJcbiAgICAgICAgICAgICAgbGFiZWw6ICdZZWFyJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICBdO1xyXG4gICAgICAgIH1dLFxyXG4gICAgICAgIGljb246ICdmYSBmYS1jbG9jay1vJyxcclxuICAgICAgICB2aWV3czogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnRGlzcGxheScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvZGF0ZXRpbWUvZGlzcGxheS5odG1sJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0RhdGUnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2RhdGV0aW1lL2RhdGUuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdUaW1lJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9kYXRldGltZS90aW1lLmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnVmFsaWRhdGlvbicsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvZGF0ZXRpbWUvdmFsaWRhdGUuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdBUEknLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9hcGkuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdMYXlvdXQnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9sYXlvdXQuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdDb25kaXRpb25hbCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY29tbW9uL2NvbmRpdGlvbmFsLmh0bWwnXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBkb2N1bWVudGF0aW9uOiAnaHR0cDovL2hlbHAuZm9ybS5pby91c2VyZ3VpZGUvI2RhdGV0aW1lJ1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICBdKTtcclxuICBhcHAucnVuKFtcclxuICAgICckdGVtcGxhdGVDYWNoZScsXHJcbiAgICBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICAgICAvLyBDcmVhdGUgdGhlIHNldHRpbmdzIG1hcmt1cC5cclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9kYXRldGltZS9kaXNwbGF5Lmh0bWwnLFxyXG4gICAgICAgICc8bmctZm9ybT4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImxhYmVsXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiZGVmYXVsdERhdGVcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJwbGFjZWhvbGRlclwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImRlc2NyaXB0aW9uXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiZm9ybWF0XCIgbGFiZWw9XCJEYXRlIEZvcm1hdFwiIHBsYWNlaG9sZGVyPVwiRW50ZXIgdGhlIERhdGUgZm9ybWF0XCIgdGl0bGU9XCJUaGUgZm9ybWF0IGZvciBkaXNwbGF5aW5nIHRoaXMgZmllbGRcXCdzIGRhdGUuIFRoZSBmb3JtYXQgbXVzdCBiZSBzcGVjaWZpZWQgbGlrZSB0aGUgPGEgaHJlZj1cXCdodHRwczovL2RvY3MuYW5ndWxhcmpzLm9yZy9hcGkvbmcvZmlsdGVyL2RhdGVcXCcgdGFyZ2V0PVxcJ19ibGFua1xcJz5Bbmd1bGFySlMgZGF0ZSBmaWx0ZXI8L2E+LlwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImN1c3RvbUNsYXNzXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwidGFiaW5kZXhcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJjbGVhck9uSGlkZVwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInByb3RlY3RlZFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInBlcnNpc3RlbnRcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJoaWRkZW5cIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJkaXNhYmxlZFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInRhYmxlVmlld1wiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAnPC9uZy1mb3JtPidcclxuICAgICAgKTtcclxuXHJcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvZGF0ZXRpbWUvZGF0ZS5odG1sJyxcclxuICAgICAgICAnPG5nLWZvcm0+JyArXHJcbiAgICAgICAgICAnPGRpdiBjbGFzcz1cImNoZWNrYm94XCI+JyArXHJcbiAgICAgICAgICAgICc8bGFiZWwgZm9ybS1idWlsZGVyLXRvb2x0aXA9XCJFbmFibGVzIGRhdGUgaW5wdXQgZm9yIHRoaXMgZmllbGQuXCI+JyArXHJcbiAgICAgICAgICAgICAgJzxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBpZD1cImVuYWJsZURhdGVcIiBuYW1lPVwiZW5hYmxlRGF0ZVwiIG5nLW1vZGVsPVwiY29tcG9uZW50LmVuYWJsZURhdGVcIiBuZy1jaGVja2VkPVwiY29tcG9uZW50LmVuYWJsZURhdGVcIiBuZy1jaGFuZ2U9XCJzZXRGb3JtYXQoKVwiPiBFbmFibGUgRGF0ZSBJbnB1dCcgK1xyXG4gICAgICAgICAgICAnPC9sYWJlbD4nICtcclxuICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPicgK1xyXG4gICAgICAgICAgICAnPGxhYmVsIGZvcj1cInBsYWNlaG9sZGVyXCIgZm9ybS1idWlsZGVyLXRvb2x0aXA9XCJUaGUgbWluaW11bSBkYXRlIHRoYXQgY2FuIGJlIHBpY2tlZC5cIj5NaW5pbXVtIERhdGU8L2xhYmVsPicgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwXCI+JyArXHJcbiAgICAgICAgICAgICAgJzxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgJyArXHJcbiAgICAgICAgICAgICAgICAnbmctZm9jdXM9XCJtaW5EYXRlT3BlbiA9IHRydWVcIiAnICtcclxuICAgICAgICAgICAgICAgICduZy1pbml0PVwibWluRGF0ZU9wZW4gPSBmYWxzZVwiICcgK1xyXG4gICAgICAgICAgICAgICAgJ2lzLW9wZW49XCJtaW5EYXRlT3BlblwiICcgK1xyXG4gICAgICAgICAgICAgICAgJ2RhdGV0aW1lLXBpY2tlcj1cInl5eXktTU0tZGRcIiAnICtcclxuICAgICAgICAgICAgICAgICdlbmFibGUtdGltZT1cImZhbHNlXCIgJyArXHJcbiAgICAgICAgICAgICAgICAnbmctbW9kZWw9XCJjb21wb25lbnQuZGF0ZVBpY2tlci5taW5EYXRlXCIgLz4nICtcclxuICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC1idG5cIj4nICtcclxuICAgICAgICAgICAgICAgICc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tZGVmYXVsdFwiIG5nLWNsaWNrPVwibWluRGF0ZU9wZW4gPSB0cnVlXCI+PGkgY2xhc3M9XCJmYSBmYS1jYWxlbmRhclwiPjwvaT48L2J1dHRvbj4nICtcclxuICAgICAgICAgICAgICAnPC9zcGFuPicgK1xyXG4gICAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAnPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj4nICtcclxuICAgICAgICAgICAgJzxsYWJlbCBmb3I9XCJwbGFjZWhvbGRlclwiICBmb3JtLWJ1aWxkZXItdG9vbHRpcD1cIlRoZSBtYXhpbXVtIGRhdGUgdGhhdCBjYW4gYmUgcGlja2VkLlwiPk1heGltdW0gRGF0ZTwvbGFiZWw+JyArXHJcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXBcIj4nICtcclxuICAgICAgICAgICAgICAnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiAnICtcclxuICAgICAgICAgICAgICAgICduZy1mb2N1cz1cIm1heERhdGVPcGVuID0gdHJ1ZVwiICcgK1xyXG4gICAgICAgICAgICAgICAgJ25nLWluaXQ9XCJtYXhEYXRlT3BlbiA9IGZhbHNlXCIgJyArXHJcbiAgICAgICAgICAgICAgICAnaXMtb3Blbj1cIm1heERhdGVPcGVuXCIgJyArXHJcbiAgICAgICAgICAgICAgICAnZGF0ZXRpbWUtcGlja2VyPVwieXl5eS1NTS1kZFwiICcgK1xyXG4gICAgICAgICAgICAgICAgJ2VuYWJsZS10aW1lPVwiZmFsc2VcIiAnICtcclxuICAgICAgICAgICAgICAgICduZy1tb2RlbD1cImNvbXBvbmVudC5kYXRlUGlja2VyLm1heERhdGVcIiAvPicgK1xyXG4gICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImlucHV0LWdyb3VwLWJ0blwiPicgK1xyXG4gICAgICAgICAgICAgICAgJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0XCIgbmctY2xpY2s9XCJtYXhEYXRlT3BlbiA9IHRydWVcIj48aSBjbGFzcz1cImZhIGZhLWNhbGVuZGFyXCI+PC9pPjwvYnV0dG9uPicgK1xyXG4gICAgICAgICAgICAgICc8L3NwYW4+JyArXHJcbiAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPicgK1xyXG4gICAgICAgICAgICAnPGxhYmVsIGZvcj1cInN0YXJ0aW5nRGF5XCIgZm9ybS1idWlsZGVyLXRvb2x0aXA9XCJUaGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlwiPlN0YXJ0aW5nIERheTwvbGFiZWw+JyArXHJcbiAgICAgICAgICAgICc8c2VsZWN0IGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJzdGFydGluZ0RheVwiIG5hbWU9XCJzdGFydGluZ0RheVwiIG5nLW1vZGVsPVwiY29tcG9uZW50LmRhdGVQaWNrZXIuc3RhcnRpbmdEYXlcIiBuZy1vcHRpb25zPVwiaWR4IGFzIGRheSBmb3IgKGlkeCwgZGF5KSBpbiBzdGFydGluZ0RheXNcIj48L3NlbGVjdD4nICtcclxuICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPicgK1xyXG4gICAgICAgICAgICAnPGxhYmVsIGZvcj1cIm1pbk1vZGVcIiBmb3JtLWJ1aWxkZXItdG9vbHRpcD1cIlRoZSBzbWFsbGVzdCB1bml0IG9mIHRpbWUgdmlldyB0byBkaXNwbGF5IGluIHRoZSBkYXRlIHBpY2tlci5cIj5NaW5pbXVtIE1vZGU8L2xhYmVsPicgK1xyXG4gICAgICAgICAgICAnPHNlbGVjdCBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwibWluTW9kZVwiIG5hbWU9XCJtaW5Nb2RlXCIgbmctbW9kZWw9XCJjb21wb25lbnQuZGF0ZVBpY2tlci5taW5Nb2RlXCIgbmctb3B0aW9ucz1cIm1vZGUubmFtZSBhcyBtb2RlLmxhYmVsIGZvciBtb2RlIGluIG1vZGVzXCI+PC9zZWxlY3Q+JyArXHJcbiAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAnPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj4nICtcclxuICAgICAgICAgICAgJzxsYWJlbCBmb3I9XCJtYXhNb2RlXCIgZm9ybS1idWlsZGVyLXRvb2x0aXA9XCJUaGUgbGFyZ2VzdCB1bml0IG9mIHRpbWUgdmlldyB0byBkaXNwbGF5IGluIHRoZSBkYXRlIHBpY2tlci5cIj5NYXhpbXVtIE1vZGU8L2xhYmVsPicgK1xyXG4gICAgICAgICAgICAnPHNlbGVjdCBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwibWF4TW9kZVwiIG5hbWU9XCJtYXhNb2RlXCIgbmctbW9kZWw9XCJjb21wb25lbnQuZGF0ZVBpY2tlci5tYXhNb2RlXCIgbmctb3B0aW9ucz1cIm1vZGUubmFtZSBhcyBtb2RlLmxhYmVsIGZvciBtb2RlIGluIG1vZGVzXCI+PC9zZWxlY3Q+JyArXHJcbiAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJkYXRlUGlja2VyLnllYXJSb3dzXCIgbGFiZWw9XCJOdW1iZXIgb2YgWWVhcnMgRGlzcGxheWVkIChSb3dzKVwiIHBsYWNlaG9sZGVyPVwiWWVhciBSYW5nZSAoUm93cylcIiB0aXRsZT1cIlRoZSBudW1iZXIgb2YgeWVhcnMgdG8gZGlzcGxheSBpbiB0aGUgeWVhcnMgdmlldyAoUm93cykuXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiZGF0ZVBpY2tlci55ZWFyQ29sdW1uc1wiIGxhYmVsPVwiTnVtYmVyIG9mIFllYXJzIERpc3BsYXllZCAoQ29sdW1ucylcIiBwbGFjZWhvbGRlcj1cIlllYXIgUmFuZ2UgKENvbHVtbnMpXCIgdGl0bGU9XCJUaGUgbnVtYmVyIG9mIHllYXJzIHRvIGRpc3BsYXkgaW4gdGhlIHllYXJzIHZpZXcgKENvbHVtbnMpLlwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImRhdGVQaWNrZXIuc2hvd1dlZWtzXCIgdHlwZT1cImNoZWNrYm94XCIgbGFiZWw9XCJTaG93IFdlZWsgTnVtYmVyc1wiIHRpdGxlPVwiRGlzcGxheXMgdGhlIHdlZWsgbnVtYmVycyBvbiB0aGUgZGF0ZSBwaWNrZXIuXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICc8L25nLWZvcm0+J1xyXG4gICAgICApO1xyXG5cclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9kYXRldGltZS90aW1lLmh0bWwnLFxyXG4gICAgICAgICc8bmctZm9ybT4nICtcclxuICAgICAgICAgICc8ZGl2IGNsYXNzPVwiY2hlY2tib3hcIj4nICtcclxuICAgICAgICAgICAgJzxsYWJlbCBmb3JtLWJ1aWxkZXItdG9vbHRpcD1cIkVuYWJsZXMgdGltZSBpbnB1dCBmb3IgdGhpcyBmaWVsZC5cIj4nICtcclxuICAgICAgICAgICAgICAnPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGlkPVwiZW5hYmxlVGltZVwiIG5hbWU9XCJlbmFibGVUaW1lXCIgbmctbW9kZWw9XCJjb21wb25lbnQuZW5hYmxlVGltZVwiIG5nLWNoZWNrZWQ9XCJjb21wb25lbnQuZW5hYmxlVGltZVwiIG5nLWNoYW5nZT1cInNldEZvcm1hdCgpXCI+IEVuYWJsZSBUaW1lIElucHV0JyArXHJcbiAgICAgICAgICAgICc8L2xhYmVsPicgK1xyXG4gICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwidGltZVBpY2tlci5ob3VyU3RlcFwiIHR5cGU9XCJudW1iZXJcIiBsYWJlbD1cIkhvdXIgU3RlcCBTaXplXCIgdGl0bGU9XCJUaGUgbnVtYmVyIG9mIGhvdXJzIHRvIGluY3JlbWVudC9kZWNyZW1lbnQgaW4gdGhlIHRpbWUgcGlja2VyLlwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInRpbWVQaWNrZXIubWludXRlU3RlcFwiIHR5cGU9XCJudW1iZXJcIiBsYWJlbD1cIk1pbnV0ZSBTdGVwIFNpemVcIiB0aXRsZT1cIlRoZSBudW1iZXIgb2YgbWludXRlcyB0byBpbmNyZW1lbnQvZGVjcmVtZW50IGluIHRoZSB0aW1lIHBpY2tlci5cIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJ0aW1lUGlja2VyLnNob3dNZXJpZGlhblwiIHR5cGU9XCJjaGVja2JveFwiIGxhYmVsPVwiMTIgSG91ciBUaW1lIChBTS9QTSlcIiB0aXRsZT1cIkRpc3BsYXkgdGltZSBpbiAxMiBob3VyIHRpbWUgd2l0aCBBTS9QTS5cIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJ0aW1lUGlja2VyLnJlYWRvbmx5SW5wdXRcIiB0eXBlPVwiY2hlY2tib3hcIiBsYWJlbD1cIlJlYWQtT25seSBJbnB1dFwiIHRpdGxlPVwiTWFrZXMgdGhlIHRpbWUgcGlja2VyIGlucHV0IGJveGVzIHJlYWQtb25seS4gVGhlIHRpbWUgY2FuIG9ubHkgYmUgY2hhbmdlZCBieSB0aGUgaW5jcmVtZW50L2RlY3JlbWVudCBidXR0b25zLlwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAnPC9uZy1mb3JtPidcclxuICAgICAgKTtcclxuXHJcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvZGF0ZXRpbWUvdmFsaWRhdGUuaHRtbCcsXHJcbiAgICAgICAgJzxuZy1mb3JtPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwidmFsaWRhdGUucmVxdWlyZWRcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24tY3VzdG9tLXZhbGlkYXRpb24+PC9mb3JtLWJ1aWxkZXItb3B0aW9uLWN1c3RvbS12YWxpZGF0aW9uPicgK1xyXG4gICAgICAgICc8L25nLWZvcm0+J1xyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIF0pO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwKSB7XHJcbiAgYXBwLmNvbmZpZyhbXHJcbiAgICAnZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyJyxcclxuICAgIGZ1bmN0aW9uKGZvcm1pb0NvbXBvbmVudHNQcm92aWRlcikge1xyXG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ2RheScsIHtcclxuICAgICAgICBpY29uOiAnZmEgZmEtY2FsZW5kYXInLFxyXG4gICAgICAgIHZpZXdzOiBbXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdEaXNwbGF5JyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9kYXkvZGlzcGxheS5odG1sJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0RhdGEnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9kYXRhLmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnVmFsaWRhdGlvbicsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvZGF5L3ZhbGlkYXRlLmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQVBJJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jb21tb24vYXBpLmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnTGF5b3V0JyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jb21tb24vbGF5b3V0Lmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQ29uZGl0aW9uYWwnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9jb25kaXRpb25hbC5odG1sJ1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgZG9jdW1lbnRhdGlvbjogJ2h0dHA6Ly9oZWxwLmZvcm0uaW8vdXNlcmd1aWRlLyNkYXknXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIF0pO1xyXG4gIGFwcC5ydW4oW1xyXG4gICAgJyR0ZW1wbGF0ZUNhY2hlJyxcclxuICAgIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgICAgIC8vIENyZWF0ZSB0aGUgc2V0dGluZ3MgbWFya3VwLlxyXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL2RheS9kaXNwbGF5Lmh0bWwnLFxyXG4gICAgICAgICc8bmctZm9ybT4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImxhYmVsXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiZmllbGRzLmRheS5wbGFjZWhvbGRlclwiIGxhYmVsPVwiRGF5IFBsYWNlaG9sZGVyXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiZmllbGRzLm1vbnRoLnBsYWNlaG9sZGVyXCIgbGFiZWw9XCJNb250aCBQbGFjZWhvbGRlclwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImZpZWxkcy55ZWFyLnBsYWNlaG9sZGVyXCIgbGFiZWw9XCJZZWFyIFBsYWNlaG9sZGVyXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiZGF5Rmlyc3RcIiB0eXBlPVwiY2hlY2tib3hcIiBsYWJlbD1cIkRheSBmaXJzdFwiIHRpdGxlPVwiRGlzcGxheSB0aGUgRGF5IGZpZWxkIGJlZm9yZSB0aGUgTW9udGggZmllbGQuXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiZmllbGRzLmRheS5oaWRlXCIgdHlwZT1cImNoZWNrYm94XCIgbGFiZWw9XCJIaWRlIERheVwiIHRpdGxlPVwiSGlkZSB0aGUgZGF5IHBhcnQgb2YgdGhlIGNvbXBvbmVudC5cIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJmaWVsZHMubW9udGguaGlkZVwiIHR5cGU9XCJjaGVja2JveFwiIGxhYmVsPVwiSGlkZSBNb250aFwiIHRpdGxlPVwiSGlkZSB0aGUgbW9udGggcGFydCBvZiB0aGUgY29tcG9uZW50LlwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImZpZWxkcy55ZWFyLmhpZGVcIiB0eXBlPVwiY2hlY2tib3hcIiBsYWJlbD1cIkhpZGUgWWVhclwiIHRpdGxlPVwiSGlkZSB0aGUgeWVhciBwYXJ0IG9mIHRoZSBjb21wb25lbnQuXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiY3VzdG9tQ2xhc3NcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJ0YWJpbmRleFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImNsZWFyT25IaWRlXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwicHJvdGVjdGVkXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwicGVyc2lzdGVudFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImhpZGRlblwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImRpc2FibGVkXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwidGFibGVWaWV3XCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICc8L25nLWZvcm0+J1xyXG4gICAgICApO1xyXG5cclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9kYXkvdmFsaWRhdGUuaHRtbCcsXHJcbiAgICAgICAgJzxuZy1mb3JtPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiZmllbGRzLmRheS5yZXF1aXJlZFwiIGxhYmVsPVwiUmVxdWlyZSBEYXlcIiB0eXBlPVwiY2hlY2tib3hcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJmaWVsZHMubW9udGgucmVxdWlyZWRcIiBsYWJlbD1cIlJlcXVpcmUgTW9udGhcIiB0eXBlPVwiY2hlY2tib3hcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJmaWVsZHMueWVhci5yZXF1aXJlZFwiIGxhYmVsPVwiUmVxdWlyZSBZZWFyXCIgdHlwZT1cImNoZWNrYm94XCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uLWN1c3RvbS12YWxpZGF0aW9uPjwvZm9ybS1idWlsZGVyLW9wdGlvbi1jdXN0b20tdmFsaWRhdGlvbj4nICtcclxuICAgICAgICAnPC9uZy1mb3JtPidcclxuICAgICAgKTtcclxuICAgIH1cclxuICBdKTtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX2Nsb25lRGVlcCA9IHJlcXVpcmUoJ2xvZGFzaC9jbG9uZURlZXAnKTtcclxudmFyIF9lYWNoID0gcmVxdWlyZSgnbG9kYXNoL2VhY2gnKTtcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApIHtcclxuICBhcHAuY29uZmlnKFtcclxuICAgICdmb3JtaW9Db21wb25lbnRzUHJvdmlkZXInLFxyXG4gICAgZnVuY3Rpb24oZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyKSB7XHJcbiAgICAgIHZhciB2aWV3cyA9IF9jbG9uZURlZXAoZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyLiRnZXQoKS5jb21wb25lbnRzLnRleHRmaWVsZC52aWV3cyk7XHJcbiAgICAgIF9lYWNoKHZpZXdzLCBmdW5jdGlvbih2aWV3KSB7XHJcbiAgICAgICAgaWYgKHZpZXcubmFtZSA9PT0gJ1ZhbGlkYXRpb24nKSB7XHJcbiAgICAgICAgICB2aWV3LnRlbXBsYXRlID0gJ2Zvcm1pby9jb21wb25lbnRzL2VtYWlsL3ZhbGlkYXRlLmh0bWwnO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIGZvcm1pb0NvbXBvbmVudHNQcm92aWRlci5yZWdpc3RlcignZW1haWwnLCB7XHJcbiAgICAgICAgaWNvbjogJ2ZhIGZhLWF0JyxcclxuICAgICAgICB2aWV3czogdmlld3MsXHJcbiAgICAgICAgZG9jdW1lbnRhdGlvbjogJ2h0dHA6Ly9oZWxwLmZvcm0uaW8vdXNlcmd1aWRlLyNlbWFpbCdcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbiAgYXBwLnJ1bihbXHJcbiAgICAnJHRlbXBsYXRlQ2FjaGUnLFxyXG4gICAgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9lbWFpbC92YWxpZGF0ZS5odG1sJyxcclxuICAgICAgICAnPG5nLWZvcm0+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJ2YWxpZGF0ZS5yZXF1aXJlZFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInVuaXF1ZVwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8ZGl2IGNsYXNzPVwicGFuZWwgcGFuZWwtZGVmYXVsdFwiPicgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cInBhbmVsLWhlYWRpbmdcIj48aDMgY2xhc3M9XCJwYW5lbC10aXRsZVwiPktpY2tib3g8L2gzPjwvZGl2PicgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cInBhbmVsLWJvZHlcIj4nICtcclxuICAgICAgICAgICAgICAnPHA+VmFsaWRhdGUgdGhpcyBlbWFpbCB1c2luZyB0aGUgS2lja2JveCBlbWFpbCB2YWxpZGF0aW9uIHNlcnZpY2UuPC9wPicgK1xyXG4gICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiY2hlY2tib3hcIj4nICtcclxuICAgICAgICAgICAgICAgICc8bGFiZWwgZm9yPVwia2lja2JveC1lbmFibGVcIiBmb3JtLWJ1aWxkZXItdG9vbHRpcD1cIkVuYWJsZSBLaWNrYm94IHZhbGlkYXRpb24gZm9yIHRoaXMgZW1haWwgZmllbGQuXCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICc8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgaWQ9XCJraWNrYm94LWVuYWJsZVwiIG5hbWU9XCJraWNrYm94LWVuYWJsZVwiIG5nLW1vZGVsPVwiY29tcG9uZW50LmtpY2tib3guZW5hYmxlZFwiPiBFbmFibGUnICtcclxuICAgICAgICAgICAgICAgICc8L2xhYmVsPicgK1xyXG4gICAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwidmFsaWRhdGUubWluTGVuZ3RoXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwidmFsaWRhdGUubWF4TGVuZ3RoXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwidmFsaWRhdGUucGF0dGVyblwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbi1jdXN0b20tdmFsaWRhdGlvbj48L2Zvcm0tYnVpbGRlci1vcHRpb24tY3VzdG9tLXZhbGlkYXRpb24+JyArXHJcbiAgICAgICAgJzwvbmctZm9ybT4nXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApIHtcclxuICBhcHAuY29uZmlnKFtcclxuICAgICdmb3JtaW9Db21wb25lbnRzUHJvdmlkZXInLFxyXG4gICAgZnVuY3Rpb24oZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyKSB7XHJcbiAgICAgIGZvcm1pb0NvbXBvbmVudHNQcm92aWRlci5yZWdpc3RlcignZmllbGRzZXQnLCB7XHJcbiAgICAgICAgZmJ0ZW1wbGF0ZTogJ2Zvcm1pby9mb3JtYnVpbGRlci9maWVsZHNldC5odG1sJyxcclxuICAgICAgICBpY29uOiAnZmEgZmEtdGgtbGFyZ2UnLFxyXG4gICAgICAgIHZpZXdzOiBbXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdEaXNwbGF5JyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9maWVsZHNldC9kaXNwbGF5Lmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnTGF5b3V0JyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jb21tb24vbGF5b3V0Lmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQVBJJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jb21tb24vYXBpLmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQ29uZGl0aW9uYWwnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9jb25kaXRpb25hbC5odG1sJ1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgZG9jdW1lbnRhdGlvbjogJ2h0dHA6Ly9oZWxwLmZvcm0uaW8vdXNlcmd1aWRlLyNmaWVsZHNldCcsXHJcbiAgICAgICAga2VlcENoaWxkcmVuT25SZW1vdmU6IHRydWUsXHJcbiAgICAgICAgbm9EbmRPdmVybGF5OiB0cnVlLFxyXG4gICAgICAgIGNvbmZpcm1SZW1vdmU6IHRydWVcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbiAgYXBwLnJ1bihbXHJcbiAgICAnJHRlbXBsYXRlQ2FjaGUnLFxyXG4gICAgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vZm9ybWJ1aWxkZXIvZmllbGRzZXQuaHRtbCcsXHJcbiAgICAgICAgJzxmaWVsZHNldD4nICtcclxuICAgICAgICAgICc8bGVnZW5kIG5nLWlmPVwiY29tcG9uZW50LmxlZ2VuZFwiPnt7IGNvbXBvbmVudC5sZWdlbmQgfX08L2xlZ2VuZD4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLWxpc3QgY29tcG9uZW50PVwiY29tcG9uZW50XCIgZm9ybT1cImZvcm1cIiBmb3JtaW89XCI6OmZvcm1pb1wiPjwvZm9ybS1idWlsZGVyLWxpc3Q+JyArXHJcbiAgICAgICAgJzwvZmllbGRzZXQ+J1xyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gQ3JlYXRlIHRoZSBzZXR0aW5ncyBtYXJrdXAuXHJcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvZmllbGRzZXQvZGlzcGxheS5odG1sJyxcclxuICAgICAgICAnPG5nLWZvcm0+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJsZWdlbmRcIiBsYWJlbD1cIkxlZ2VuZFwiIHBsYWNlaG9sZGVyPVwiRmllbGRTZXQgTGVnZW5kXCIgdGl0bGU9XCJUaGUgbGVnZW5kIHRleHQgdG8gYXBwZWFyIGFib3ZlIHRoaXMgZmllbGRzZXQuXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiY3VzdG9tQ2xhc3NcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgJzwvbmctZm9ybT4nXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9tYXAgPSByZXF1aXJlKCdsb2Rhc2gvbWFwJyk7XHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwKSB7XHJcbiAgYXBwLmNvbmZpZyhbXHJcbiAgICAnZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyJyxcclxuICAgIGZ1bmN0aW9uKFxyXG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXJcclxuICAgICkge1xyXG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ2ZpbGUnLCB7XHJcbiAgICAgICAgb25FZGl0OiBbXHJcbiAgICAgICAgICAnJHNjb3BlJyxcclxuICAgICAgICAgICdGb3JtaW8nLFxyXG4gICAgICAgICAgZnVuY3Rpb24oJHNjb3BlLCBGb3JtaW8pIHtcclxuICAgICAgICAgICAgLy8gUHVsbCBvdXQgdGl0bGUgYW5kIG5hbWUgZnJvbSB0aGUgbGlzdCBvZiBzdG9yYWdlIHBsdWdpbnMuXHJcbiAgICAgICAgICAgICRzY29wZS5zdG9yYWdlID0gX21hcChGb3JtaW8ucHJvdmlkZXJzLnN0b3JhZ2UsIGZ1bmN0aW9uKHN0b3JhZ2UsIGtleSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogc3RvcmFnZS50aXRsZSxcclxuICAgICAgICAgICAgICAgIG5hbWU6IGtleVxyXG4gICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgaWNvbjogJ2ZhIGZhLWZpbGUnLFxyXG4gICAgICAgIHZpZXdzOiBbXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdEaXNwbGF5JyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9maWxlL2Rpc3BsYXkuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdWYWxpZGF0aW9uJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9maWxlL3ZhbGlkYXRlLmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQVBJJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jb21tb24vYXBpLmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnTGF5b3V0JyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jb21tb24vbGF5b3V0Lmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQ29uZGl0aW9uYWwnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9jb25kaXRpb25hbC5odG1sJ1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgZG9jdW1lbnRhdGlvbjogJ2h0dHA6Ly9oZWxwLmZvcm0uaW8vdXNlcmd1aWRlLyNmaWxlJ1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICBdKTtcclxuICBhcHAucnVuKFtcclxuICAgICckdGVtcGxhdGVDYWNoZScsXHJcbiAgICBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICAgICAvLyBDcmVhdGUgdGhlIHNldHRpbmdzIG1hcmt1cC5cclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9maWxlL2Rpc3BsYXkuaHRtbCcsXHJcbiAgICAgICAgJzxuZy1mb3JtPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwibGFiZWxcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj4nICtcclxuICAgICAgICAgICAgJzxsYWJlbCBmb3I9XCJzdG9yYWdlXCIgZm9ybS1idWlsZGVyLXRvb2x0aXA9XCJXaGljaCBzdG9yYWdlIHRvIHNhdmUgdGhlIGZpbGVzIGluLlwiPlN0b3JhZ2U8L2xhYmVsPicgK1xyXG4gICAgICAgICAgICAnPHNlbGVjdCBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwic3RvcmFnZVwiIG5hbWU9XCJzdG9yYWdlXCIgbmctb3B0aW9ucz1cInN0b3JlLm5hbWUgYXMgc3RvcmUudGl0bGUgZm9yIHN0b3JlIGluIHN0b3JhZ2VcIiBuZy1tb2RlbD1cImNvbXBvbmVudC5zdG9yYWdlXCI+PC9zZWxlY3Q+JyArXHJcbiAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJ1cmxcIiBuZy1zaG93PVwiY29tcG9uZW50LnN0b3JhZ2UgPT09IFxcJ3VybFxcJ1wiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImRpclwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImltYWdlXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiaW1hZ2VTaXplXCIgbmctaWY9XCJjb21wb25lbnQuaW1hZ2VcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJjdXN0b21DbGFzc1wiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInRhYmluZGV4XCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwibXVsdGlwbGVcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJjbGVhck9uSGlkZVwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInByb3RlY3RlZFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInBlcnNpc3RlbnRcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJoaWRkZW5cIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJkaXNhYmxlZFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInRhYmxlVmlld1wiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAnPC9uZy1mb3JtPidcclxuICAgICAgKTtcclxuXHJcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvZmlsZS92YWxpZGF0ZS5odG1sJyxcclxuICAgICAgICAnPG5nLWZvcm0+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJ2YWxpZGF0ZS5yZXF1aXJlZFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAnPC9uZy1mb3JtPidcclxuICAgICAgKTtcclxuICAgIH1cclxuICBdKTtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwcCkge1xyXG4gIGFwcC5jb25maWcoW1xyXG4gICAgJ2Zvcm1pb0NvbXBvbmVudHNQcm92aWRlcicsXHJcbiAgICBmdW5jdGlvbihmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIpIHtcclxuICAgICAgZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyLnJlZ2lzdGVyKCdmb3JtJywge1xyXG4gICAgICAgIGZidGVtcGxhdGU6ICdmb3JtaW8vZm9ybWJ1aWxkZXIvZm9ybS5odG1sJyxcclxuICAgICAgICBpY29uOiAnZmEgZmEtd3Bmb3JtcycsXHJcbiAgICAgICAgdmlld3M6IFtcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0Rpc3BsYXknLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2Zvcm0vZGlzcGxheS5odG1sJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0RhdGEnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9kYXRhLmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQVBJJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jb21tb24vYXBpLmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQ29uZGl0aW9uYWwnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9jb25kaXRpb25hbC5odG1sJ1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgZG9jdW1lbnRhdGlvbjogJ2h0dHA6Ly9oZWxwLmZvcm0uaW8vdXNlcmd1aWRlLyNmb3JtJyxcclxuICAgICAgICBvbkVkaXQ6IFsnJHNjb3BlJywgZnVuY3Rpb24oJHNjb3BlKSB7XHJcbiAgICAgICAgICAkc2NvcGUuZm9ybXMgPSBbXTtcclxuICAgICAgICAgICRzY29wZS5jb21wb25lbnQucHJvamVjdCA9ICRzY29wZS5mb3JtaW8ucHJvamVjdElkO1xyXG4gICAgICAgICAgJHNjb3BlLmZvcm1pby5sb2FkRm9ybXMoe3BhcmFtczoge2xpbWl0OiAxMDB9fSkudGhlbihmdW5jdGlvbihmb3Jtcykge1xyXG4gICAgICAgICAgICAkc2NvcGUuZm9ybXMgPSBmb3JtcztcclxuICAgICAgICAgICAgaWYgKCEkc2NvcGUuY29tcG9uZW50LmZvcm0pIHtcclxuICAgICAgICAgICAgICAkc2NvcGUuY29tcG9uZW50LmZvcm0gPSBmb3Jtc1swXS5faWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1dXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gT3ZlcnJpZGUgdGhlIGNvbnRyb2xsZXIgZm9yIGZvcm0gYnVpbGRpbmcuXHJcbiAgICAgIHZhciBmb3JtQ29tcG9uZW50ID0gZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyLiRnZXQoKS5jb21wb25lbnRzLmZvcm07XHJcbiAgICAgIHZhciBmb3JtQ29udHJvbGxlciA9IGZvcm1Db21wb25lbnQuY29udHJvbGxlcjtcclxuICAgICAgZm9ybUNvbXBvbmVudC5jb250cm9sbGVyID0gW1xyXG4gICAgICAgICckc2NvcGUnLFxyXG4gICAgICAgICckY29udHJvbGxlcicsXHJcbiAgICAgICAgZnVuY3Rpb24oXHJcbiAgICAgICAgICAkc2NvcGUsXHJcbiAgICAgICAgICAkY29udHJvbGxlclxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgaWYgKCEkc2NvcGUuYnVpbGRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gJGNvbnRyb2xsZXIoZm9ybUNvbnRyb2xsZXIsIHskc2NvcGU6ICRzY29wZX0pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICRzY29wZS5mb3JtID0ge307XHJcbiAgICAgICAgICAkc2NvcGUuZm9ybWlvLmxvYWRGb3Jtcyh7cGFyYW1zOiB7bGltaXQ6IDEwMH19KS50aGVuKGZ1bmN0aW9uKGZvcm1zKSB7XHJcbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChmb3JtcywgZnVuY3Rpb24oZm9ybSkge1xyXG4gICAgICAgICAgICAgIGlmIChmb3JtLl9pZCA9PT0gJHNjb3BlLmNvbXBvbmVudC5mb3JtKSB7XHJcbiAgICAgICAgICAgICAgICAkc2NvcGUuZm9ybSA9IGZvcm07XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgXTtcclxuICAgIH1cclxuICBdKTtcclxuICBhcHAucnVuKFtcclxuICAgICckdGVtcGxhdGVDYWNoZScsXHJcbiAgICBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9mb3JtYnVpbGRlci9mb3JtLmh0bWwnLCAnPHNwYW4gY2xhc3M9XCJoaWRkZW4tZWxlbWVudC10ZXh0XCI+e3sgZm9ybS50aXRsZSB9fSB7eyBmb3JtLnR5cGUgfX08L3NwYW4+Jyk7XHJcblxyXG4gICAgICAvLyBDcmVhdGUgdGhlIHNldHRpbmdzIG1hcmt1cC5cclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9mb3JtL2Rpc3BsYXkuaHRtbCcsXHJcbiAgICAgICAgJzxuZy1mb3JtPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwibGFiZWxcIiBsYWJlbD1cIk5hbWVcIiBwbGFjZWhvbGRlcj1cIkVudGVyIHRoZSBuYW1lIGZvciB0aGlzIGZvcm0gZmllbGRcIiB0aXRsZT1cIlRoZSBuYW1lIGZvciB0aGlzIGZpZWxkLiBJdCBpcyBvbmx5IHVzZWQgZm9yIGFkbWluaXN0cmF0aXZlIHB1cnBvc2VzIHN1Y2ggYXMgZ2VuZXJhdGluZyB0aGUgYXV0b21hdGljIHByb3BlcnR5IG5hbWUgaW4gdGhlIEFQSSB0YWIgKHdoaWNoIG1heSBiZSBjaGFuZ2VkIG1hbnVhbGx5KS5cIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj4nICtcclxuICAgICAgICAgICAgJzxsYWJlbCBmb3I9XCJmb3JtXCIgZm9ybS1idWlsZGVyLXRvb2x0aXA9XCJUaGUgZm9ybSB0byBsb2FkIHdpdGhpbiB0aGlzIGZvcm0gY29tcG9uZW50Li5cIj5Gb3JtPC9sYWJlbD4nICtcclxuICAgICAgICAgICAgJzxzZWxlY3QgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBpZD1cImZvcm1cIiBuYW1lPVwiZm9ybVwiIG5nLW9wdGlvbnM9XCJ2YWx1ZS5faWQgYXMgdmFsdWUudGl0bGUgZm9yIHZhbHVlIGluIGZvcm1zXCIgbmctbW9kZWw9XCJjb21wb25lbnQuZm9ybVwiPjwvc2VsZWN0PicgK1xyXG4gICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiY3VzdG9tQ2xhc3NcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJyZWZlcmVuY2VcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJwcm90ZWN0ZWRcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJwZXJzaXN0ZW50XCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwidGFibGVWaWV3XCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICc8L25nLWZvcm0+J1xyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIF0pO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwKSB7XHJcbiAgYXBwLmNvbmZpZyhbXHJcbiAgICAnZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyJyxcclxuICAgIGZ1bmN0aW9uKGZvcm1pb0NvbXBvbmVudHNQcm92aWRlcikge1xyXG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ2hpZGRlbicsIHtcclxuICAgICAgICBmYnRlbXBsYXRlOiAnZm9ybWlvL2Zvcm1idWlsZGVyL2hpZGRlbi5odG1sJyxcclxuICAgICAgICBpY29uOiAnZmEgZmEtdXNlci1zZWNyZXQnLFxyXG4gICAgICAgIHZpZXdzOiBbXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdEaXNwbGF5JyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9oaWRkZW4vZGlzcGxheS5odG1sJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0RhdGEnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9kYXRhLmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnVmFsaWRhdGlvbicsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvaGlkZGVuL3ZhbGlkYXRpb24uaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdBUEknLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9hcGkuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdDb25kaXRpb25hbCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY29tbW9uL2NvbmRpdGlvbmFsLmh0bWwnXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBkb2N1bWVudGF0aW9uOiAnaHR0cDovL2hlbHAuZm9ybS5pby91c2VyZ3VpZGUvI2hpZGRlbidcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbiAgYXBwLnJ1bihbXHJcbiAgICAnJHRlbXBsYXRlQ2FjaGUnLFxyXG4gICAgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vZm9ybWJ1aWxkZXIvaGlkZGVuLmh0bWwnLCAnPHNwYW4gY2xhc3M9XCJoaWRkZW4tZWxlbWVudC10ZXh0XCI+e3sgY29tcG9uZW50LmxhYmVsIH19PC9zcGFuPicpO1xyXG5cclxuICAgICAgLy8gQ3JlYXRlIHRoZSBzZXR0aW5ncyBtYXJrdXAuXHJcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvaGlkZGVuL2Rpc3BsYXkuaHRtbCcsXHJcbiAgICAgICAgJzxuZy1mb3JtPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwibGFiZWxcIiBsYWJlbD1cIk5hbWVcIiBwbGFjZWhvbGRlcj1cIkVudGVyIHRoZSBuYW1lIGZvciB0aGlzIGhpZGRlbiBmaWVsZFwiIHRpdGxlPVwiVGhlIG5hbWUgZm9yIHRoaXMgZmllbGQuIEl0IGlzIG9ubHkgdXNlZCBmb3IgYWRtaW5pc3RyYXRpdmUgcHVycG9zZXMgc3VjaCBhcyBnZW5lcmF0aW5nIHRoZSBhdXRvbWF0aWMgcHJvcGVydHkgbmFtZSBpbiB0aGUgQVBJIHRhYiAod2hpY2ggbWF5IGJlIGNoYW5nZWQgbWFudWFsbHkpLlwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImN1c3RvbUNsYXNzXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwicHJvdGVjdGVkXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwicGVyc2lzdGVudFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInRhYmxlVmlld1wiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAnPC9uZy1mb3JtPidcclxuICAgICAgKTtcclxuXHJcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvaGlkZGVuL3ZhbGlkYXRpb24uaHRtbCcsXHJcbiAgICAgICAgJzxuZy1mb3JtPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwidW5pcXVlXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICc8L25nLWZvcm0+J1xyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIF0pO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwKSB7XHJcbiAgYXBwLmNvbmZpZyhbXHJcbiAgICAnZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyJyxcclxuICAgIGZ1bmN0aW9uKGZvcm1pb0NvbXBvbmVudHNQcm92aWRlcikge1xyXG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ2h0bWxlbGVtZW50Jywge1xyXG4gICAgICAgIGZidGVtcGxhdGU6ICdmb3JtaW8vZm9ybWJ1aWxkZXIvaHRtbGVsZW1lbnQuaHRtbCcsXHJcbiAgICAgICAgaWNvbjogJ2ZhIGZhLWNvZGUnLFxyXG4gICAgICAgIHZpZXdzOiBbXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdEaXNwbGF5JyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9odG1sZWxlbWVudC9kaXNwbGF5Lmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQVBJJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jb21tb24vYXBpLmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQ29uZGl0aW9uYWwnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9jb25kaXRpb25hbC5odG1sJ1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgZG9jdW1lbnRhdGlvbjogJ2h0dHA6Ly9oZWxwLmZvcm0uaW8vdXNlcmd1aWRlLyNodG1sLWVsZW1lbnQtY29tcG9uZW50J1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICBdKTtcclxuICBhcHAucnVuKFtcclxuICAgICckdGVtcGxhdGVDYWNoZScsXHJcbiAgICBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9mb3JtYnVpbGRlci9odG1sZWxlbWVudC5odG1sJyxcclxuICAgICAgICAnPGZvcm1pby1odG1sLWVsZW1lbnQgY29tcG9uZW50PVwiY29tcG9uZW50XCI+PC9kaXY+J1xyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gQ3JlYXRlIHRoZSBzZXR0aW5ncyBtYXJrdXAuXHJcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvaHRtbGVsZW1lbnQvZGlzcGxheS5odG1sJyxcclxuICAgICAgICAnPG5nLWZvcm0+JyArXHJcbiAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiY3VzdG9tQ2xhc3NcIiBsYWJlbD1cIkNvbnRhaW5lciBDdXN0b20gQ2xhc3NcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJ0YWdcIiBsYWJlbD1cIkhUTUwgVGFnXCIgcGxhY2Vob2xkZXI9XCJIVE1MIEVsZW1lbnQgVGFnXCIgdGl0bGU9XCJUaGUgdGFnIG9mIHRoaXMgSFRNTCBlbGVtZW50LlwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImNsYXNzTmFtZVwiIGxhYmVsPVwiQ1NTIENsYXNzXCIgcGxhY2Vob2xkZXI9XCJDU1MgQ2xhc3NcIiB0aXRsZT1cIlRoZSBDU1MgY2xhc3MgZm9yIHRoaXMgSFRNTCBlbGVtZW50LlwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8dmFsdWUtYnVpbGRlciAnICtcclxuICAgICAgICAgICAgJ2RhdGE9XCJjb21wb25lbnQuYXR0cnNcIiAnICtcclxuICAgICAgICAgICAgJ2xhYmVsPVwiQXR0cmlidXRlc1wiICcgK1xyXG4gICAgICAgICAgICAndG9vbHRpcC10ZXh0PVwiVGhlIGF0dHJpYnV0ZXMgZm9yIHRoaXMgSFRNTCBlbGVtZW50LiBPbmx5IHNhZmUgYXR0cmlidXRlcyBhcmUgYWxsb3dlZCwgc3VjaCBhcyBzcmMsIGhyZWYsIGFuZCB0aXRsZS5cIiAnICtcclxuICAgICAgICAgICAgJ3ZhbHVlLXByb3BlcnR5PVwidmFsdWVcIiAnICtcclxuICAgICAgICAgICAgJ2xhYmVsLXByb3BlcnR5PVwiYXR0clwiICcgK1xyXG4gICAgICAgICAgICAndmFsdWUtbGFiZWw9XCJWYWx1ZVwiICcgK1xyXG4gICAgICAgICAgICAnbGFiZWwtbGFiZWw9XCJBdHRyaWJ1dGVcIiAnICtcclxuICAgICAgICAgICAgJ25vLWF1dG9jb21wbGV0ZS12YWx1ZT1cInRydWVcIiAnICtcclxuICAgICAgICAgICc+PC92YWx1ZS1idWlsZGVyPicgK1xyXG4gICAgICAgICAgJzxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+JyArXHJcbiAgICAgICAgICAgICc8bGFiZWwgZm9yPVwiY29udGVudFwiIGZvcm0tYnVpbGRlci10b29sdGlwPVwiVGhlIGNvbnRlbnQgb2YgdGhpcyBIVE1MIGVsZW1lbnQuXCI+Q29udGVudDwvbGFiZWw+JyArXHJcbiAgICAgICAgICAgICc8dGV4dGFyZWEgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBpZD1cImNvbnRlbnRcIiBuYW1lPVwiY29udGVudFwiIG5nLW1vZGVsPVwiY29tcG9uZW50LmNvbnRlbnRcIiBwbGFjZWhvbGRlcj1cIkhUTUwgQ29udGVudFwiIHJvd3M9XCIzXCI+e3sgY29tcG9uZW50LmNvbnRlbnQgfX08L3RleHRhcmVhPicgK1xyXG4gICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICc8L25nLWZvcm0+J1xyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIF0pO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBhcHAgPSBhbmd1bGFyLm1vZHVsZSgnbmdGb3JtQnVpbGRlcicpO1xyXG5cclxuLy8gQmFzaWNcclxucmVxdWlyZSgnLi9jb21wb25lbnRzJykoYXBwKTtcclxucmVxdWlyZSgnLi90ZXh0ZmllbGQnKShhcHApO1xyXG5yZXF1aXJlKCcuL251bWJlcicpKGFwcCk7XHJcbnJlcXVpcmUoJy4vcGFzc3dvcmQnKShhcHApO1xyXG5yZXF1aXJlKCcuL3RleHRhcmVhJykoYXBwKTtcclxucmVxdWlyZSgnLi9jaGVja2JveCcpKGFwcCk7XHJcbnJlcXVpcmUoJy4vc2VsZWN0Ym94ZXMnKShhcHApO1xyXG5yZXF1aXJlKCcuL3NlbGVjdCcpKGFwcCk7XHJcbnJlcXVpcmUoJy4vcmFkaW8nKShhcHApO1xyXG5yZXF1aXJlKCcuL2h0bWxlbGVtZW50JykoYXBwKTtcclxucmVxdWlyZSgnLi9jb250ZW50JykoYXBwKTtcclxucmVxdWlyZSgnLi9idXR0b24nKShhcHApO1xyXG5cclxuLy8gU3BlY2lhbFxyXG5yZXF1aXJlKCcuL2VtYWlsJykoYXBwKTtcclxucmVxdWlyZSgnLi9waG9uZW51bWJlcicpKGFwcCk7XHJcbnJlcXVpcmUoJy4vYWRkcmVzcycpKGFwcCk7XHJcbnJlcXVpcmUoJy4vZGF0ZXRpbWUnKShhcHApO1xyXG5yZXF1aXJlKCcuL2RheScpKGFwcCk7XHJcbnJlcXVpcmUoJy4vY3VycmVuY3knKShhcHApO1xyXG5yZXF1aXJlKCcuL2hpZGRlbicpKGFwcCk7XHJcbnJlcXVpcmUoJy4vcmVzb3VyY2UnKShhcHApO1xyXG5yZXF1aXJlKCcuL2ZpbGUnKShhcHApO1xyXG5yZXF1aXJlKCcuL2Zvcm0nKShhcHApO1xyXG5yZXF1aXJlKCcuL3NpZ25hdHVyZScpKGFwcCk7XHJcbnJlcXVpcmUoJy4vY3VzdG9tJykoYXBwKTtcclxucmVxdWlyZSgnLi9kYXRhZ3JpZCcpKGFwcCk7XHJcbnJlcXVpcmUoJy4vc3VydmV5JykoYXBwKTtcclxuXHJcbi8vIExheW91dFxyXG5yZXF1aXJlKCcuL2NvbHVtbnMnKShhcHApO1xyXG5yZXF1aXJlKCcuL2ZpZWxkc2V0JykoYXBwKTtcclxucmVxdWlyZSgnLi9jb250YWluZXInKShhcHApO1xyXG5yZXF1aXJlKCcuL3BhZ2UnKShhcHApO1xyXG5yZXF1aXJlKCcuL3BhbmVsJykoYXBwKTtcclxucmVxdWlyZSgnLi90YWJsZScpKGFwcCk7XHJcbnJlcXVpcmUoJy4vd2VsbCcpKGFwcCk7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApIHtcclxuICBhcHAuY29uZmlnKFtcclxuICAgICdmb3JtaW9Db21wb25lbnRzUHJvdmlkZXInLFxyXG4gICAgZnVuY3Rpb24oZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyKSB7XHJcbiAgICAgIGZvcm1pb0NvbXBvbmVudHNQcm92aWRlci5yZWdpc3RlcignbnVtYmVyJywge1xyXG4gICAgICAgIGljb246ICdmYSBmYS1oYXNodGFnJyxcclxuICAgICAgICB2aWV3czogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnRGlzcGxheScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvbnVtYmVyL2Rpc3BsYXkuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdEYXRhJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jb21tb24vZGF0YS5odG1sJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1ZhbGlkYXRpb24nLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL251bWJlci92YWxpZGF0ZS5odG1sJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0FQSScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY29tbW9uL2FwaS5odG1sJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0xheW91dCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY29tbW9uL2xheW91dC5odG1sJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0NvbmRpdGlvbmFsJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jb21tb24vY29uZGl0aW9uYWwuaHRtbCdcclxuICAgICAgICAgIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIGRvY3VtZW50YXRpb246ICdodHRwOi8vaGVscC5mb3JtLmlvL3VzZXJndWlkZS8jbnVtYmVyJ1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICBdKTtcclxuICBhcHAucnVuKFtcclxuICAgICckdGVtcGxhdGVDYWNoZScsXHJcbiAgICBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICAgICAvLyBDcmVhdGUgdGhlIHNldHRpbmdzIG1hcmt1cC5cclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9udW1iZXIvZGlzcGxheS5odG1sJyxcclxuICAgICAgICAnPG5nLWZvcm0+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJsYWJlbFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInBsYWNlaG9sZGVyXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiZGVzY3JpcHRpb25cIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJ2YWxpZGF0ZS5zdGVwXCIgbGFiZWw9XCJJbmNyZW1lbnQgKFN0ZXApXCIgcGxhY2Vob2xkZXI9XCJFbnRlciBob3cgbXVjaCB0byBpbmNyZW1lbnQgcGVyIHN0ZXAgKG9yIHByZWNpc2lvbikuXCIgdGl0bGU9XCJUaGUgYW1vdW50IHRvIGluY3JlbWVudC9kZWNyZW1lbnQgZm9yIGVhY2ggc3RlcC5cIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJwcmVmaXhcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJzdWZmaXhcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJjdXN0b21DbGFzc1wiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInRhYmluZGV4XCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwibXVsdGlwbGVcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJjbGVhck9uSGlkZVwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInByb3RlY3RlZFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInBlcnNpc3RlbnRcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJoaWRkZW5cIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJkaXNhYmxlZFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInRhYmxlVmlld1wiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAnPC9uZy1mb3JtPidcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIENyZWF0ZSB0aGUgQVBJIG1hcmt1cC5cclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9udW1iZXIvdmFsaWRhdGUuaHRtbCcsXHJcbiAgICAgICAgJzxuZy1mb3JtPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwidmFsaWRhdGUucmVxdWlyZWRcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJ2YWxpZGF0ZS5taW5cIiB0eXBlPVwibnVtYmVyXCIgbGFiZWw9XCJNaW5pbXVtIFZhbHVlXCIgcGxhY2Vob2xkZXI9XCJNaW5pbXVtIFZhbHVlXCIgdGl0bGU9XCJUaGUgbWluaW11bSB2YWx1ZSB0aGlzIGZpZWxkIG11c3QgaGF2ZSBiZWZvcmUgdGhlIGZvcm0gY2FuIGJlIHN1Ym1pdHRlZC5cIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJ2YWxpZGF0ZS5tYXhcIiB0eXBlPVwibnVtYmVyXCIgbGFiZWw9XCJNYXhpbXVtIFZhbHVlXCIgcGxhY2Vob2xkZXI9XCJNYXhpbXVtIFZhbHVlXCIgdGl0bGU9XCJUaGUgbWF4aW11bSB2YWx1ZSB0aGlzIGZpZWxkIG11c3QgaGF2ZSBiZWZvcmUgdGhlIGZvcm0gY2FuIGJlIHN1Ym1pdHRlZC5cIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24tY3VzdG9tLXZhbGlkYXRpb24+PC9mb3JtLWJ1aWxkZXItb3B0aW9uLWN1c3RvbS12YWxpZGF0aW9uPicgK1xyXG4gICAgICAgICc8L25nLWZvcm0+J1xyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIF0pO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwKSB7XHJcbiAgYXBwLmNvbmZpZyhbXHJcbiAgICAnZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyJyxcclxuICAgIGZ1bmN0aW9uKGZvcm1pb0NvbXBvbmVudHNQcm92aWRlcikge1xyXG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ3BhZ2UnLCB7XHJcbiAgICAgICAgZmJ0ZW1wbGF0ZTogJ2Zvcm1pby9mb3JtYnVpbGRlci9wYWdlLmh0bWwnXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIF0pO1xyXG4gIGFwcC5ydW4oW1xyXG4gICAgJyR0ZW1wbGF0ZUNhY2hlJyxcclxuICAgIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2Zvcm1idWlsZGVyL3BhZ2UuaHRtbCcsXHJcbiAgICAgICAgJzxmb3JtLWJ1aWxkZXItbGlzdCBjb21wb25lbnQ9XCJjb21wb25lbnRcIiBmb3JtPVwiZm9ybVwiIGZvcm1pbz1cIjo6Zm9ybWlvXCI+PC9mb3JtLWJ1aWxkZXItbGlzdD4nXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApIHtcclxuICBhcHAuY29uZmlnKFtcclxuICAgICdmb3JtaW9Db21wb25lbnRzUHJvdmlkZXInLFxyXG4gICAgJ0ZPUk1fT1BUSU9OUycsXHJcbiAgICBmdW5jdGlvbihcclxuICAgICAgZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyLFxyXG4gICAgICBGT1JNX09QVElPTlNcclxuICAgICkge1xyXG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ3BhbmVsJywge1xyXG4gICAgICAgIGZidGVtcGxhdGU6ICdmb3JtaW8vZm9ybWJ1aWxkZXIvcGFuZWwuaHRtbCcsXHJcbiAgICAgICAgaWNvbjogJ2ZhIGZhLWxpc3QtYWx0JyxcclxuICAgICAgICBvbkVkaXQ6IFsnJHNjb3BlJywgZnVuY3Rpb24oJHNjb3BlKSB7XHJcbiAgICAgICAgICAkc2NvcGUudGhlbWVzID0gRk9STV9PUFRJT05TLnRoZW1lcztcclxuICAgICAgICAgIGlmICghJHNjb3BlLmNvbXBvbmVudC5icmVhZGNydW1iKSB7XHJcbiAgICAgICAgICAgICRzY29wZS5jb21wb25lbnQuYnJlYWRjcnVtYiA9ICdkZWZhdWx0JztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgICRzY29wZS5icmVhZGNydW1icyA9IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIG5hbWU6ICdkZWZhdWx0JyxcclxuICAgICAgICAgICAgICB0aXRsZTogJ1llcydcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIG5hbWU6ICdub25lJyxcclxuICAgICAgICAgICAgICB0aXRsZTogJ05vJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICBdO1xyXG4gICAgICAgIH1dLFxyXG4gICAgICAgIHZpZXdzOiBbXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdEaXNwbGF5JyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9wYW5lbC9kaXNwbGF5Lmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnTGF5b3V0JyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jb21tb24vbGF5b3V0Lmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQVBJJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jb21tb24vYXBpLmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQ29uZGl0aW9uYWwnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL3BhbmVsL2NvbmRpdGlvbmFsLmh0bWwnXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBkb2N1bWVudGF0aW9uOiAnaHR0cDovL2hlbHAuZm9ybS5pby91c2VyZ3VpZGUvI3BhbmVscycsXHJcbiAgICAgICAgbm9EbmRPdmVybGF5OiB0cnVlLFxyXG4gICAgICAgIGNvbmZpcm1SZW1vdmU6IHRydWVcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbiAgYXBwLnJ1bihbXHJcbiAgICAnJHRlbXBsYXRlQ2FjaGUnLFxyXG4gICAgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vZm9ybWJ1aWxkZXIvcGFuZWwuaHRtbCcsXHJcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJwYW5lbCBwYW5lbC17eyBjb21wb25lbnQudGhlbWUgfX1cIj4nICtcclxuICAgICAgICAgICc8ZGl2IG5nLWlmPVwiY29tcG9uZW50LnRpdGxlXCIgY2xhc3M9XCJwYW5lbC1oZWFkaW5nXCI+PGgzIGNsYXNzPVwicGFuZWwtdGl0bGVcIj57eyBjb21wb25lbnQudGl0bGUgfX08L2gzPjwvZGl2PicgK1xyXG4gICAgICAgICAgJzxkaXYgY2xhc3M9XCJwYW5lbC1ib2R5XCI+JyArXHJcbiAgICAgICAgICAgICc8Zm9ybS1idWlsZGVyLWxpc3QgY29tcG9uZW50PVwiY29tcG9uZW50XCIgZm9ybT1cImZvcm1cIiBmb3JtaW89XCI6OmZvcm1pb1wiPjwvZm9ybS1idWlsZGVyLWxpc3Q+JyArXHJcbiAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgJzwvZGl2PidcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIENyZWF0ZSB0aGUgc2V0dGluZ3MgbWFya3VwLlxyXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL3BhbmVsL2Rpc3BsYXkuaHRtbCcsXHJcbiAgICAgICAgJzxuZy1mb3JtPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwidGl0bGVcIiBsYWJlbD1cIlRpdGxlXCIgcGxhY2Vob2xkZXI9XCJQYW5lbCBUaXRsZVwiIHRpdGxlPVwiVGhlIHRpdGxlIHRleHQgdGhhdCBhcHBlYXJzIGluIHRoZSBoZWFkZXIgb2YgdGhpcyBwYW5lbC5cIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj4nICtcclxuICAgICAgICAgICAgJzxsYWJlbCBmb3I9XCJ0aGVtZVwiIGZvcm0tYnVpbGRlci10b29sdGlwPVwiVGhlIGNvbG9yIHRoZW1lIG9mIHRoaXMgcGFuZWwuXCI+VGhlbWU8L2xhYmVsPicgK1xyXG4gICAgICAgICAgICAnPHNlbGVjdCBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwidGhlbWVcIiBuYW1lPVwidGhlbWVcIiBuZy1vcHRpb25zPVwidGhlbWUubmFtZSBhcyB0aGVtZS50aXRsZSBmb3IgdGhlbWUgaW4gdGhlbWVzXCIgbmctbW9kZWw9XCJjb21wb25lbnQudGhlbWVcIj48L3NlbGVjdD4nICtcclxuICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPicgK1xyXG4gICAgICAgICAgICAnPGxhYmVsIGZvcj1cImJyZWFkY3J1bWJcIiBmb3JtLWJ1aWxkZXItdG9vbHRpcD1cIlRoZSBicmVhZGNydW1iIHRvIHNob3cgd2l0aCB0aGlzIHBhZ2UuXCI+U2hvdyBCcmVhZGNydW1iPC9sYWJlbD4nICtcclxuICAgICAgICAgICAgJzxzZWxlY3QgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBpZD1cImJyZWFkY3J1bWJcIiBuYW1lPVwiYnJlYWRjcnVtYlwiIG5nLW9wdGlvbnM9XCJicmVhZGNydW1iLm5hbWUgYXMgYnJlYWRjcnVtYi50aXRsZSBmb3IgYnJlYWRjcnVtYiBpbiBicmVhZGNydW1ic1wiIG5nLW1vZGVsPVwiY29tcG9uZW50LmJyZWFkY3J1bWJcIj48L3NlbGVjdD4nICtcclxuICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImN1c3RvbUNsYXNzXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICc8L25nLWZvcm0+J1xyXG4gICAgICApO1xyXG5cclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9wYW5lbC9jb25kaXRpb25hbC5odG1sJyxcclxuICAgICAgICAnPGZvcm0tYnVpbGRlci1jb25kaXRpb25hbD48L2Zvcm0tYnVpbGRlci1jb25kaXRpb25hbD4nICtcclxuICAgICAgICAnPHVpYi1hY2NvcmRpb24+JyArXHJcbiAgICAgICAgICAnPGRpdiB1aWItYWNjb3JkaW9uLWdyb3VwIGhlYWRpbmc9XCJBZHZhbmNlZCBOZXh0IFBhZ2VcIiBjbGFzcz1cInBhbmVsIHBhbmVsLWRlZmF1bHRcIj4nICtcclxuICAgICAgICAgICAgJzx0ZXh0YXJlYSBjbGFzcz1cImZvcm0tY29udHJvbFwiIHJvd3M9XCI1XCIgaWQ9XCJjdXN0b21cIiBuYW1lPVwiY3VzdG9tXCIgbmctbW9kZWw9XCJjb21wb25lbnQubmV4dFBhZ2VcIiBwbGFjZWhvbGRlcj1cIi8qKiogRXhhbXBsZSBDb2RlICoqKi9cXG5uZXh0ID0gKGRhdGFbXFwnbXlrZXlcXCddID4gMSkgPyBcXCdwYWdlQVxcJyA6IFxcJ3BhZ2VCXFwnO1wiPjwvdGV4dGFyZWE+JyArXHJcbiAgICAgICAgICAgICc8c21hbGw+JyArXHJcbiAgICAgICAgICAgICAgJzxwPkVudGVyIGN1c3RvbSBjb25kaXRpb25hbCBjb2RlLjwvcD4nICtcclxuICAgICAgICAgICAgICAnPHA+WW91IG11c3QgYXNzaWduIHRoZSA8c3Ryb25nPm5leHQ8L3N0cm9uZz4gdmFyaWFibGUgd2l0aCB0aGUgQVBJIGtleSBvZiB0aGUgbmV4dCBwYWdlLjwvcD4nICtcclxuICAgICAgICAgICAgICAnPHA+VGhlIGdsb2JhbCB2YXJpYWJsZSA8c3Ryb25nPmRhdGE8L3N0cm9uZz4gaXMgcHJvdmlkZWQsIGFuZCBhbGxvd3MgeW91IHRvIGFjY2VzcyB0aGUgZGF0YSBvZiBhbnkgZm9ybSBjb21wb25lbnQsIGJ5IHVzaW5nIGl0cyBBUEkga2V5LjwvcD4nICtcclxuICAgICAgICAgICAgJzwvc21hbGw+JyArXHJcbiAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAnPGRpdiB1aWItYWNjb3JkaW9uLWdyb3VwIGhlYWRpbmc9XCJKU09OIE5leHQgUGFnZVwiIGNsYXNzPVwicGFuZWwgcGFuZWwtZGVmYXVsdFwiPicgK1xyXG4gICAgICAgICAgICAnPHNtYWxsPicgK1xyXG4gICAgICAgICAgICAgICc8cD5FeGVjdXRlIGN1c3RvbSBuZXh0IHBhZ2Ugd2l0aCBKU09OIGFuZCA8YSBocmVmPVwiaHR0cDovL2pzb25sb2dpYy5jb20vXCI+SnNvbkxvZ2ljPC9hPi48L3A+JyArXHJcbiAgICAgICAgICAgICAgJzxwPlN1Ym1pc3Npb24gZGF0YSBpcyBhdmFpbGFibGUgYXMgSnNvbkxvZ2ljIHZhcmlhYmxlcywgd2l0aCB0aGUgc2FtZSBhcGkga2V5IGFzIHlvdXIgY29tcG9uZW50cy48L3A+JyArXHJcbiAgICAgICAgICAgICAgJzxwPjxhIGhyZWY9XCJodHRwOi8vZm9ybWlvLmdpdGh1Yi5pby9mb3JtaW8uanMvYXBwL2V4YW1wbGVzL211bHRpZm9ybS5odG1sXCIgdGFyZ2V0PVwiX2JsYW5rXCI+Q2xpY2sgaGVyZSBmb3IgYW4gZXhhbXBsZTwvYT48L3A+JyArXHJcbiAgICAgICAgICAgICc8L3NtYWxsPicgK1xyXG4gICAgICAgICAgICAnPHRleHRhcmVhIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgcm93cz1cIjVcIiBpZD1cImpzb25cIiBuYW1lPVwianNvblwiIGpzb24taW5wdXQgbmctbW9kZWw9XCJjb21wb25lbnQubmV4dFBhZ2VcIiBwbGFjZWhvbGRlcj1cInsgLi4uIH1cIj48L3RleHRhcmVhPicgK1xyXG4gICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICc8L3VpYi1hY2NvcmRpb24+J1xyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIF0pO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwKSB7XHJcbiAgYXBwLmNvbmZpZyhbXHJcbiAgICAnZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyJyxcclxuICAgIGZ1bmN0aW9uKGZvcm1pb0NvbXBvbmVudHNQcm92aWRlcikge1xyXG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ3Bhc3N3b3JkJywge1xyXG4gICAgICAgIGljb246ICdmYSBmYS1hc3RlcmlzaycsXHJcbiAgICAgICAgdmlld3M6IFtcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0Rpc3BsYXknLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL3Bhc3N3b3JkL2Rpc3BsYXkuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdWYWxpZGF0aW9uJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy90ZXh0ZmllbGQvdmFsaWRhdGUuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdBUEknLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9hcGkuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdMYXlvdXQnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9sYXlvdXQuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdDb25kaXRpb25hbCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY29tbW9uL2NvbmRpdGlvbmFsLmh0bWwnXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBkb2N1bWVudGF0aW9uOiAnaHR0cDovL2hlbHAuZm9ybS5pby91c2VyZ3VpZGUvI3Bhc3N3b3JkJyxcclxuICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL3Bhc3N3b3JkLmh0bWwnXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIF0pO1xyXG4gIGFwcC5ydW4oW1xyXG4gICAgJyR0ZW1wbGF0ZUNhY2hlJyxcclxuICAgIGZ1bmN0aW9uKFxyXG4gICAgICAkdGVtcGxhdGVDYWNoZVxyXG4gICAgKSB7XHJcbiAgICAgIC8vIERpc2FibGUgZHJhZ2dpbmcgb24gcGFzc3dvcmQgaW5wdXRzIGJlY2F1c2UgaXQgYnJlYWtzIGRuZExpc3RzXHJcbiAgICAgIHZhciB0ZXh0RmllbGRUbXBsID0gJHRlbXBsYXRlQ2FjaGUuZ2V0KCdmb3JtaW8vY29tcG9uZW50cy90ZXh0ZmllbGQuaHRtbCcpO1xyXG4gICAgICB2YXIgcGFzc3dvcmRUbXBsID0gdGV4dEZpZWxkVG1wbC5yZXBsYWNlKFxyXG4gICAgICAgIC88aW5wdXQgdHlwZT1cInt7IGNvbXBvbmVudC5pbnB1dFR5cGUgfX1cIiAvZyxcclxuICAgICAgICAnPGlucHV0IHR5cGU9XCJ7eyBjb21wb25lbnQuaW5wdXRUeXBlIH19XCIgZG5kLW5vZHJhZyAnXHJcbiAgICAgICk7XHJcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvcGFzc3dvcmQuaHRtbCcsIHBhc3N3b3JkVG1wbCk7XHJcblxyXG4gICAgICAvLyBDcmVhdGUgdGhlIHNldHRpbmdzIG1hcmt1cC5cclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9wYXNzd29yZC9kaXNwbGF5Lmh0bWwnLFxyXG4gICAgICAgICc8bmctZm9ybT4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImxhYmVsXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwicGxhY2Vob2xkZXJcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJkZXNjcmlwdGlvblwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInByZWZpeFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInN1ZmZpeFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImN1c3RvbUNsYXNzXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwidGFiaW5kZXhcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJjbGVhck9uSGlkZVwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInByb3RlY3RlZFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInBlcnNpc3RlbnRcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJoaWRkZW5cIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJkaXNhYmxlZFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInRhYmxlVmlld1wiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAnPC9uZy1mb3JtPidcclxuICAgICAgKTtcclxuICAgIH1cclxuICBdKTtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwcCkge1xyXG4gIGFwcC5jb25maWcoW1xyXG4gICAgJ2Zvcm1pb0NvbXBvbmVudHNQcm92aWRlcicsXHJcbiAgICBmdW5jdGlvbihmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIpIHtcclxuICAgICAgZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyLnJlZ2lzdGVyKCdwaG9uZU51bWJlcicsIHtcclxuICAgICAgICBpY29uOiAnZmEgZmEtcGhvbmUtc3F1YXJlJyxcclxuICAgICAgICB2aWV3czogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnRGlzcGxheScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvcGhvbmVOdW1iZXIvZGlzcGxheS5odG1sJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0RhdGEnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9kYXRhLmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnVmFsaWRhdGlvbicsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvcGhvbmVOdW1iZXIvdmFsaWRhdGUuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdBUEknLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9hcGkuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdMYXlvdXQnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9sYXlvdXQuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdDb25kaXRpb25hbCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY29tbW9uL2NvbmRpdGlvbmFsLmh0bWwnXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBkb2N1bWVudGF0aW9uOiAnaHR0cDovL2hlbHAuZm9ybS5pby91c2VyZ3VpZGUvI3Bob25lbnVtYmVyJ1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICBdKTtcclxuICBhcHAucnVuKFtcclxuICAgICckdGVtcGxhdGVDYWNoZScsXHJcbiAgICBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICAgICAvLyBDcmVhdGUgdGhlIHNldHRpbmdzIG1hcmt1cC5cclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9waG9uZU51bWJlci9kaXNwbGF5Lmh0bWwnLFxyXG4gICAgICAgICc8bmctZm9ybT4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImxhYmVsXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwicGxhY2Vob2xkZXJcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJkZXNjcmlwdGlvblwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImlucHV0TWFza1wiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInByZWZpeFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInN1ZmZpeFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImN1c3RvbUNsYXNzXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwidGFiaW5kZXhcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJtdWx0aXBsZVwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImNsZWFyT25IaWRlXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwicHJvdGVjdGVkXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwicGVyc2lzdGVudFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImhpZGRlblwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImRpc2FibGVkXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwidGFibGVWaWV3XCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICc8L25nLWZvcm0+J1xyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gQ3JlYXRlIHRoZSBWYWxpZGF0aW9uIG1hcmt1cC5cclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9waG9uZU51bWJlci92YWxpZGF0ZS5odG1sJyxcclxuICAgICAgICAnPG5nLWZvcm0+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJ2YWxpZGF0ZS5yZXF1aXJlZFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInVuaXF1ZVwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAnPC9uZy1mb3JtPidcclxuICAgICAgKTtcclxuICAgIH1cclxuICBdKTtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwcCkge1xyXG4gIGFwcC5jb25maWcoW1xyXG4gICAgJ2Zvcm1pb0NvbXBvbmVudHNQcm92aWRlcicsXHJcbiAgICBmdW5jdGlvbihmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIpIHtcclxuICAgICAgZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyLnJlZ2lzdGVyKCdyYWRpbycsIHtcclxuICAgICAgICBpY29uOiAnZmEgZmEtZG90LWNpcmNsZS1vJyxcclxuICAgICAgICB2aWV3czogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnRGlzcGxheScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvcmFkaW8vZGlzcGxheS5odG1sJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0RhdGEnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9kYXRhLmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnVmFsaWRhdGlvbicsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvcmFkaW8vdmFsaWRhdGUuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdBUEknLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9hcGkuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdMYXlvdXQnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9sYXlvdXQuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdDb25kaXRpb25hbCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY29tbW9uL2NvbmRpdGlvbmFsLmh0bWwnXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBkb2N1bWVudGF0aW9uOiAnaHR0cDovL2hlbHAuZm9ybS5pby91c2VyZ3VpZGUvI3JhZGlvJ1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICBdKTtcclxuICBhcHAucnVuKFtcclxuICAgICckdGVtcGxhdGVDYWNoZScsXHJcbiAgICBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICAgICAvLyBDcmVhdGUgdGhlIHNldHRpbmdzIG1hcmt1cC5cclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9yYWRpby9kaXNwbGF5Lmh0bWwnLFxyXG4gICAgICAgICc8bmctZm9ybT4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImxhYmVsXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzx2YWx1ZS1idWlsZGVyIGRhdGE9XCJjb21wb25lbnQudmFsdWVzXCIgZGVmYXVsdD1cImNvbXBvbmVudC5kZWZhdWx0VmFsdWVcIiBsYWJlbD1cIlZhbHVlc1wiIHRvb2x0aXAtdGV4dD1cIlRoZSByYWRpbyBidXR0b24gdmFsdWVzIHRoYXQgY2FuIGJlIHBpY2tlZCBmb3IgdGhpcyBmaWVsZC4gVmFsdWVzIGFyZSB0ZXh0IHN1Ym1pdHRlZCB3aXRoIHRoZSBmb3JtIGRhdGEuIExhYmVscyBhcmUgdGV4dCB0aGF0IGFwcGVhcnMgbmV4dCB0byB0aGUgcmFkaW8gYnV0dG9ucyBvbiB0aGUgZm9ybS5cIj48L3ZhbHVlLWJ1aWxkZXI+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJjdXN0b21DbGFzc1wiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInRhYmluZGV4XCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiaW5saW5lXCIgdHlwZT1cImNoZWNrYm94XCIgbGFiZWw9XCJJbmxpbmUgTGF5b3V0XCIgdGl0bGU9XCJEaXNwbGF5cyB0aGUgcmFkaW8gYnV0dG9ucyBob3Jpem9udGFsbHkuXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiY2xlYXJPbkhpZGVcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJwcm90ZWN0ZWRcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJwZXJzaXN0ZW50XCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiaGlkZGVuXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiZGlzYWJsZWRcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJ0YWJsZVZpZXdcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgJzwvbmctZm9ybT4nXHJcbiAgICAgICk7XHJcbiAgICAgIC8vIENyZWF0ZSB0aGUgQVBJIG1hcmt1cC5cclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9yYWRpby92YWxpZGF0ZS5odG1sJyxcclxuICAgICAgICAnPG5nLWZvcm0+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJ2YWxpZGF0ZS5yZXF1aXJlZFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbi1jdXN0b20tdmFsaWRhdGlvbj48L2Zvcm0tYnVpbGRlci1vcHRpb24tY3VzdG9tLXZhbGlkYXRpb24+JyArXHJcbiAgICAgICAgJzwvbmctZm9ybT4nXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApIHtcclxuICBhcHAuY29uZmlnKFtcclxuICAgICdmb3JtaW9Db21wb25lbnRzUHJvdmlkZXInLFxyXG4gICAgZnVuY3Rpb24oZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyKSB7XHJcbiAgICAgIGZvcm1pb0NvbXBvbmVudHNQcm92aWRlci5yZWdpc3RlcigncmVzb3VyY2UnLCB7XHJcbiAgICAgICAgb25FZGl0OiBbJyRzY29wZScsIGZ1bmN0aW9uKCRzY29wZSkge1xyXG4gICAgICAgICAgJHNjb3BlLnJlc291cmNlcyA9IFtdO1xyXG4gICAgICAgICAgJHNjb3BlLmNvbXBvbmVudC5wcm9qZWN0ID0gJHNjb3BlLmZvcm1pby5wcm9qZWN0SWQ7XHJcbiAgICAgICAgICAkc2NvcGUuZm9ybWlvLmxvYWRGb3Jtcyh7cGFyYW1zOiB7dHlwZTogJ3Jlc291cmNlJywgbGltaXQ6IDEwMH19KS50aGVuKGZ1bmN0aW9uKHJlc291cmNlcykge1xyXG4gICAgICAgICAgICAkc2NvcGUucmVzb3VyY2VzID0gcmVzb3VyY2VzO1xyXG4gICAgICAgICAgICBpZiAoISRzY29wZS5jb21wb25lbnQucmVzb3VyY2UpIHtcclxuICAgICAgICAgICAgICAkc2NvcGUuY29tcG9uZW50LnJlc291cmNlID0gcmVzb3VyY2VzWzBdLl9pZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfV0sXHJcbiAgICAgICAgaWNvbjogJ2ZhIGZhLWZpbGVzLW8nLFxyXG4gICAgICAgIHZpZXdzOiBbXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdEaXNwbGF5JyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9yZXNvdXJjZS9kaXNwbGF5Lmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnVmFsaWRhdGlvbicsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvcmVzb3VyY2UvdmFsaWRhdGUuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdBUEknLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9hcGkuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdMYXlvdXQnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9sYXlvdXQuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdDb25kaXRpb25hbCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY29tbW9uL2NvbmRpdGlvbmFsLmh0bWwnXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBkb2N1bWVudGF0aW9uOiAnaHR0cDovL2hlbHAuZm9ybS5pby91c2VyZ3VpZGUvI3Jlc291cmNlJ1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICBdKTtcclxuICBhcHAucnVuKFtcclxuICAgICckdGVtcGxhdGVDYWNoZScsXHJcbiAgICBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICAgICAvLyBDcmVhdGUgdGhlIHNldHRpbmdzIG1hcmt1cC5cclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9yZXNvdXJjZS9kaXNwbGF5Lmh0bWwnLFxyXG4gICAgICAgICc8bmctZm9ybT4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImxhYmVsXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwicGxhY2Vob2xkZXJcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj4nICtcclxuICAgICAgICAgICAgJzxsYWJlbCBmb3I9XCJyZXNvdXJjZVwiIGZvcm0tYnVpbGRlci10b29sdGlwPVwiVGhlIHJlc291cmNlIHRvIGJlIHVzZWQgd2l0aCB0aGlzIGZpZWxkLlwiPlJlc291cmNlPC9sYWJlbD4nICtcclxuICAgICAgICAgICAgJzxzZWxlY3QgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBpZD1cInJlc291cmNlXCIgbmFtZT1cInJlc291cmNlXCIgbmctb3B0aW9ucz1cInZhbHVlLl9pZCBhcyB2YWx1ZS50aXRsZSBmb3IgdmFsdWUgaW4gcmVzb3VyY2VzXCIgbmctbW9kZWw9XCJjb21wb25lbnQucmVzb3VyY2VcIj48L3NlbGVjdD4nICtcclxuICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPicgK1xyXG4gICAgICAgICAgICAnPGxhYmVsIGZvcj1cInNlbGVjdEZpZWxkc1wiIGZvcm0tYnVpbGRlci10b29sdGlwPVwiVGhlIHByb3BlcnRpZXMgb24gdGhlIHJlc291cmNlIHRvIHJldHVybiBhcyBwYXJ0IG9mIHRoZSBvcHRpb25zLiBTZXBhcmF0ZSBwcm9wZXJ0eSBuYW1lcyBieSBjb21tYXMuIElmIGxlZnQgYmxhbmssIGFsbCBwcm9wZXJ0aWVzIHdpbGwgYmUgcmV0dXJuZWQuXCI+U2VsZWN0IEZpZWxkczwvbGFiZWw+JyArXHJcbiAgICAgICAgICAgICc8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwic2VsZWN0RmllbGRzXCIgbmFtZT1cInNlbGVjdEZpZWxkc1wiIG5nLW1vZGVsPVwiY29tcG9uZW50LnNlbGVjdEZpZWxkc1wiIHBsYWNlaG9sZGVyPVwiQ29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgZmllbGRzIHRvIHNlbGVjdC5cIiB2YWx1ZT1cInt7IGNvbXBvbmVudC5zZWxlY3RGaWVsZHMgfX1cIj4nICtcclxuICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPicgK1xyXG4gICAgICAgICAgICAnPGxhYmVsIGZvcj1cInNlYXJjaEZpZWxkc1wiIGZvcm0tYnVpbGRlci10b29sdGlwPVwiQSBsaXN0IG9mIHNlYXJjaCBmaWx0ZXJzIGJhc2VkIG9uIHRoZSBmaWVsZHMgb2YgdGhlIHJlc291cmNlLiBTZWUgdGhlIDxhIHRhcmdldD1cXCdfYmxhbmtcXCcgaHJlZj1cXCdodHRwczovL2dpdGh1Yi5jb20vdHJhdmlzdC9yZXNvdXJjZWpzI2ZpbHRlcmluZy10aGUtcmVzdWx0c1xcJz5SZXNvdXJjZS5qcyBkb2N1bWVudGF0aW9uPC9hPiBmb3IgdGhlIGZvcm1hdCBvZiB0aGVzZSBmaWx0ZXJzLlwiPlNlYXJjaCBGaWVsZHM8L2xhYmVsPicgK1xyXG4gICAgICAgICAgICAnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBpZD1cInNlYXJjaEZpZWxkc1wiIG5hbWU9XCJzZWFyY2hGaWVsZHNcIiBuZy1tb2RlbD1cImNvbXBvbmVudC5zZWFyY2hGaWVsZHNcIiBuZy1saXN0IHBsYWNlaG9sZGVyPVwiVGhlIGZpZWxkcyB0byBxdWVyeSBvbiB0aGUgc2VydmVyXCIgdmFsdWU9XCJ7eyBjb21wb25lbnQuc2VhcmNoRmllbGRzIH19XCI+JyArXHJcbiAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAnPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj4nICtcclxuICAgICAgICAgICAgJzxsYWJlbCBmb3I9XCJ0ZW1wbGF0ZVwiIGZvcm0tYnVpbGRlci10b29sdGlwPVwiVGhlIEhUTUwgdGVtcGxhdGUgZm9yIHRoZSByZXN1bHQgZGF0YSBpdGVtcy5cIj5JdGVtIFRlbXBsYXRlPC9sYWJlbD4nICtcclxuICAgICAgICAgICAgJzx0ZXh0YXJlYSBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwidGVtcGxhdGVcIiBuYW1lPVwidGVtcGxhdGVcIiBuZy1tb2RlbD1cImNvbXBvbmVudC50ZW1wbGF0ZVwiIHJvd3M9XCIzXCI+e3sgY29tcG9uZW50LnRlbXBsYXRlIH19PC90ZXh0YXJlYT4nICtcclxuICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImN1c3RvbUNsYXNzXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwidGFiaW5kZXhcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJtdWx0aXBsZVwiIGxhYmVsPVwiQWxsb3cgTXVsdGlwbGUgUmVzb3VyY2VzXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiY2xlYXJPbkhpZGVcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJyZWZlcmVuY2VcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJhZGRSZXNvdXJjZVwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImFkZFJlc291cmNlTGFiZWxcIiBuZy1pZj1cImNvbXBvbmVudC5hZGRSZXNvdXJjZVwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImRpc2FibGVkXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiaGlkZGVuXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwidGFibGVWaWV3XCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICc8L25nLWZvcm0+J1xyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gQ3JlYXRlIHRoZSBBUEkgbWFya3VwLlxyXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL3Jlc291cmNlL3ZhbGlkYXRlLmh0bWwnLFxyXG4gICAgICAgICc8bmctZm9ybT4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInZhbGlkYXRlLnJlcXVpcmVkXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICc8L25nLWZvcm0+J1xyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIF0pO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfY2xvbmUgPSByZXF1aXJlKCdsb2Rhc2gvY2xvbmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFwcCkge1xuICBhcHAuY29uZmlnKFtcbiAgICAnZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyJyxcbiAgICBmdW5jdGlvbiAoZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyKSB7XG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ3NlbGVjdCcsIHtcbiAgICAgICAgaWNvbjogJ2ZhIGZhLXRoLWxpc3QnLFxuICAgICAgICB2aWV3czogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdEaXNwbGF5JyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvc2VsZWN0L2Rpc3BsYXkuaHRtbCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdEYXRhJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvc2VsZWN0L2RhdGEuaHRtbCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdWYWxpZGF0aW9uJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvc2VsZWN0L3ZhbGlkYXRlLmh0bWwnXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnQVBJJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY29tbW9uL2FwaS5odG1sJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0xheW91dCcsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9sYXlvdXQuaHRtbCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdDb25kaXRpb25hbCcsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9jb25kaXRpb25hbC5odG1sJ1xuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgb25FZGl0OiBbJyRzY29wZScsICdGb3JtaW9VdGlscycsIGZ1bmN0aW9uICgkc2NvcGUsIEZvcm1pb1V0aWxzKSB7XG4gICAgICAgICAgJHNjb3BlLmRhdGFTb3VyY2VzID0ge1xuICAgICAgICAgICAgdmFsdWVzOiAnVmFsdWVzJyxcbiAgICAgICAgICAgIGpzb246ICdSYXcgSlNPTicsXG4gICAgICAgICAgICB1cmw6ICdVUkwnLFxuICAgICAgICAgICAgcmVzb3VyY2U6ICdSZXNvdXJjZScsXG4gICAgICAgICAgICBjdXN0b206ICdDdXN0b20nXG4gICAgICAgICAgfTtcbiAgICAgICAgICAkc2NvcGUucmVzb3VyY2VzID0gW107XG4gICAgICAgICAgJHNjb3BlLnJlc291cmNlRmllbGRzID0gW107XG5cbiAgICAgICAgICAvLyBSZXR1cm5zIG9ubHkgaW5wdXQgZmllbGRzIHdlIGFyZSBpbnRlcmVzdGVkIGluLlxuICAgICAgICAgIHZhciBnZXRJbnB1dEZpZWxkcyA9IGZ1bmN0aW9uIChjb21wb25lbnRzKSB7XG4gICAgICAgICAgICB2YXIgZmllbGRzID0gW107XG4gICAgICAgICAgICBGb3JtaW9VdGlscy5lYWNoQ29tcG9uZW50KGNvbXBvbmVudHMsIGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5rZXkgJiYgY29tcG9uZW50LmlucHV0ICYmIChjb21wb25lbnQudHlwZSAhPT0gJ2J1dHRvbicpICYmIGNvbXBvbmVudC5rZXkgIT09ICRzY29wZS5jb21wb25lbnQua2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXAgPSBfY2xvbmUoY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXAubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNvbXAubGFiZWwgPSBjb21wLmtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmllbGRzLnB1c2goY29tcCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkcztcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgJHNjb3BlLmZvcm1GaWVsZHMgPSBbe2xhYmVsOiAnQW55IENoYW5nZScsIGtleTogJ2RhdGEnfV0uY29uY2F0KGdldElucHV0RmllbGRzKCRzY29wZS5mb3JtLmNvbXBvbmVudHMpKTtcblxuICAgICAgICAgIC8vIExvYWRzIHRoZSBzZWxlY3RlZCBmaWVsZHMuXG4gICAgICAgICAgdmFyIGxvYWRGaWVsZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoISRzY29wZS5jb21wb25lbnQuZGF0YS5yZXNvdXJjZSB8fCAoJHNjb3BlLnJlc291cmNlcy5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IG51bGw7XG4gICAgICAgICAgICAkc2NvcGUucmVzb3VyY2VGaWVsZHMgPSBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eTogJycsXG4gICAgICAgICAgICAgICAgdGl0bGU6ICd7RW50aXJlIE9iamVjdH0nXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eTogJ19pZCcsXG4gICAgICAgICAgICAgICAgdGl0bGU6ICdTdWJtaXNzaW9uIElkJ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgaWYgKCRzY29wZS5mb3JtaW8ucHJvamVjdElkKSB7XG4gICAgICAgICAgICAgICRzY29wZS5jb21wb25lbnQuZGF0YS5wcm9qZWN0ID0gJHNjb3BlLmZvcm1pby5wcm9qZWN0SWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCBpbiAkc2NvcGUucmVzb3VyY2VzKSB7XG4gICAgICAgICAgICAgIGlmICgkc2NvcGUucmVzb3VyY2VzW2luZGV4XS5faWQudG9TdHJpbmcoKSA9PT0gJHNjb3BlLmNvbXBvbmVudC5kYXRhLnJlc291cmNlKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSAkc2NvcGUucmVzb3VyY2VzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgIHZhciBmaWVsZHMgPSBnZXRJbnB1dEZpZWxkcyhzZWxlY3RlZC5jb21wb25lbnRzKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBmaWVsZHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHRpdGxlID0gZmllbGQubGFiZWwgfHwgZmllbGQua2V5O1xuICAgICAgICAgICAgICAgICRzY29wZS5yZXNvdXJjZUZpZWxkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiAnZGF0YS4nICsgZmllbGQua2V5LFxuICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCEkc2NvcGUuY29tcG9uZW50LnZhbHVlUHJvcGVydHkgJiYgJHNjb3BlLnJlc291cmNlRmllbGRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICRzY29wZS5jb21wb25lbnQudmFsdWVQcm9wZXJ0eSA9ICRzY29wZS5yZXNvdXJjZUZpZWxkc1swXS5wcm9wZXJ0eTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICAkc2NvcGUuJHdhdGNoKCdjb21wb25lbnQuZGF0YVNyYycsIGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmICgoJHNjb3BlLnJlc291cmNlcy5sZW5ndGggPT09IDApICYmIChzb3VyY2UgPT09ICdyZXNvdXJjZScpKSB7XG4gICAgICAgICAgICAgICRzY29wZS5mb3JtaW8ubG9hZEZvcm1zKHtwYXJhbXM6IHt0eXBlOiAncmVzb3VyY2UnLCBsaW1pdDogNDI5NDk2NzI5NX19KS50aGVuKGZ1bmN0aW9uIChyZXNvdXJjZXMpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUucmVzb3VyY2VzID0gcmVzb3VyY2VzO1xuICAgICAgICAgICAgICAgIGxvYWRGaWVsZHMoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBUcmlnZ2VyIHdoZW4gdGhlIHJlc291cmNlIGNoYW5nZXMuXG4gICAgICAgICAgJHNjb3BlLiR3YXRjaCgnY29tcG9uZW50LmRhdGEucmVzb3VyY2UnLCBmdW5jdGlvbiAocmVzb3VyY2VJZCkge1xuICAgICAgICAgICAgaWYgKCFyZXNvdXJjZUlkKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvYWRGaWVsZHMoKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIFVwZGF0ZSBvdGhlciBwYXJhbWV0ZXJzIHdoZW4gdGhlIHZhbHVlIHByb3BlcnR5IGNoYW5nZXMuXG4gICAgICAgICAgJHNjb3BlLmN1cnJlbnRWYWx1ZVByb3BlcnR5ID0gJHNjb3BlLmNvbXBvbmVudC52YWx1ZVByb3BlcnR5O1xuICAgICAgICAgICRzY29wZS4kd2F0Y2goJ2NvbXBvbmVudC52YWx1ZVByb3BlcnR5JywgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICBpZiAoJHNjb3BlLmNvbXBvbmVudC5kYXRhU3JjID09PSAncmVzb3VyY2UnICYmICRzY29wZS5jdXJyZW50VmFsdWVQcm9wZXJ0eSAhPT0gcHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgaWYgKCFwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgICRzY29wZS5jb21wb25lbnQuc2VhcmNoRmllbGQgPSAnJztcbiAgICAgICAgICAgICAgICAkc2NvcGUuY29tcG9uZW50LnRlbXBsYXRlID0gJzxzcGFuPnt7IGl0ZW0uZGF0YSB9fTwvc3Bhbj4nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICRzY29wZS5jb21wb25lbnQuc2VhcmNoRmllbGQgPSBwcm9wZXJ0eSArICdfX3JlZ2V4JztcbiAgICAgICAgICAgICAgICAkc2NvcGUuY29tcG9uZW50LnRlbXBsYXRlID0gJzxzcGFuPnt7IGl0ZW0uJyArIHByb3BlcnR5ICsgJyB9fTwvc3Bhbj4nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBsb2FkRmllbGRzKCk7XG4gICAgICAgIH1dLFxuICAgICAgICBkb2N1bWVudGF0aW9uOiAnaHR0cDovL2hlbHAuZm9ybS5pby91c2VyZ3VpZGUvI3NlbGVjdCdcbiAgICAgIH0pO1xuICAgIH1cbiAgXSk7XG4gIGFwcC5ydW4oW1xuICAgICckdGVtcGxhdGVDYWNoZScsXG4gICAgZnVuY3Rpb24gKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICAgICAvLyBDcmVhdGUgdGhlIHNldHRpbmdzIG1hcmt1cC5cbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvc2VsZWN0L2Rpc3BsYXkuaHRtbCcsXG4gICAgICAgICc8bmctZm9ybT4nICtcbiAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwibGFiZWxcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXG4gICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInBsYWNlaG9sZGVyXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xuICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJkZXNjcmlwdGlvblwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcbiAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiY3VzdG9tQ2xhc3NcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXG4gICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInRhYmluZGV4XCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xuICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJtdWx0aXBsZVwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcbiAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiY2xlYXJPbkhpZGVcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXG4gICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInByb3RlY3RlZFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcbiAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwicGVyc2lzdGVudFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcbiAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiaGlkZGVuXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xuICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJkaXNhYmxlZFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcbiAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwidGFibGVWaWV3XCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xuICAgICAgICAnPC9uZy1mb3JtPidcbiAgICAgICk7XG5cbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvc2VsZWN0L2RhdGEuaHRtbCcsXG4gICAgICAgICc8bmctZm9ybT4nICtcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+JyArXG4gICAgICAgICc8bGFiZWwgZm9yPVwiZGF0YVNyY1wiIGZvcm0tYnVpbGRlci10b29sdGlwPVwiVGhlIHNvdXJjZSB0byB1c2UgZm9yIHRoZSBzZWxlY3QgZGF0YS4gVmFsdWVzIGxldHMgeW91IHByb3ZpZGUgeW91ciBvd24gdmFsdWVzIGFuZCBsYWJlbHMuIEpTT04gbGV0cyB5b3UgcHJvdmlkZSByYXcgSlNPTiBkYXRhLiBVUkwgbGV0cyB5b3UgcHJvdmlkZSBhIFVSTCB0byByZXRyaWV2ZSB0aGUgSlNPTiBkYXRhIGZyb20uXCI+RGF0YSBTb3VyY2UgVHlwZTwvbGFiZWw+JyArXG4gICAgICAgICc8c2VsZWN0IGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJkYXRhU3JjXCIgbmFtZT1cImRhdGFTcmNcIiBuZy1tb2RlbD1cImNvbXBvbmVudC5kYXRhU3JjXCIgbmctb3B0aW9ucz1cInZhbHVlIGFzIGxhYmVsIGZvciAodmFsdWUsIGxhYmVsKSBpbiBkYXRhU291cmNlc1wiPjwvc2VsZWN0PicgK1xuICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICc8bmctc3dpdGNoIG9uPVwiY29tcG9uZW50LmRhdGFTcmNcIj4nICtcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCIgbmctc3dpdGNoLXdoZW49XCJqc29uXCI+JyArXG4gICAgICAgICc8bGFiZWwgZm9yPVwiZGF0YS5qc29uXCIgZm9ybS1idWlsZGVyLXRvb2x0aXA9XCJBIHJhdyBKU09OIGFycmF5IHRvIHVzZSBhcyBhIGRhdGEgc291cmNlLlwiPkRhdGEgU291cmNlIFJhdyBKU09OPC9sYWJlbD4nICtcbiAgICAgICAgJzx0ZXh0YXJlYSBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwiZGF0YS5qc29uXCIgbmFtZT1cImRhdGEuanNvblwiIG5nLW1vZGVsPVwiY29tcG9uZW50LmRhdGEuanNvblwiIHBsYWNlaG9sZGVyPVwiUmF3IEpTT04gQXJyYXlcIiBqc29uLWlucHV0IHJvd3M9XCIzXCI+e3sgY29tcG9uZW50LmRhdGEuanNvbiB9fTwvdGV4dGFyZWE+JyArXG4gICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgJzxkaXYgbmctc3dpdGNoLXdoZW49XCJ1cmxcIj4nICtcbiAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiZGF0YS51cmxcIiBsYWJlbD1cIkRhdGEgU291cmNlIFVSTFwiIHBsYWNlaG9sZGVyPVwiRGF0YSBTb3VyY2UgVVJMXCIgdGl0bGU9XCJBIFVSTCB0aGF0IHJldHVybnMgYSBKU09OIGFycmF5IHRvIHVzZSBhcyB0aGUgZGF0YSBzb3VyY2UuXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xuICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICc8dmFsdWUtYnVpbGRlciBuZy1zd2l0Y2gtd2hlbj1cInZhbHVlc1wiIGRhdGE9XCJjb21wb25lbnQuZGF0YS52YWx1ZXNcIiBsYWJlbD1cIkRhdGEgU291cmNlIFZhbHVlc1wiIHRvb2x0aXAtdGV4dD1cIlZhbHVlcyB0byB1c2UgYXMgdGhlIGRhdGEgc291cmNlLiBMYWJlbHMgYXJlIHNob3duIGluIHRoZSBzZWxlY3QgZmllbGQuIFZhbHVlcyBhcmUgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzIHNhdmVkIHdpdGggdGhlIHN1Ym1pc3Npb24uXCI+PC92YWx1ZS1idWlsZGVyPicgK1xuICAgICAgICAnPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIiBuZy1zd2l0Y2gtd2hlbj1cInJlc291cmNlXCI+JyArXG4gICAgICAgICc8bGFiZWwgZm9yPVwicGxhY2Vob2xkZXJcIiBmb3JtLWJ1aWxkZXItdG9vbHRpcD1cIlRoZSByZXNvdXJjZSB0byBiZSB1c2VkIHdpdGggdGhpcyBmaWVsZC5cIj5SZXNvdXJjZTwvbGFiZWw+JyArXG4gICAgICAgICc8dWktc2VsZWN0IHVpLXNlbGVjdC1yZXF1aXJlZCB1aS1zZWxlY3Qtb3Blbi1vbi1mb2N1cyBuZy1tb2RlbD1cImNvbXBvbmVudC5kYXRhLnJlc291cmNlXCIgdGhlbWU9XCJib290c3RyYXBcIj4nICtcbiAgICAgICAgJzx1aS1zZWxlY3QtbWF0Y2ggY2xhc3M9XCJ1aS1zZWxlY3QtbWF0Y2hcIiBwbGFjZWhvbGRlcj1cIlwiPicgK1xuICAgICAgICAne3skc2VsZWN0LnNlbGVjdGVkLnRpdGxlfX0nICtcbiAgICAgICAgJzwvdWktc2VsZWN0LW1hdGNoPicgK1xuICAgICAgICAnPHVpLXNlbGVjdC1jaG9pY2VzIGNsYXNzPVwidWktc2VsZWN0LWNob2ljZXNcIiByZXBlYXQ9XCJ2YWx1ZS5faWQgYXMgdmFsdWUgaW4gcmVzb3VyY2VzIHwgZmlsdGVyOiAkc2VsZWN0LnNlYXJjaFwiIHJlZnJlc2g9XCJyZWZyZXNoU3VibWlzc2lvbnMoJHNlbGVjdC5zZWFyY2gpXCIgcmVmcmVzaC1kZWxheT1cIjI1MFwiPicgK1xuICAgICAgICAnPGRpdiBuZy1iaW5kLWh0bWw9XCJ2YWx1ZS50aXRsZSB8IGhpZ2hsaWdodDogJHNlbGVjdC5zZWFyY2hcIj48L2Rpdj4nICtcbiAgICAgICAgJzwvdWktc2VsZWN0LWNob2ljZXM+JyArXG4gICAgICAgICc8L3VpLXNlbGVjdD4nICtcbiAgICAgICAgJzwvZGl2PicgK1xuICAgICAgICAnPC9uZy1zd2l0Y2g+JyArXG4gICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBuZy1oaWRlPVwiY29tcG9uZW50LmRhdGFTcmMgIT09IFxcJ3VybFxcJ1wiIHByb3BlcnR5PVwic2VsZWN0VmFsdWVzXCIgbGFiZWw9XCJEYXRhIFBhdGhcIiB0eXBlPVwidGV4dFwiIHBsYWNlaG9sZGVyPVwiVGhlIG9iamVjdCBwYXRoIHRvIHRoZSBpdGVyYWJsZSBpdGVtcy5cIiB0aXRsZT1cIlRoZSBwcm9wZXJ0eSB3aXRoaW4gdGhlIHNvdXJjZSBkYXRhLCB3aGVyZSBpdGVyYWJsZSBpdGVtcyByZXNpZGUuIEZvciBleGFtcGxlOiByZXN1bHRzLml0ZW1zIG9yIHJlc3VsdHNbMF0uaXRlbXNcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXG4gICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBuZy1oaWRlPVwiY29tcG9uZW50LmRhdGFTcmMgPT0gXFwndmFsdWVzXFwnIHx8IGNvbXBvbmVudC5kYXRhU3JjID09IFxcJ3Jlc291cmNlXFwnIHx8IGNvbXBvbmVudC5kYXRhU3JjID09IFxcJ2N1c3RvbVxcJ1wiIHByb3BlcnR5PVwidmFsdWVQcm9wZXJ0eVwiIGxhYmVsPVwiVmFsdWUgUHJvcGVydHlcIiBwbGFjZWhvbGRlcj1cIlRoZSBzZWxlY3RlZCBpdGVtXFwncyBwcm9wZXJ0eSB0byBzYXZlLlwiIHRpdGxlPVwiVGhlIHByb3BlcnR5IG9mIGVhY2ggaXRlbSBpbiB0aGUgZGF0YSBzb3VyY2UgdG8gdXNlIGFzIHRoZSBzZWxlY3QgdmFsdWUuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBpdGVtIGl0c2VsZiB3aWxsIGJlIHVzZWQuXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xuICAgICAgICAnPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIiBuZy1oaWRlPVwiY29tcG9uZW50LmRhdGFTcmMgIT09IFxcJ3Jlc291cmNlXFwnIHx8ICFjb21wb25lbnQuZGF0YS5yZXNvdXJjZSB8fCByZXNvdXJjZUZpZWxkcy5sZW5ndGggPT0gMFwiPicgK1xuICAgICAgICAnPGxhYmVsIGZvcj1cInBsYWNlaG9sZGVyXCIgZm9ybS1idWlsZGVyLXRvb2x0aXA9XCJUaGUgZmllbGQgdG8gdXNlIGFzIHRoZSB2YWx1ZS5cIj5WYWx1ZTwvbGFiZWw+JyArXG4gICAgICAgICc8c2VsZWN0IGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJ2YWx1ZVByb3BlcnR5XCIgbmFtZT1cInZhbHVlUHJvcGVydHlcIiBuZy1vcHRpb25zPVwidmFsdWUucHJvcGVydHkgYXMgdmFsdWUudGl0bGUgZm9yIHZhbHVlIGluIHJlc291cmNlRmllbGRzXCIgbmctbW9kZWw9XCJjb21wb25lbnQudmFsdWVQcm9wZXJ0eVwiPjwvc2VsZWN0PicgK1xuICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICc8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiIG5nLWlmPVwiY29tcG9uZW50LmRhdGFTcmMgPT0gXFwncmVzb3VyY2VcXCcgJiYgY29tcG9uZW50LnZhbHVlUHJvcGVydHkgPT09IFxcJ1xcJ1wiPicgK1xuICAgICAgICAnICA8bGFiZWwgZm9yPVwicGxhY2Vob2xkZXJcIiBmb3JtLWJ1aWxkZXItdG9vbHRpcD1cIlRoZSBwcm9wZXJ0aWVzIG9uIHRoZSByZXNvdXJjZSB0byByZXR1cm4gYXMgcGFydCBvZiB0aGUgb3B0aW9ucy4gU2VwYXJhdGUgcHJvcGVydHkgbmFtZXMgYnkgY29tbWFzLiBJZiBsZWZ0IGJsYW5rLCBhbGwgcHJvcGVydGllcyB3aWxsIGJlIHJldHVybmVkLlwiPlNlbGVjdCBGaWVsZHM8L2xhYmVsPicgK1xuICAgICAgICAnICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwic2VsZWN0RmllbGRzXCIgbmFtZT1cInNlbGVjdEZpZWxkc1wiIG5nLW1vZGVsPVwiY29tcG9uZW50LnNlbGVjdEZpZWxkc1wiIHBsYWNlaG9sZGVyPVwiQ29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgZmllbGRzIHRvIHNlbGVjdC5cIiB2YWx1ZT1cInt7IGNvbXBvbmVudC5zZWxlY3RGaWVsZHMgfX1cIj4nICtcbiAgICAgICAgJzwvZGl2PicgK1xuICAgICAgICAnPGRpdiBuZy1zaG93PVwiY29tcG9uZW50LmRhdGFTcmMgPT0gXFwndXJsXFwnXCI+JyArXG4gICAgICAgICc8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgbmctbW9kZWw9XCJjb21wb25lbnQuZGF0YS5kaXNhYmxlTGltaXRcIiBuYW1lPVwiZGlzYWJsZUxpbWl0XCI+PC9pbnB1dD4nICtcbiAgICAgICAgJyAgPGxhYmVsIGZvcj1cImRpc2FibGVMaW1pdFwiIGZvcm0tYnVpbGRlci10b29sdGlwPVwiV2hlbiBlbmFibGVkIHRoZSByZXF1ZXN0IHdpbGwgbm90IGluY2x1ZGUgdGhlIGxpbWl0IGFuZCBza2lwIG9wdGlvbnMgaW4gdGhlIHF1ZXJ5IHN0cmluZ1wiPkRpc2FibGUgbGltaXRpbmcgcmVzcG9uc2U8L2xhYmVsPicgK1xuICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBuZy1zaG93PVwiY29tcG9uZW50LmRhdGFTcmMgPT0gXFwndXJsXFwnIHx8IGNvbXBvbmVudC5kYXRhU3JjID09IFxcJ3Jlc291cmNlXFwnXCIgcHJvcGVydHk9XCJzZWFyY2hGaWVsZFwiIGxhYmVsPVwiU2VhcmNoIFF1ZXJ5IE5hbWVcIiBwbGFjZWhvbGRlcj1cIk5hbWUgb2YgVVJMIHF1ZXJ5IHBhcmFtZXRlclwiIHRpdGxlPVwiVGhlIG5hbWUgb2YgdGhlIHNlYXJjaCBxdWVyeXN0cmluZyBwYXJhbWV0ZXIgdXNlZCB3aGVuIHNlbmRpbmcgYSByZXF1ZXN0IHRvIGZpbHRlciByZXN1bHRzIHdpdGguIFRoZSBzZXJ2ZXIgYXQgdGhlIFVSTCBtdXN0IGhhbmRsZSB0aGlzIHF1ZXJ5IHBhcmFtZXRlci5cIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXG4gICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBuZy1zaG93PVwiY29tcG9uZW50LmRhdGFTcmMgPT0gXFwndXJsXFwnIHx8IGNvbXBvbmVudC5kYXRhU3JjID09IFxcJ3Jlc291cmNlXFwnXCIgcHJvcGVydHk9XCJmaWx0ZXJcIiBsYWJlbD1cIkZpbHRlciBRdWVyeVwiIHBsYWNlaG9sZGVyPVwiVGhlIGZpbHRlciBxdWVyeSBmb3IgcmVzdWx0cy5cIiB0aXRsZT1cIlVzZSB0aGlzIHRvIHByb3ZpZGUgYWRkaXRpb25hbCBmaWx0ZXJpbmcgdXNpbmcgcXVlcnkgcGFyYW1ldGVycy5cIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXG4gICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBuZy1zaG93PVwiY29tcG9uZW50LmRhdGFTcmMgPT0gXFwndXJsXFwnIHx8IGNvbXBvbmVudC5kYXRhU3JjID09IFxcJ3Jlc291cmNlXFwnIHx8IGNvbXBvbmVudC5kYXRhU3JjID09IFxcJ2pzb25cXCdcIiBwcm9wZXJ0eT1cImxpbWl0XCIgbGFiZWw9XCJMaW1pdFwiIHBsYWNlaG9sZGVyPVwiTWF4aW11bSBudW1iZXIgb2YgaXRlbXMgdG8gdmlldyBwZXIgcGFnZSBvZiByZXN1bHRzLlwiIHRpdGxlPVwiVXNlIHRoaXMgdG8gbGltaXQgdGhlIG51bWJlciBvZiBpdGVtcyB0byByZXF1ZXN0IG9yIHZpZXcuXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xuICAgICAgICAnPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIiBuZy1zaG93PVwiY29tcG9uZW50LmRhdGFTcmMgPT0gXFwnanNvblxcJ1wiPicgK1xuICAgICAgICAnICA8bGFiZWwgZm9yPVwiZmlsdGVyXCIgZm9ybS1idWlsZGVyLXRvb2x0aXA9XCJUaGUgZmlsdGVyIHR5cGUgZm9yIHNlYXJjaC5cIj5TZWFyY2ggRmlsdGVyPC9sYWJlbD4nICtcbiAgICAgICAgJyAgPHNlbGVjdCBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwiZmlsdGVyXCIgbmFtZT1cImZpbHRlclwiIG5nLW1vZGVsPVwiY29tcG9uZW50LmZpbHRlclwiIG5nLW9wdGlvbnM9XCJ2YWx1ZSBhcyBsYWJlbCBmb3IgKHZhbHVlLCBsYWJlbCkgaW4ge25vbmU6IFxcJ05vIFNlYXJjaFxcJywgY29udGFpbnM6IFxcJ0NvbnRhaW5zXFwnLCBzdGFydHNXaXRoOiBcXCdTdGFydHMgV2l0aFxcJ31cIj48L3NlbGVjdD4nICtcbiAgICAgICAgJzwvZGl2PicgK1xuICAgICAgICAnPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIiBuZy1zaG93PVwiY29tcG9uZW50LmRhdGFTcmMgPT0gXFwnY3VzdG9tXFwnXCI+JyArXG4gICAgICAgICcgIDxsYWJlbCBmb3I9XCJjdXN0b21cIiBmb3JtLWJ1aWxkZXItdG9vbHRpcD1cIldyaXRlIGN1c3RvbSBjb2RlIHRvIHJldHVybiB0aGUgdmFsdWUgb3B0aW9ucy4gVGhlIGZvcm0gZGF0YSBvYmplY3QgaXMgYXZhaWxhYmxlLlwiPkN1c3RvbSBWYWx1ZXM8L2xhYmVsPicgK1xuICAgICAgICAnICA8dGV4dGFyZWEgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiByb3dzPVwiMTBcIiBpZD1cImN1c3RvbVwiIG5hbWU9XCJjdXN0b21cIiBuZy1tb2RlbD1cImNvbXBvbmVudC5kYXRhLmN1c3RvbVwiIHBsYWNlaG9sZGVyPVwiLyoqKiBFeGFtcGxlIENvZGUgKioqL1xcbnZhbHVlcyA9IGRhdGFbXFwnbXlrZXlcXCddO1wiPnt7IGNvbXBvbmVudC5kYXRhLmN1c3RvbSB9fTwvdGV4dGFyZWE+JyArXG4gICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+JyArXG4gICAgICAgICc8bGFiZWwgZm9yPVwicGxhY2Vob2xkZXJcIiBmb3JtLWJ1aWxkZXItdG9vbHRpcD1cIlRoZSBIVE1MIHRlbXBsYXRlIGZvciB0aGUgcmVzdWx0IGRhdGEgaXRlbXMuXCI+SXRlbSBUZW1wbGF0ZTwvbGFiZWw+JyArXG4gICAgICAgICc8dGV4dGFyZWEgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBpZD1cInRlbXBsYXRlXCIgbmFtZT1cInRlbXBsYXRlXCIgbmctbW9kZWw9XCJjb21wb25lbnQudGVtcGxhdGVcIiByb3dzPVwiM1wiPnt7IGNvbXBvbmVudC50ZW1wbGF0ZSB9fTwvdGV4dGFyZWE+JyArXG4gICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCIgbmctaGlkZT1cImNvbXBvbmVudC5kYXRhU3JjID09IFxcJ3ZhbHVlc1xcJyB8fCBjb21wb25lbnQuZGF0YVNyYyA9PSBcXCdqc29uXFwnXCI+JyArXG4gICAgICAgICcgIDxsYWJlbCBmb3I9XCJwbGFjZWhvbGRlclwiIGZvcm0tYnVpbGRlci10b29sdGlwPVwiUmVmcmVzaCBkYXRhIHdoZW4gYW5vdGhlciBmaWVsZCBjaGFuZ2VzLlwiPlJlZnJlc2ggT248L2xhYmVsPicgK1xuICAgICAgICAnICA8c2VsZWN0IGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJyZWZyZXNoT25cIiBuYW1lPVwicmVmcmVzaE9uXCIgbmctb3B0aW9ucz1cImZpZWxkLmtleSBhcyBmaWVsZC5sYWJlbCBmb3IgZmllbGQgaW4gZm9ybUZpZWxkc1wiIG5nLW1vZGVsPVwiY29tcG9uZW50LnJlZnJlc2hPblwiPjwvc2VsZWN0PicgK1xuICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBuZy1zaG93PVwiY29tcG9uZW50LmRhdGFTcmMgPT0gXFwncmVzb3VyY2VcXCcgfHwgY29tcG9uZW50LmRhdGFTcmMgPT0gXFwndXJsXFwnIHx8IGNvbXBvbmVudC5kYXRhU3JjID09IFxcJ2N1c3RvbVxcJ1wiIHByb3BlcnR5PVwiY2xlYXJPblJlZnJlc2hcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXG4gICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBuZy1zaG93PVwiY29tcG9uZW50LmRhdGFTcmMgPT0gXFwncmVzb3VyY2VcXCdcIiBwcm9wZXJ0eT1cInJlZmVyZW5jZVwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcbiAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIG5nLXNob3c9XCJjb21wb25lbnQuZGF0YVNyYyA9PSBcXCd1cmxcXCdcIiBwcm9wZXJ0eT1cImF1dGhlbnRpY2F0ZVwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcbiAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiZGVmYXVsdFZhbHVlXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xuICAgICAgICAnPC9uZy1mb3JtPidcbiAgICAgICk7XG5cbiAgICAgIC8vIENyZWF0ZSB0aGUgQVBJIG1hcmt1cC5cbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvc2VsZWN0L3ZhbGlkYXRlLmh0bWwnLFxuICAgICAgICAnPG5nLWZvcm0+JyArXG4gICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInZhbGlkYXRlLnJlcXVpcmVkXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xuICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJ1bmlxdWVcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXG4gICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbi1jdXN0b20tdmFsaWRhdGlvbj48L2Zvcm0tYnVpbGRlci1vcHRpb24tY3VzdG9tLXZhbGlkYXRpb24+JyArXG4gICAgICAgICc8L25nLWZvcm0+J1xuICAgICAgKTtcbiAgICB9XG4gIF0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApIHtcclxuICBhcHAuY29uZmlnKFtcclxuICAgICdmb3JtaW9Db21wb25lbnRzUHJvdmlkZXInLFxyXG4gICAgZnVuY3Rpb24oZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyKSB7XHJcbiAgICAgIGZvcm1pb0NvbXBvbmVudHNQcm92aWRlci5yZWdpc3Rlcignc2VsZWN0Ym94ZXMnLCB7XHJcbiAgICAgICAgaWNvbjogJ2ZhIGZhLXBsdXMtc3F1YXJlJyxcclxuICAgICAgICB2aWV3czogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnRGlzcGxheScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvc2VsZWN0Ym94ZXMvZGlzcGxheS5odG1sJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1ZhbGlkYXRpb24nLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL3NlbGVjdGJveGVzL3ZhbGlkYXRlLmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQVBJJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9zZWxlY3Rib3hlcy9hcGkuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdMYXlvdXQnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9sYXlvdXQuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdDb25kaXRpb25hbCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY29tbW9uL2NvbmRpdGlvbmFsLmh0bWwnXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBkb2N1bWVudGF0aW9uOiAnaHR0cDovL2hlbHAuZm9ybS5pby91c2VyZ3VpZGUvI3NlbGVjdGJveGVzJ1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICBdKTtcclxuICBhcHAucnVuKFtcclxuICAgICckdGVtcGxhdGVDYWNoZScsXHJcbiAgICBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICAgICAvLyBDcmVhdGUgdGhlIHNldHRpbmdzIG1hcmt1cC5cclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9zZWxlY3Rib3hlcy9kaXNwbGF5Lmh0bWwnLFxyXG4gICAgICAgICc8bmctZm9ybT4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImxhYmVsXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzx2YWx1ZS1idWlsZGVyIGRhdGE9XCJjb21wb25lbnQudmFsdWVzXCIgbGFiZWw9XCJTZWxlY3QgQm94ZXNcIiB0b29sdGlwLXRleHQ9XCJDaGVja2JveGVzIHRvIGRpc3BsYXkuIExhYmVscyBhcmUgc2hvd24gaW4gdGhlIGZvcm0uIFZhbHVlcyBhcmUgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzIHNhdmVkIHdpdGggdGhlIHN1Ym1pc3Npb24uXCI+PC92YWx1ZS1idWlsZGVyPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiY3VzdG9tQ2xhc3NcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJ0YWJpbmRleFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImlubGluZVwiIHR5cGU9XCJjaGVja2JveFwiIGxhYmVsPVwiSW5saW5lIExheW91dFwiIHRpdGxlPVwiRGlzcGxheXMgdGhlIGNoZWNrYm94ZXMgaG9yaXpvbnRhbGx5LlwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImNsZWFyT25IaWRlXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwicHJvdGVjdGVkXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwicGVyc2lzdGVudFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImhpZGRlblwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImRpc2FibGVkXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwidGFibGVWaWV3XCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICc8L25nLWZvcm0+J1xyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gQ3JlYXRlIHRoZSBBUEkgbWFya3VwLlxyXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL3NlbGVjdGJveGVzL2FwaS5odG1sJyxcclxuICAgICAgICAnPG5nLWZvcm0+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24ta2V5PjwvZm9ybS1idWlsZGVyLW9wdGlvbi1rZXk+JyArXHJcbiAgICAgICAgJzwvbmctZm9ybT4nXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBDcmVhdGUgdGhlIEFQSSBtYXJrdXAuXHJcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvc2VsZWN0Ym94ZXMvdmFsaWRhdGUuaHRtbCcsXHJcbiAgICAgICAgJzxuZy1mb3JtPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwidmFsaWRhdGUucmVxdWlyZWRcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24tY3VzdG9tLXZhbGlkYXRpb24+PC9mb3JtLWJ1aWxkZXItb3B0aW9uLWN1c3RvbS12YWxpZGF0aW9uPicgK1xyXG4gICAgICAgICc8L25nLWZvcm0+J1xyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIF0pO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwKSB7XHJcbiAgYXBwLmNvbmZpZyhbXHJcbiAgICAnZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyJyxcclxuICAgIGZ1bmN0aW9uKGZvcm1pb0NvbXBvbmVudHNQcm92aWRlcikge1xyXG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ3NpZ25hdHVyZScsIHtcclxuICAgICAgICBpY29uOiAnZmEgZmEtcGVuY2lsJyxcclxuICAgICAgICB2aWV3czogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnRGlzcGxheScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvc2lnbmF0dXJlL2Rpc3BsYXkuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdWYWxpZGF0aW9uJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9zaWduYXR1cmUvdmFsaWRhdGUuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdBUEknLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9hcGkuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdMYXlvdXQnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9sYXlvdXQuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdDb25kaXRpb25hbCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY29tbW9uL2NvbmRpdGlvbmFsLmh0bWwnXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBkb2N1bWVudGF0aW9uOiAnaHR0cDovL2hlbHAuZm9ybS5pby91c2VyZ3VpZGUvI3NpZ25hdHVyZSdcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbiAgYXBwLnJ1bihbXHJcbiAgICAnJHRlbXBsYXRlQ2FjaGUnLFxyXG4gICAgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAgICAgLy8gQ3JlYXRlIHRoZSBzZXR0aW5ncyBtYXJrdXAuXHJcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvc2lnbmF0dXJlL2Rpc3BsYXkuaHRtbCcsXHJcbiAgICAgICAgJzxuZy1mb3JtPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiZm9vdGVyXCIgbGFiZWw9XCJGb290ZXIgTGFiZWxcIiBwbGFjZWhvbGRlcj1cIkZvb3RlciBMYWJlbFwiIHRpdGxlPVwiVGhlIGZvb3RlciB0ZXh0IHRoYXQgYXBwZWFycyBiZWxvdyB0aGUgc2lnbmF0dXJlIGFyZWEuXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwid2lkdGhcIiBsYWJlbD1cIldpZHRoXCIgcGxhY2Vob2xkZXI9XCJXaWR0aFwiIHRpdGxlPVwiVGhlIHdpZHRoIG9mIHRoZSBzaWduYXR1cmUgYXJlYS5cIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJoZWlnaHRcIiBsYWJlbD1cIkhlaWdodFwiIHBsYWNlaG9sZGVyPVwiSGVpZ2h0XCIgdGl0bGU9XCJUaGUgaGVpZ2h0IG9mIHRoZSBzaWduYXR1cmUgYXJlYS5cIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJiYWNrZ3JvdW5kQ29sb3JcIiBsYWJlbD1cIkJhY2tncm91bmQgQ29sb3JcIiBwbGFjZWhvbGRlcj1cIkJhY2tncm91bmQgQ29sb3JcIiB0aXRsZT1cIlRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSBzaWduYXR1cmUgYXJlYS5cIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJwZW5Db2xvclwiIGxhYmVsPVwiUGVuIENvbG9yXCIgcGxhY2Vob2xkZXI9XCJQZW4gQ29sb3JcIiB0aXRsZT1cIlRoZSBpbmsgY29sb3IgZm9yIHRoZSBzaWduYXR1cmUgYXJlYS5cIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJjdXN0b21DbGFzc1wiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImNsZWFyT25IaWRlXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiZGlzYWJsZWRcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJoaWRkZW5cIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJ0YWJsZVZpZXdcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgJzwvbmctZm9ybT4nXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBDcmVhdGUgdGhlIFZhbGlkYXRpb24gbWFya3VwLlxyXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL3NpZ25hdHVyZS92YWxpZGF0ZS5odG1sJyxcclxuICAgICAgICAnPG5nLWZvcm0+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJ2YWxpZGF0ZS5yZXF1aXJlZFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAnPC9uZy1mb3JtPidcclxuICAgICAgKTtcclxuICAgIH1cclxuICBdKTtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwcCkge1xyXG4gIGFwcC5jb25maWcoW1xyXG4gICAgJ2Zvcm1pb0NvbXBvbmVudHNQcm92aWRlcicsXHJcbiAgICBmdW5jdGlvbihmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIpIHtcclxuICAgICAgZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyLnJlZ2lzdGVyKCdzdXJ2ZXknLCB7XHJcbiAgICAgICAgaWNvbjogJ2ZhIGZhLWxpc3QnLFxyXG4gICAgICAgIHZpZXdzOiBbXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdEaXNwbGF5JyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9zdXJ2ZXkvZGlzcGxheS5odG1sJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1ZhbGlkYXRpb24nLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL3N1cnZleS92YWxpZGF0ZS5odG1sJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0FQSScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY29tbW9uL2FwaS5odG1sJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0xheW91dCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY29tbW9uL2xheW91dC5odG1sJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0NvbmRpdGlvbmFsJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jb21tb24vY29uZGl0aW9uYWwuaHRtbCdcclxuICAgICAgICAgIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIGRvY3VtZW50YXRpb246ICdodHRwOi8vaGVscC5mb3JtLmlvL3VzZXJndWlkZS8jc3VydmV5J1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICBdKTtcclxuICBhcHAucnVuKFtcclxuICAgICckdGVtcGxhdGVDYWNoZScsXHJcbiAgICBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICAgICAvLyBDcmVhdGUgdGhlIHNldHRpbmdzIG1hcmt1cC5cclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9zdXJ2ZXkvZGlzcGxheS5odG1sJyxcclxuICAgICAgICAnPG5nLWZvcm0+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJsYWJlbFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8dmFsdWUtYnVpbGRlciBkYXRhPVwiY29tcG9uZW50LnF1ZXN0aW9uc1wiIGRlZmF1bHQ9XCJjb21wb25lbnQucXVlc3Rpb25zXCIgbGFiZWw9XCJRdWVzdGlvbnNcIiB0b29sdGlwLXRleHQ9XCJUaGUgcXVlc3Rpb25zIHlvdSB3b3VsZCBsaWtlIHRvIGFzIGluIHRoaXMgc3VydmV5IHF1ZXN0aW9uLlwiPjwvdmFsdWUtYnVpbGRlcj4nICtcclxuICAgICAgICAgICc8dmFsdWUtYnVpbGRlciBkYXRhPVwiY29tcG9uZW50LnZhbHVlc1wiIGRlZmF1bHQ9XCJjb21wb25lbnQudmFsdWVzXCIgbGFiZWw9XCJWYWx1ZXNcIiB0b29sdGlwLXRleHQ9XCJUaGUgdmFsdWVzIHRoYXQgY2FuIGJlIHNlbGVjdGVkIHBlciBxdWVzdGlvbi4gRXhhbXBsZTogXFwnU2F0aXNmaWVkXFwnLCBcXCdWZXJ5IFNhdGlzZmllZFxcJywgZXRjLlwiPjwvdmFsdWUtYnVpbGRlcj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImRlZmF1bHRWYWx1ZVwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImN1c3RvbUNsYXNzXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwidGFiaW5kZXhcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJpbmxpbmVcIiB0eXBlPVwiY2hlY2tib3hcIiBsYWJlbD1cIklubGluZSBMYXlvdXRcIiB0aXRsZT1cIkRpc3BsYXlzIHRoZSByYWRpbyBidXR0b25zIGhvcml6b250YWxseS5cIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJjbGVhck9uSGlkZVwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInByb3RlY3RlZFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInBlcnNpc3RlbnRcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJoaWRkZW5cIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJkaXNhYmxlZFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInRhYmxlVmlld1wiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAnPC9uZy1mb3JtPidcclxuICAgICAgKTtcclxuICAgICAgLy8gQ3JlYXRlIHRoZSBBUEkgbWFya3VwLlxyXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL3N1cnZleS92YWxpZGF0ZS5odG1sJyxcclxuICAgICAgICAnPG5nLWZvcm0+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJ2YWxpZGF0ZS5yZXF1aXJlZFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbi1jdXN0b20tdmFsaWRhdGlvbj48L2Zvcm0tYnVpbGRlci1vcHRpb24tY3VzdG9tLXZhbGlkYXRpb24+JyArXHJcbiAgICAgICAgJzwvbmctZm9ybT4nXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApIHtcclxuICBhcHAuY29uZmlnKFtcclxuICAgICdmb3JtaW9Db21wb25lbnRzUHJvdmlkZXInLFxyXG4gICAgZnVuY3Rpb24oZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyKSB7XHJcbiAgICAgIGZvcm1pb0NvbXBvbmVudHNQcm92aWRlci5yZWdpc3RlcigndGFibGUnLCB7XHJcbiAgICAgICAgZmJ0ZW1wbGF0ZTogJ2Zvcm1pby9mb3JtYnVpbGRlci90YWJsZS5odG1sJyxcclxuICAgICAgICBkb2N1bWVudGF0aW9uOiAnaHR0cDovL2hlbHAuZm9ybS5pby91c2VyZ3VpZGUvI3RhYmxlJyxcclxuICAgICAgICBub0RuZE92ZXJsYXk6IHRydWUsXHJcbiAgICAgICAgY29uZmlybVJlbW92ZTogdHJ1ZSxcclxuICAgICAgICBpY29uOiAnZmEgZmEtdGFibGUnLFxyXG4gICAgICAgIHZpZXdzOiBbXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdEaXNwbGF5JyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy90YWJsZS9kaXNwbGF5Lmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnTGF5b3V0JyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jb21tb24vbGF5b3V0Lmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQVBJJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jb21tb24vYXBpLmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQ29uZGl0aW9uYWwnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9jb25kaXRpb25hbC5odG1sJ1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIF1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbiAgYXBwLnJ1bihbXHJcbiAgICAnJHRlbXBsYXRlQ2FjaGUnLFxyXG4gICAgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAgICAgdmFyIHRhYmxlQ2xhc3NlcyA9IFwieyd0YWJsZS1zdHJpcGVkJzogY29tcG9uZW50LnN0cmlwZWQsIFwiO1xyXG4gICAgICB0YWJsZUNsYXNzZXMgKz0gXCIndGFibGUtYm9yZGVyZWQnOiBjb21wb25lbnQuYm9yZGVyZWQsIFwiO1xyXG4gICAgICB0YWJsZUNsYXNzZXMgKz0gXCIndGFibGUtaG92ZXInOiBjb21wb25lbnQuaG92ZXIsIFwiO1xyXG4gICAgICB0YWJsZUNsYXNzZXMgKz0gXCIndGFibGUtY29uZGVuc2VkJzogY29tcG9uZW50LmNvbmRlbnNlZH1cIjtcclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vZm9ybWJ1aWxkZXIvdGFibGUuaHRtbCcsXHJcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJ0YWJsZS1yZXNwb25zaXZlXCI+JyArXHJcbiAgICAgICAgICAnPHRhYmxlIG5nLWNsYXNzPVwiJyArIHRhYmxlQ2xhc3NlcyArICdcIiBjbGFzcz1cInRhYmxlXCI+JyArXHJcbiAgICAgICAgICAgICc8dGhlYWQgbmctaWY9XCJjb21wb25lbnQuaGVhZGVyLmxlbmd0aFwiPjx0cj4nICtcclxuICAgICAgICAgICAgICAnPHRoIG5nLXJlcGVhdD1cImhlYWRlciBpbiBjb21wb25lbnQuaGVhZGVyXCI+e3sgaGVhZGVyIH19PC90aD4nICtcclxuICAgICAgICAgICAgJzwvdHI+PC90aGVhZD4nICtcclxuICAgICAgICAgICAgJzx0Ym9keT4nICtcclxuICAgICAgICAgICAgICAnPHRyIG5nLXJlcGVhdD1cInJvdyBpbiBjb21wb25lbnQucm93c1wiPicgK1xyXG4gICAgICAgICAgICAgICAgJzx0ZCBuZy1yZXBlYXQ9XCJjb21wb25lbnQgaW4gcm93XCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICc8Zm9ybS1idWlsZGVyLWxpc3QgY29tcG9uZW50PVwiY29tcG9uZW50XCIgZm9ybT1cImZvcm1cIiBmb3JtaW89XCI6OmZvcm1pb1wiPjwvZm9ybS1idWlsZGVyLWxpc3Q+JyArXHJcbiAgICAgICAgICAgICAgICAnPC90ZD4nICtcclxuICAgICAgICAgICAgICAnPC90cj4nICtcclxuICAgICAgICAgICAgJzwvdGJvZHk+JyArXHJcbiAgICAgICAgICAnPC90YWJsZT4nICtcclxuICAgICAgICAnPC9kaXY+J1xyXG4gICAgICApO1xyXG5cclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy90YWJsZS9kaXNwbGF5Lmh0bWwnLFxyXG4gICAgICAgICc8bmctZm9ybT4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLXRhYmxlPjwvZm9ybS1idWlsZGVyLXRhYmxlPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiY3VzdG9tQ2xhc3NcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJzdHJpcGVkXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiYm9yZGVyZWRcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJob3ZlclwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImNvbmRlbnNlZFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAnPC9uZy1mb3JtPidcclxuICAgICAgKTtcclxuICAgIH1cclxuICBdKTtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwcCkge1xyXG4gIGFwcC5jb25maWcoW1xyXG4gICAgJ2Zvcm1pb0NvbXBvbmVudHNQcm92aWRlcicsXHJcbiAgICBmdW5jdGlvbihmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIpIHtcclxuICAgICAgZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyLnJlZ2lzdGVyKCd0ZXh0YXJlYScsIHtcclxuICAgICAgICBpY29uOiAnZmEgZmEtZm9udCcsXHJcbiAgICAgICAgdmlld3M6IFtcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0Rpc3BsYXknLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL3RleHRhcmVhL2Rpc3BsYXkuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdEYXRhJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jb21tb24vZGF0YS5odG1sJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1ZhbGlkYXRpb24nLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL3RleHRmaWVsZC92YWxpZGF0ZS5odG1sJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0FQSScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY29tbW9uL2FwaS5odG1sJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0xheW91dCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY29tbW9uL2xheW91dC5odG1sJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0NvbmRpdGlvbmFsJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jb21tb24vY29uZGl0aW9uYWwuaHRtbCdcclxuICAgICAgICAgIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIGRvY3VtZW50YXRpb246ICdodHRwOi8vaGVscC5mb3JtLmlvL3VzZXJndWlkZS8jdGV4dGFyZWEnXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIF0pO1xyXG4gIGFwcC5jb250cm9sbGVyKCd3eXNpd3lnU2V0dGluZ3MnLCBbJyRzY29wZScsIGZ1bmN0aW9uKCRzY29wZSkge1xyXG4gICAgJHNjb3BlLnd5c2l3eWdFbmFibGVkID0gISEkc2NvcGUuY29tcG9uZW50Lnd5c2l3eWc7XHJcbiAgICAkc2NvcGUud3lzaXd5Z1NldHRpbmdzID0ge1xyXG4gICAgICB0b29sYmFyR3JvdXBzOiAgW1xyXG4gICAgICAgIHtuYW1lOiAnYmFzaWNzdHlsZXMnLCBncm91cHM6IFsnYmFzaWNzdHlsZXMnLCAnY2xlYW51cCddfSxcclxuICAgICAgICB7bmFtZTogJ3BhcmFncmFwaCcsIGdyb3VwczogWydsaXN0JywgJ2luZGVudCcsICdibG9ja3MnLCAnYWxpZ24nLCAnYmlkaScsICdwYXJhZ3JhcGgnLCAnLScsICdKdXN0aWZ5TGVmdCcsICdKdXN0aWZ5Q2VudGVyJywgJ0p1c3RpZnlSaWdodCcsICdKdXN0aWZ5QmxvY2snXX0sXHJcbiAgICAgICAge25hbWU6ICdsaW5rcycsIGdyb3VwczogWydsaW5rcyddfSxcclxuICAgICAgICB7bmFtZTogJ2luc2VydCcsIGdyb3VwczogWydpbnNlcnQnXX0sXHJcbiAgICAgICAgJy8nLFxyXG4gICAgICAgIHtuYW1lOiAnc3R5bGVzJywgZ3JvdXBzOiBbJ1N0eWxlcycsICdGb3JtYXQnLCAnRm9udCcsICdGb250U2l6ZSddfSxcclxuICAgICAgICB7bmFtZTogJ2NvbG9ycycsIGdyb3VwczogWydjb2xvcnMnXX0sXHJcbiAgICAgICAge25hbWU6ICdjbGlwYm9hcmQnLCBncm91cHM6IFsnY2xpcGJvYXJkJywgJ3VuZG8nXX0sXHJcbiAgICAgICAge25hbWU6ICdlZGl0aW5nJywgZ3JvdXBzOiBbJ2ZpbmQnLCAnc2VsZWN0aW9uJywgJ3NwZWxsY2hlY2tlcicsICdlZGl0aW5nJ119LFxyXG4gICAgICAgIHtuYW1lOiAnZG9jdW1lbnQnLCBncm91cHM6IFsnbW9kZScsICdkb2N1bWVudCcsICdkb2N0b29scyddfSxcclxuICAgICAgICB7bmFtZTogJ290aGVycycsIGdyb3VwczogWydvdGhlcnMnXX0sXHJcbiAgICAgICAge25hbWU6ICd0b29scycsIGdyb3VwczogWyd0b29scyddfVxyXG4gICAgICBdLFxyXG4gICAgICBleHRyYVBsdWdpbnM6ICdqdXN0aWZ5LGZvbnQnLFxyXG4gICAgICByZW1vdmVCdXR0b25zOiAnQ3V0LENvcHksUGFzdGUsVW5kZXJsaW5lLFN1YnNjcmlwdCxTdXBlcnNjcmlwdCxTY2F5dCxBYm91dCcsXHJcbiAgICAgIHVpQ29sb3I6ICcjZWVlZWVlJyxcclxuICAgICAgaGVpZ2h0OiAnNDAwcHgnLFxyXG4gICAgICB3aWR0aDogJzEwMCUnXHJcbiAgICB9O1xyXG4gICAgJHNjb3BlLiR3YXRjaCgnd3lzaXd5Z0VuYWJsZWQnLCBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAkc2NvcGUuY29tcG9uZW50Lnd5c2l3eWcgPSB2YWx1ZSA/ICRzY29wZS53eXNpd3lnU2V0dGluZ3MgOiBmYWxzZTtcclxuICAgIH0pO1xyXG4gICAgJHNjb3BlLiR3YXRjaCgnd3lzaXd5Z1NldHRpbmdzJywgZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgaWYgKCRzY29wZS53eXNpd3lnRW5hYmxlZCkge1xyXG4gICAgICAgICRzY29wZS5jb21wb25lbnQud3lzaXd5ZyA9IHZhbHVlO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XSk7XHJcbiAgYXBwLnJ1bihbXHJcbiAgICAnJHRlbXBsYXRlQ2FjaGUnLFxyXG4gICAgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAgICAgLy8gQ3JlYXRlIHRoZSBzZXR0aW5ncyBtYXJrdXAuXHJcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvdGV4dGFyZWEvZGlzcGxheS5odG1sJyxcclxuICAgICAgICAnPG5nLWZvcm0+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJsYWJlbFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInBsYWNlaG9sZGVyXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiZGVzY3JpcHRpb25cIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJpbnB1dE1hc2tcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGRpdiBuZy1jb250cm9sbGVyPVwid3lzaXd5Z1NldHRpbmdzXCI+JyArXHJcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiY2hlY2tib3hcIj4nICtcclxuICAgICAgICAgICAgICAnPGxhYmVsPjxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBuZy1tb2RlbD1cInd5c2l3eWdFbmFibGVkXCI+IEVuYWJsZSBXWVdJV1lHPC9sYWJlbD4nICtcclxuICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj4nICtcclxuICAgICAgICAgICAgICAnPGxhYmVsIGZvcj1cInd5c2l3eWdcIj5XWVNJV1lHIFNldHRpbmdzPC9sYWJlbD4nICtcclxuICAgICAgICAgICAgICAnPHRleHRhcmVhIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgcm93cz1cIjVcIiBpZD1cInd5c2l3eWdcIiBuZy1tb2RlbD1cInd5c2l3eWdTZXR0aW5nc1wiIGpzb24taW5wdXQgcGxhY2Vob2xkZXI9XCJFbnRlciB0aGUgQ0tFZGl0b3IgSlNPTiBjb25maWd1cmF0aW9uIHRvIHR1cm4gdGhpcyBUZXh0QXJlYSBpbnRvIGEgV1lTSVdZRy5cIj48L3RleHRhcmVhPicgK1xyXG4gICAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJwcmVmaXhcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJzdWZmaXhcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJjdXN0b21DbGFzc1wiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInRhYmluZGV4XCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwibXVsdGlwbGVcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJjbGVhck9uSGlkZVwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInByb3RlY3RlZFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInBlcnNpc3RlbnRcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJkaXNhYmxlZFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInRhYmxlVmlld1wiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAnPC9uZy1mb3JtPidcclxuICAgICAgKTtcclxuICAgIH1cclxuICBdKTtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwcCkge1xyXG4gIGFwcC5jb25maWcoW1xyXG4gICAgJ2Zvcm1pb0NvbXBvbmVudHNQcm92aWRlcicsXHJcbiAgICBmdW5jdGlvbihmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIpIHtcclxuICAgICAgZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyLnJlZ2lzdGVyKCd0ZXh0ZmllbGQnLCB7XHJcbiAgICAgICAgdmlld3M6IFtcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0Rpc3BsYXknLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL3RleHRmaWVsZC9kaXNwbGF5Lmh0bWwnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnRGF0YScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY29tbW9uL2RhdGEuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdWYWxpZGF0aW9uJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy90ZXh0ZmllbGQvdmFsaWRhdGUuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdBUEknLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9hcGkuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdMYXlvdXQnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9sYXlvdXQuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdDb25kaXRpb25hbCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY29tbW9uL2NvbmRpdGlvbmFsLmh0bWwnXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBkb2N1bWVudGF0aW9uOiAnaHR0cDovL2hlbHAuZm9ybS5pby91c2VyZ3VpZGUvI3RleHRmaWVsZCdcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbiAgYXBwLnJ1bihbXHJcbiAgICAnJHRlbXBsYXRlQ2FjaGUnLFxyXG4gICAgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAgICAgLy8gQ3JlYXRlIHRoZSBzZXR0aW5ncyBtYXJrdXAuXHJcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvdGV4dGZpZWxkL2Rpc3BsYXkuaHRtbCcsXHJcbiAgICAgICAgJzxuZy1mb3JtPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwibGFiZWxcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJwbGFjZWhvbGRlclwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImRlc2NyaXB0aW9uXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiaW5wdXRNYXNrXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwicHJlZml4XCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwic3VmZml4XCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiY3VzdG9tQ2xhc3NcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJ0YWJpbmRleFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cIm11bHRpcGxlXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiY2xlYXJPbkhpZGVcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJwcm90ZWN0ZWRcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJwZXJzaXN0ZW50XCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiaGlkZGVuXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItb3B0aW9uIHByb3BlcnR5PVwiZGlzYWJsZWRcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJ0YWJsZVZpZXdcIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgJzwvbmctZm9ybT4nXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL3RleHRmaWVsZC92YWxpZGF0ZS5odG1sJyxcclxuICAgICAgICAnPG5nLWZvcm0+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24gcHJvcGVydHk9XCJ2YWxpZGF0ZS5yZXF1aXJlZFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInVuaXF1ZVwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInZhbGlkYXRlLm1pbkxlbmd0aFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInZhbGlkYXRlLm1heExlbmd0aFwiPjwvZm9ybS1idWlsZGVyLW9wdGlvbj4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cInZhbGlkYXRlLnBhdHRlcm5cIj48L2Zvcm0tYnVpbGRlci1vcHRpb24+JyArXHJcbiAgICAgICAgICAnPGZvcm0tYnVpbGRlci1vcHRpb24tY3VzdG9tLXZhbGlkYXRpb24+PC9mb3JtLWJ1aWxkZXItb3B0aW9uLWN1c3RvbS12YWxpZGF0aW9uPicgK1xyXG4gICAgICAgICc8L25nLWZvcm0+J1xyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIF0pO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwKSB7XHJcbiAgYXBwLmNvbmZpZyhbXHJcbiAgICAnZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyJyxcclxuICAgIGZ1bmN0aW9uKGZvcm1pb0NvbXBvbmVudHNQcm92aWRlcikge1xyXG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ3dlbGwnLCB7XHJcbiAgICAgICAgZmJ0ZW1wbGF0ZTogJ2Zvcm1pby9mb3JtYnVpbGRlci93ZWxsLmh0bWwnLFxyXG4gICAgICAgIGljb246ICdmYSBmYS1zcXVhcmUtbycsXHJcbiAgICAgICAgZG9jdW1lbnRhdGlvbjogJ2h0dHA6Ly9oZWxwLmZvcm0uaW8vdXNlcmd1aWRlLyN3ZWxsJyxcclxuICAgICAgICBub0RuZE92ZXJsYXk6IHRydWUsXHJcbiAgICAgICAgY29uZmlybVJlbW92ZTogdHJ1ZSxcclxuICAgICAgICB2aWV3czogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnRGlzcGxheScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY29tbW9uL2Rpc3BsYXkuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdBUEknLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9hcGkuaHRtbCdcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdDb25kaXRpb25hbCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY29tbW9uL2NvbmRpdGlvbmFsLmh0bWwnXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgXVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICBdKTtcclxuICBhcHAucnVuKFtcclxuICAgICckdGVtcGxhdGVDYWNoZScsXHJcbiAgICBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9mb3JtYnVpbGRlci93ZWxsLmh0bWwnLFxyXG4gICAgICAgICc8ZGl2IGNsYXNzPVwid2VsbFwiPicgK1xyXG4gICAgICAgICAgJzxmb3JtLWJ1aWxkZXItbGlzdCBjb21wb25lbnQ9XCJjb21wb25lbnRcIiBmb3JtPVwiZm9ybVwiIGZvcm1pbz1cIjo6Zm9ybWlvXCI+PC9mb3JtLWJ1aWxkZXItbGlzdD4nICtcclxuICAgICAgICAnPC9kaXY+J1xyXG4gICAgICApO1xyXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL2NvbW1vbi9kaXNwbGF5Lmh0bWwnLFxyXG4gICAgICAgICc8bmctZm9ybT4nICtcclxuICAgICAgICAgICc8Zm9ybS1idWlsZGVyLW9wdGlvbiBwcm9wZXJ0eT1cImN1c3RvbUNsYXNzXCI+PC9mb3JtLWJ1aWxkZXItb3B0aW9uPicgK1xyXG4gICAgICAgICc8bmctZm9ybT4nXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXHJcbiAgKiBUaGVzZSBhcmUgY29tcG9uZW50IG9wdGlvbnMgdGhhdCBjYW4gYmUgcmV1c2VkXHJcbiAgKiB3aXRoIHRoZSBidWlsZGVyLW9wdGlvbiBkaXJlY3RpdmVcclxuICAqIFZhbGlkIHByb3BlcnRpZXM6IGxhYmVsLCBwbGFjZWhvbGRlciwgdG9vbHRpcCwgdHlwZVxyXG4gICovXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gIGxhYmVsOiB7XHJcbiAgICBsYWJlbDogJ0xhYmVsJyxcclxuICAgIHBsYWNlaG9sZGVyOiAnRmllbGQgTGFiZWwnLFxyXG4gICAgdG9vbHRpcDogJ1RoZSBsYWJlbCBmb3IgdGhpcyBmaWVsZCB0aGF0IHdpbGwgYXBwZWFyIG5leHQgdG8gaXQuJ1xyXG4gIH0sXHJcbiAgZGVmYXVsdFZhbHVlOiB7XHJcbiAgICBsYWJlbDogJ0RlZmF1bHQgVmFsdWUnLFxyXG4gICAgcGxhY2Vob2xkZXI6ICdEZWZhdWx0IFZhbHVlJyxcclxuICAgIHRvb2x0aXA6ICdUaGUgd2lsbCBiZSB0aGUgdmFsdWUgZm9yIHRoaXMgZmllbGQsIGJlZm9yZSB1c2VyIGludGVyYWN0aW9uLiBIYXZpbmcgYSBkZWZhdWx0IHZhbHVlIHdpbGwgb3ZlcnJpZGUgdGhlIHBsYWNlaG9sZGVyIHRleHQuJ1xyXG4gIH0sXHJcbiAgcGxhY2Vob2xkZXI6IHtcclxuICAgIGxhYmVsOiAnUGxhY2Vob2xkZXInLFxyXG4gICAgcGxhY2Vob2xkZXI6ICdQbGFjZWhvbGRlcicsXHJcbiAgICB0b29sdGlwOiAnVGhlIHBsYWNlaG9sZGVyIHRleHQgdGhhdCB3aWxsIGFwcGVhciB3aGVuIHRoaXMgZmllbGQgaXMgZW1wdHkuJ1xyXG4gIH0sXHJcbiAgZGVzY3JpcHRpb246IHtcclxuICAgIGxhYmVsOiAnRGVzY3JpcHRpb24nLFxyXG4gICAgcGxhY2Vob2xkZXI6ICdEZXNjcmlwdGlvbiBmb3IgdGhpcyBmaWVsZC4nLFxyXG4gICAgdG9vbHRpcDogJ1RoZSBkZXNjcmlwdGlvbiBpcyB0ZXh0IHRoYXQgd2lsbCBhcHBlYXIgYmVsb3cgdGhlIGlucHV0IGZpZWxkLidcclxuICB9LFxyXG4gIHBhdGg6IHtcclxuICAgIGxhYmVsOiAnRm9ybSBQYXRoJyxcclxuICAgIHBsYWNlaG9sZGVyOiAnRW50ZXIgdGhlIHBhdGggb2YgdGhlIEZvcm0gdG8gbG9hZCcsXHJcbiAgICB0b29sdGlwOiAnVGhpcyBpcyB0aGUgcGF0aCBvZiB0aGUgZm9ybSB0byBsb2FkLidcclxuICB9LFxyXG4gIGlucHV0TWFzazoge1xyXG4gICAgbGFiZWw6ICdJbnB1dCBNYXNrJyxcclxuICAgIHBsYWNlaG9sZGVyOiAnSW5wdXQgTWFzaycsXHJcbiAgICB0b29sdGlwOiAnQW4gaW5wdXQgbWFzayBoZWxwcyB0aGUgdXNlciB3aXRoIGlucHV0IGJ5IGVuc3VyaW5nIGEgcHJlZGVmaW5lZCBmb3JtYXQuPGJyPjxicj45OiBudW1lcmljPGJyPmE6IGFscGhhYmV0aWNhbDxicj4qOiBhbHBoYW51bWVyaWM8YnI+PGJyPkV4YW1wbGUgdGVsZXBob25lIG1hc2s6ICg5OTkpIDk5OS05OTk5PGJyPjxicj5TZWUgdGhlIDxhIHRhcmdldD1cXCdfYmxhbmtcXCcgaHJlZj1cXCdodHRwczovL2dpdGh1Yi5jb20vUm9iaW5IZXJib3RzL2pxdWVyeS5pbnB1dG1hc2tcXCc+anF1ZXJ5LmlucHV0bWFzayBkb2N1bWVudGF0aW9uPC9hPiBmb3IgbW9yZSBpbmZvcm1hdGlvbi48L2E+J1xyXG4gIH0sXHJcbiAgYXV0aGVudGljYXRlOiB7XHJcbiAgICBsYWJlbDogJ0Zvcm1pbyBBdXRoZW50aWNhdGUnLFxyXG4gICAgdG9vbHRpcDogJ0NoZWNrIHRoaXMgaWYgeW91IHdvdWxkIGxpa2UgdG8gdXNlIEZvcm1pbyBBdXRoZW50aWNhdGlvbiB3aXRoIHRoZSByZXF1ZXN0LicsXHJcbiAgICB0eXBlOiAnY2hlY2tib3gnXHJcbiAgfSxcclxuICB0YWJsZVZpZXc6IHtcclxuICAgIGxhYmVsOiAnVGFibGUgVmlldycsXHJcbiAgICB0eXBlOiAnY2hlY2tib3gnLFxyXG4gICAgdG9vbHRpcDogJ1Nob3dzIHRoaXMgdmFsdWUgd2l0aGluIHRoZSB0YWJsZSB2aWV3IG9mIHRoZSBzdWJtaXNzaW9ucy4nXHJcbiAgfSxcclxuICBwcmVmaXg6IHtcclxuICAgIGxhYmVsOiAnUHJlZml4JyxcclxuICAgIHBsYWNlaG9sZGVyOiAnZXhhbXBsZSBcXCckXFwnLCBcXCdAXFwnJyxcclxuICAgIHRvb2x0aXA6ICdUaGUgdGV4dCB0byBzaG93IGJlZm9yZSBhIGZpZWxkLidcclxuICB9LFxyXG4gIHN1ZmZpeDoge1xyXG4gICAgbGFiZWw6ICdTdWZmaXgnLFxyXG4gICAgcGxhY2Vob2xkZXI6ICdleGFtcGxlIFxcJyRcXCcsIFxcJ0BcXCcnLFxyXG4gICAgdG9vbHRpcDogJ1RoZSB0ZXh0IHRvIHNob3cgYWZ0ZXIgYSBmaWVsZC4nXHJcbiAgfSxcclxuICBtdWx0aXBsZToge1xyXG4gICAgbGFiZWw6ICdNdWx0aXBsZSBWYWx1ZXMnLFxyXG4gICAgdHlwZTogJ2NoZWNrYm94JyxcclxuICAgIHRvb2x0aXA6ICdBbGxvd3MgbXVsdGlwbGUgdmFsdWVzIHRvIGJlIGVudGVyZWQgZm9yIHRoaXMgZmllbGQuJ1xyXG4gIH0sXHJcbiAgZGlzYWJsZWQ6IHtcclxuICAgIGxhYmVsOiAnRGlzYWJsZWQnLFxyXG4gICAgdHlwZTogJ2NoZWNrYm94JyxcclxuICAgIHRvb2x0aXA6ICdEaXNhYmxlIHRoZSBmb3JtIGlucHV0LidcclxuICB9LFxyXG4gIGNsZWFyT25SZWZyZXNoOiB7XHJcbiAgICBsYWJlbDogJ0NsZWFyIFZhbHVlIE9uIFJlZnJlc2gnLFxyXG4gICAgdHlwZTogJ2NoZWNrYm94JyxcclxuICAgIHRvb2x0aXA6ICdXaGVuIHRoZSBSZWZyZXNoIE9uIGZpZWxkIGlzIGNoYW5nZWQsIGNsZWFyIHRoZSBzZWxlY3RlZCB2YWx1ZS4nXHJcbiAgfSxcclxuICBjbGVhck9uSGlkZToge1xyXG4gICAgbGFiZWw6ICdDbGVhciBWYWx1ZSBXaGVuIEhpZGRlbicsXHJcbiAgICB0eXBlOiAnY2hlY2tib3gnLFxyXG4gICAgdG9vbHRpcDogJ1doZW4gYSBmaWVsZCBpcyBoaWRkZW4sIGNsZWFyIHRoZSB2YWx1ZS4nXHJcbiAgfSxcclxuICB1bmlxdWU6IHtcclxuICAgIGxhYmVsOiAnVW5pcXVlJyxcclxuICAgIHR5cGU6ICdjaGVja2JveCcsXHJcbiAgICB0b29sdGlwOiAnTWFrZXMgc3VyZSB0aGUgZGF0YSBzdWJtaXR0ZWQgZm9yIHRoaXMgZmllbGQgaXMgdW5pcXVlLCBhbmQgaGFzIG5vdCBiZWVuIHN1Ym1pdHRlZCBiZWZvcmUuJ1xyXG4gIH0sXHJcbiAgcHJvdGVjdGVkOiB7XHJcbiAgICBsYWJlbDogJ1Byb3RlY3RlZCcsXHJcbiAgICB0eXBlOiAnY2hlY2tib3gnLFxyXG4gICAgdG9vbHRpcDogJ0EgcHJvdGVjdGVkIGZpZWxkIHdpbGwgbm90IGJlIHJldHVybmVkIHdoZW4gcXVlcmllZCB2aWEgQVBJLidcclxuICB9LFxyXG4gIGltYWdlOiB7XHJcbiAgICBsYWJlbDogJ0Rpc3BsYXkgYXMgaW1hZ2VzJyxcclxuICAgIHR5cGU6ICdjaGVja2JveCcsXHJcbiAgICB0b29sdGlwOiAnSW5zdGVhZCBvZiBhIGxpc3Qgb2YgbGlua2VkIGZpbGVzLCBpbWFnZXMgd2lsbCBiZSByZW5kZXJlZCBpbiB0aGUgdmlldy4nXHJcbiAgfSxcclxuICBpbWFnZVNpemU6IHtcclxuICAgIGxhYmVsOiAnSW1hZ2UgU2l6ZScsXHJcbiAgICBwbGFjZWhvbGRlcjogJzEwMCcsXHJcbiAgICB0b29sdGlwOiAnVGhlIGltYWdlIHNpemUgZm9yIHByZXZpZXdpbmcgaW1hZ2VzLidcclxuICB9LFxyXG4gIHBlcnNpc3RlbnQ6IHtcclxuICAgIGxhYmVsOiAnUGVyc2lzdGVudCcsXHJcbiAgICB0eXBlOiAnY2hlY2tib3gnLFxyXG4gICAgdG9vbHRpcDogJ0EgcGVyc2lzdGVudCBmaWVsZCB3aWxsIGJlIHN0b3JlZCBpbiBkYXRhYmFzZSB3aGVuIHRoZSBmb3JtIGlzIHN1Ym1pdHRlZC4nXHJcbiAgfSxcclxuICBoaWRkZW46IHtcclxuICAgIGxhYmVsOiAnSGlkZGVuJyxcclxuICAgIHR5cGU6ICdjaGVja2JveCcsXHJcbiAgICB0b29sdGlwOiAnQSBoaWRkZW4gZmllbGQgaXMgc3RpbGwgYSBwYXJ0IG9mIHRoZSBmb3JtLCBidXQgaXMgaGlkZGVuIGZyb20gdmlldy4nXHJcbiAgfSxcclxuICByZWZlcmVuY2U6IHtcclxuICAgIGxhYmVsOiAnU2F2ZSBhcyByZWZlcmVuY2UnLFxyXG4gICAgdHlwZTogJ2NoZWNrYm94JyxcclxuICAgIHRvb2x0aXA6ICdVc2luZyB0aGlzIG9wdGlvbiB3aWxsIHNhdmUgdGhpcyBmaWVsZCBhcyBhIHJlZmVyZW5jZSBhbmQgbGluayBpdHMgdmFsdWUgdG8gdGhlIHZhbHVlIG9mIHRoZSBvcmlnaW4gcmVjb3JkLidcclxuICB9LFxyXG4gIGJsb2NrOiB7XHJcbiAgICBsYWJlbDogJ0Jsb2NrJyxcclxuICAgIHR5cGU6ICdjaGVja2JveCcsXHJcbiAgICB0b29sdGlwOiAnVGhpcyBjb250cm9sIHNob3VsZCBzcGFuIHRoZSBmdWxsIHdpZHRoIG9mIHRoZSBib3VuZGluZyBjb250YWluZXIuJ1xyXG4gIH0sXHJcbiAgbGVmdEljb246IHtcclxuICAgIGxhYmVsOiAnTGVmdCBJY29uJyxcclxuICAgIHBsYWNlaG9sZGVyOiAnRW50ZXIgaWNvbiBjbGFzc2VzJyxcclxuICAgIHRvb2x0aXA6ICdUaGlzIGlzIHRoZSBmdWxsIGljb24gY2xhc3Mgc3RyaW5nIHRvIHNob3cgdGhlIGljb24uIEV4YW1wbGU6IFxcJ2dseXBoaWNvbiBnbHlwaGljb24tc2VhcmNoXFwnIG9yIFxcJ2ZhIGZhLXBsdXNcXCcnXHJcbiAgfSxcclxuICByaWdodEljb246IHtcclxuICAgIGxhYmVsOiAnUmlnaHQgSWNvbicsXHJcbiAgICBwbGFjZWhvbGRlcjogJ0VudGVyIGljb24gY2xhc3NlcycsXHJcbiAgICB0b29sdGlwOiAnVGhpcyBpcyB0aGUgZnVsbCBpY29uIGNsYXNzIHN0cmluZyB0byBzaG93IHRoZSBpY29uLiBFeGFtcGxlOiBcXCdnbHlwaGljb24gZ2x5cGhpY29uLXNlYXJjaFxcJyBvciBcXCdmYSBmYS1wbHVzXFwnJ1xyXG4gIH0sXHJcbiAgdXJsOiB7XHJcbiAgICBsYWJlbDogJ1VwbG9hZCBVcmwnLFxyXG4gICAgcGxhY2Vob2xkZXI6ICdFbnRlciB0aGUgdXJsIHRvIHBvc3QgdGhlIGZpbGVzIHRvLicsXHJcbiAgICB0b29sdGlwOiAnU2VlIDxhIGhyZWY9XFwnaHR0cHM6Ly9naXRodWIuY29tL2RhbmlhbGZhcmlkL25nLWZpbGUtdXBsb2FkI3NlcnZlci1zaWRlXFwnIHRhcmdldD1cXCdfYmxhbmtcXCc+aHR0cHM6Ly9naXRodWIuY29tL2RhbmlhbGZhcmlkL25nLWZpbGUtdXBsb2FkI3NlcnZlci1zaWRlPC9hPiBmb3IgaG93IHRvIHNldCB1cCB0aGUgc2VydmVyLidcclxuICB9LFxyXG4gIGRpcjoge1xyXG4gICAgbGFiZWw6ICdEaXJlY3RvcnknLFxyXG4gICAgcGxhY2Vob2xkZXI6ICcob3B0aW9uYWwpIEVudGVyIGEgZGlyZWN0b3J5IGZvciB0aGUgZmlsZXMnLFxyXG4gICAgdG9vbHRpcDogJ1RoaXMgd2lsbCBwbGFjZSBhbGwgdGhlIGZpbGVzIHVwbG9hZGVkIGluIHRoaXMgZmllbGQgaW4gdGhlIGRpcmVjdG9yeSdcclxuICB9LFxyXG4gIGRpc2FibGVPbkludmFsaWQ6IHtcclxuICAgIGxhYmVsOiAnRGlzYWJsZSBvbiBGb3JtIEludmFsaWQnLFxyXG4gICAgdHlwZTogJ2NoZWNrYm94JyxcclxuICAgIHRvb2x0aXA6ICdUaGlzIHdpbGwgZGlzYWJsZSB0aGlzIGZpZWxkIGlmIHRoZSBmb3JtIGlzIGludmFsaWQuJ1xyXG4gIH0sXHJcbiAgc3RyaXBlZDoge1xyXG4gICAgbGFiZWw6ICdTdHJpcGVkJyxcclxuICAgIHR5cGU6ICdjaGVja2JveCcsXHJcbiAgICB0b29sdGlwOiAnVGhpcyB3aWxsIHN0cmlwZSB0aGUgdGFibGUgaWYgY2hlY2tlZC4nXHJcbiAgfSxcclxuICBib3JkZXJlZDoge1xyXG4gICAgbGFiZWw6ICdCb3JkZXJlZCcsXHJcbiAgICB0eXBlOiAnY2hlY2tib3gnLFxyXG4gICAgdG9vbHRpcDogJ1RoaXMgd2lsbCBib3JkZXIgdGhlIHRhYmxlIGlmIGNoZWNrZWQuJ1xyXG4gIH0sXHJcbiAgaG92ZXI6IHtcclxuICAgIGxhYmVsOiAnSG92ZXInLFxyXG4gICAgdHlwZTogJ2NoZWNrYm94JyxcclxuICAgIHRvb2x0aXA6ICdIaWdobGlnaHQgYSByb3cgb24gaG92ZXIuJ1xyXG4gIH0sXHJcbiAgY29uZGVuc2VkOiB7XHJcbiAgICBsYWJlbDogJ0NvbmRlbnNlZCcsXHJcbiAgICB0eXBlOiAnY2hlY2tib3gnLFxyXG4gICAgdG9vbHRpcDogJ0NvbmRlbnNlIHRoZSBzaXplIG9mIHRoZSB0YWJsZS4nXHJcbiAgfSxcclxuICBkYXRhZ3JpZExhYmVsOiB7XHJcbiAgICBsYWJlbDogJ0RhdGFncmlkIExhYmVsJyxcclxuICAgIHR5cGU6ICdjaGVja2JveCcsXHJcbiAgICB0b29sdGlwOiAnU2hvdyB0aGUgbGFiZWwgd2hlbiBpbiBhIGRhdGFncmlkLidcclxuICB9LFxyXG4gICd2YWxpZGF0ZS5yZXF1aXJlZCc6IHtcclxuICAgIGxhYmVsOiAnUmVxdWlyZWQnLFxyXG4gICAgdHlwZTogJ2NoZWNrYm94JyxcclxuICAgIHRvb2x0aXA6ICdBIHJlcXVpcmVkIGZpZWxkIG11c3QgYmUgZmlsbGVkIGluIGJlZm9yZSB0aGUgZm9ybSBjYW4gYmUgc3VibWl0dGVkLidcclxuICB9LFxyXG4gICd2YWxpZGF0ZS5taW5MZW5ndGgnOiB7XHJcbiAgICBsYWJlbDogJ01pbmltdW0gTGVuZ3RoJyxcclxuICAgIHBsYWNlaG9sZGVyOiAnTWluaW11bSBMZW5ndGgnLFxyXG4gICAgdHlwZTogJ251bWJlcicsXHJcbiAgICB0b29sdGlwOiAnVGhlIG1pbmltdW0gbGVuZ3RoIHJlcXVpcmVtZW50IHRoaXMgZmllbGQgbXVzdCBtZWV0LidcclxuICB9LFxyXG4gICd2YWxpZGF0ZS5tYXhMZW5ndGgnOiB7XHJcbiAgICBsYWJlbDogJ01heGltdW0gTGVuZ3RoJyxcclxuICAgIHBsYWNlaG9sZGVyOiAnTWF4aW11bSBMZW5ndGgnLFxyXG4gICAgdHlwZTogJ251bWJlcicsXHJcbiAgICB0b29sdGlwOiAnVGhlIG1heGltdW0gbGVuZ3RoIHJlcXVpcmVtZW50IHRoaXMgZmllbGQgbXVzdCBtZWV0J1xyXG4gIH0sXHJcbiAgJ3ZhbGlkYXRlLnBhdHRlcm4nOiB7XHJcbiAgICBsYWJlbDogJ1JlZ3VsYXIgRXhwcmVzc2lvbiBQYXR0ZXJuJyxcclxuICAgIHBsYWNlaG9sZGVyOiAnUmVndWxhciBFeHByZXNzaW9uIFBhdHRlcm4nLFxyXG4gICAgdG9vbHRpcDogJ1RoZSByZWd1bGFyIGV4cHJlc3Npb24gcGF0dGVybiB0ZXN0IHRoYXQgdGhlIGZpZWxkIHZhbHVlIG11c3QgcGFzcyBiZWZvcmUgdGhlIGZvcm0gY2FuIGJlIHN1Ym1pdHRlZC4nXHJcbiAgfSxcclxuICAnY3VzdG9tQ2xhc3MnOiB7XHJcbiAgICBsYWJlbDogJ0N1c3RvbSBDU1MgQ2xhc3MnLFxyXG4gICAgcGxhY2Vob2xkZXI6ICdDdXN0b20gQ1NTIENsYXNzJyxcclxuICAgIHRvb2x0aXA6ICdDdXN0b20gQ1NTIGNsYXNzIHRvIGFkZCB0byB0aGlzIGNvbXBvbmVudC4nXHJcbiAgfSxcclxuICAndGFiaW5kZXgnOiB7XHJcbiAgICBsYWJlbDogJ1RhYiBJbmRleCcsXHJcbiAgICBwbGFjZWhvbGRlcjogJ1RhYiBJbmRleCcsXHJcbiAgICB0b29sdGlwOiAnU2V0cyB0aGUgdGFiaW5kZXggYXR0cmlidXRlIG9mIHRoaXMgY29tcG9uZW50IHRvIG92ZXJyaWRlIHRoZSB0YWIgb3JkZXIgb2YgdGhlIGZvcm0uIFNlZSB0aGUgPGEgaHJlZj1cXCdodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0dsb2JhbF9hdHRyaWJ1dGVzL3RhYmluZGV4XFwnPk1ETiBkb2N1bWVudGF0aW9uPC9hPiBvbiB0YWJpbmRleCBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nXHJcbiAgfSxcclxuICAnYWRkQW5vdGhlcic6IHtcclxuICAgIGxhYmVsOiAnQWRkIEFub3RoZXIgVGV4dCcsXHJcbiAgICBwbGFjZWhvbGRlcjogJ0FkZCBBbm90aGVyJyxcclxuICAgIHRvb2x0aXA6ICdTZXQgdGhlIHRleHQgb2YgdGhlIEFkZCBBbm90aGVyIGJ1dHRvbi4nXHJcbiAgfSxcclxuICAnZGVmYXVsdERhdGUnOiB7XHJcbiAgICBsYWJlbDogJ0RlZmF1bHQgVmFsdWUnLFxyXG4gICAgcGxhY2Vob2xkZXI6ICdEZWZhdWx0IFZhbHVlJyxcclxuICAgIHRvb2x0aXA6ICdZb3UgY2FuIHVzZSBNb21lbnQuanMgZnVuY3Rpb25zIHRvIHNldCB0aGUgZGVmYXVsdCB2YWx1ZSB0byBhIHNwZWNpZmljIGRhdGUuIEZvciBleGFtcGxlOiBcXG4gXFxuIG1vbWVudCgpLnN1YnRyYWN0KDEwLCBcXCdkYXlzXFwnKS5jYWxlbmRhcigpOydcclxuICB9LFxyXG4gIC8vIE5lZWQgdG8gdXNlIGFycmF5IG5vdGF0aW9uIHRvIGhhdmUgZGFzaCBpbiBuYW1lXHJcbiAgJ3N0eWxlW1xcJ21hcmdpbi10b3BcXCddJzoge1xyXG4gICAgbGFiZWw6ICdNYXJnaW4gVG9wJyxcclxuICAgIHBsYWNlaG9sZGVyOiAnMHB4JyxcclxuICAgIHRvb2x0aXA6ICdTZXRzIHRoZSB0b3AgbWFyZ2luIG9mIHRoaXMgY29tcG9uZW50LiBNdXN0IGJlIGEgdmFsaWQgQ1NTIG1lYXN1cmVtZW50IGxpa2UgYDEwcHhgLidcclxuICB9LFxyXG4gICdzdHlsZVtcXCdtYXJnaW4tcmlnaHRcXCddJzoge1xyXG4gICAgbGFiZWw6ICdNYXJnaW4gUmlnaHQnLFxyXG4gICAgcGxhY2Vob2xkZXI6ICcwcHgnLFxyXG4gICAgdG9vbHRpcDogJ1NldHMgdGhlIHJpZ2h0IG1hcmdpbiBvZiB0aGlzIGNvbXBvbmVudC4gTXVzdCBiZSBhIHZhbGlkIENTUyBtZWFzdXJlbWVudCBsaWtlIGAxMHB4YC4nXHJcbiAgfSxcclxuICAnc3R5bGVbXFwnbWFyZ2luLWJvdHRvbVxcJ10nOiB7XHJcbiAgICBsYWJlbDogJ01hcmdpbiBCb3R0b20nLFxyXG4gICAgcGxhY2Vob2xkZXI6ICcwcHgnLFxyXG4gICAgdG9vbHRpcDogJ1NldHMgdGhlIGJvdHRvbSBtYXJnaW4gb2YgdGhpcyBjb21wb25lbnQuIE11c3QgYmUgYSB2YWxpZCBDU1MgbWVhc3VyZW1lbnQgbGlrZSBgMTBweGAuJ1xyXG4gIH0sXHJcbiAgJ3N0eWxlW1xcJ21hcmdpbi1sZWZ0XFwnXSc6IHtcclxuICAgIGxhYmVsOiAnTWFyZ2luIExlZnQnLFxyXG4gICAgcGxhY2Vob2xkZXI6ICcwcHgnLFxyXG4gICAgdG9vbHRpcDogJ1NldHMgdGhlIGxlZnQgbWFyZ2luIG9mIHRoaXMgY29tcG9uZW50LiBNdXN0IGJlIGEgdmFsaWQgQ1NTIG1lYXN1cmVtZW50IGxpa2UgYDEwcHhgLidcclxuICB9LFxyXG4gICdhZGRSZXNvdXJjZSc6IHtcclxuICAgIGxhYmVsOiAnU2hvdyBBZGQgUmVzb3VyY2UgQnV0dG9uJyxcclxuICAgIHR5cGU6ICdjaGVja2JveCcsXHJcbiAgICB0b29sdGlwOiAnSW5jbHVkZSBhIGJ1dHRvbiBmb3IgYWRkaW5nIGEgbmV3IHJlc291cmNlJ1xyXG4gIH0sXHJcbiAgJ2FkZFJlc291cmNlTGFiZWwnOiB7XHJcbiAgICBsYWJlbDogJ0FkZCBSZXNvdXJjZSBUZXh0JyxcclxuICAgIHBsYWNlaG9sZGVyOiAnQWRkIFJlc291cmNlJyxcclxuICAgIHRvb2x0aXA6ICdTZXQgdGhlIHRleHQgb2YgdGhlIEFkZCBSZXNvdXJjZSBidXR0b24uJ1xyXG4gIH1cclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBhY3Rpb25zOiBbXHJcbiAgICB7XHJcbiAgICAgIG5hbWU6ICdzdWJtaXQnLFxyXG4gICAgICB0aXRsZTogJ1N1Ym1pdCdcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIG5hbWU6ICdldmVudCcsXHJcbiAgICAgIHRpdGxlOiAnRXZlbnQnXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICBuYW1lOiAncmVzZXQnLFxyXG4gICAgICB0aXRsZTogJ1Jlc2V0J1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgbmFtZTogJ29hdXRoJyxcclxuICAgICAgdGl0bGU6ICdPQXV0aCdcclxuICAgIH1cclxuICBdLFxyXG4gIHRoZW1lczogW1xyXG4gICAge1xyXG4gICAgICBuYW1lOiAnZGVmYXVsdCcsXHJcbiAgICAgIHRpdGxlOiAnRGVmYXVsdCdcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIG5hbWU6ICdwcmltYXJ5JyxcclxuICAgICAgdGl0bGU6ICdQcmltYXJ5J1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgbmFtZTogJ2luZm8nLFxyXG4gICAgICB0aXRsZTogJ0luZm8nXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICBuYW1lOiAnc3VjY2VzcycsXHJcbiAgICAgIHRpdGxlOiAnU3VjY2VzcydcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIG5hbWU6ICdkYW5nZXInLFxyXG4gICAgICB0aXRsZTogJ0RhbmdlcidcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIG5hbWU6ICd3YXJuaW5nJyxcclxuICAgICAgdGl0bGU6ICdXYXJuaW5nJ1xyXG4gICAgfVxyXG4gIF0sXHJcbiAgc2l6ZXM6IFtcclxuICAgIHtcclxuICAgICAgbmFtZTogJ3hzJyxcclxuICAgICAgdGl0bGU6ICdFeHRyYSBTbWFsbCdcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIG5hbWU6ICdzbScsXHJcbiAgICAgIHRpdGxlOiAnU21hbGwnXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICBuYW1lOiAnbWQnLFxyXG4gICAgICB0aXRsZTogJ01lZGl1bSdcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIG5hbWU6ICdsZycsXHJcbiAgICAgIHRpdGxlOiAnTGFyZ2UnXHJcbiAgICB9XHJcbiAgXVxyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qZXNsaW50IG1heC1zdGF0ZW1lbnRzOiAwKi9cclxudmFyIF9jbG9uZURlZXAgPSByZXF1aXJlKCdsb2Rhc2gvY2xvbmVEZWVwJyk7XHJcbnZhciBfZWFjaCA9IHJlcXVpcmUoJ2xvZGFzaC9lYWNoJyk7XHJcbnZhciBfb21pdEJ5ID0gcmVxdWlyZSgnbG9kYXNoL29taXRCeScpO1xyXG52YXIgX2dyb3VwQnkgPSByZXF1aXJlKCdsb2Rhc2gvZ3JvdXBCeScpO1xyXG52YXIgX3VwcGVyRmlyc3QgPSByZXF1aXJlKCdsb2Rhc2gvdXBwZXJGaXJzdCcpO1xyXG52YXIgX21lcmdlID0gcmVxdWlyZSgnbG9kYXNoL21lcmdlJyk7XHJcbnZhciBfY2FwaXRhbGl6ZSA9IHJlcXVpcmUoJ2xvZGFzaC9jYXBpdGFsaXplJyk7XHJcbm1vZHVsZS5leHBvcnRzID0gWydkZWJvdW5jZScsIGZ1bmN0aW9uKGRlYm91bmNlKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlcGxhY2U6IHRydWUsXHJcbiAgICB0ZW1wbGF0ZVVybDogJ2Zvcm1pby9mb3JtYnVpbGRlci9idWlsZGVyLmh0bWwnLFxyXG4gICAgc2NvcGU6IHtcclxuICAgICAgZm9ybTogJz0/JyxcclxuICAgICAgc3JjOiAnPScsXHJcbiAgICAgIHVybDogJz0/JyxcclxuICAgICAgdHlwZTogJz0nLFxyXG4gICAgICBvblNhdmU6ICc9JyxcclxuICAgICAgb25DYW5jZWw6ICc9JyxcclxuICAgICAgb3B0aW9uczogJz0/J1xyXG4gICAgfSxcclxuICAgIGNvbnRyb2xsZXI6IFtcclxuICAgICAgJyRzY29wZScsXHJcbiAgICAgICdmb3JtaW9Db21wb25lbnRzJyxcclxuICAgICAgJ25nRGlhbG9nJyxcclxuICAgICAgJ0Zvcm1pbycsXHJcbiAgICAgICdGb3JtaW9VdGlscycsXHJcbiAgICAgICdkbmREcmFnSWZyYW1lV29ya2Fyb3VuZCcsXHJcbiAgICAgICckaW50ZXJ2YWwnLFxyXG4gICAgICAnJHRpbWVvdXQnLFxyXG4gICAgICBmdW5jdGlvbihcclxuICAgICAgICAkc2NvcGUsXHJcbiAgICAgICAgZm9ybWlvQ29tcG9uZW50cyxcclxuICAgICAgICBuZ0RpYWxvZyxcclxuICAgICAgICBGb3JtaW8sXHJcbiAgICAgICAgRm9ybWlvVXRpbHMsXHJcbiAgICAgICAgZG5kRHJhZ0lmcmFtZVdvcmthcm91bmQsXHJcbiAgICAgICAgJGludGVydmFsLFxyXG4gICAgICAgICR0aW1lb3V0XHJcbiAgICAgICkge1xyXG4gICAgICAgICRzY29wZS5vcHRpb25zID0gJHNjb3BlLm9wdGlvbnMgfHwge307XHJcblxyXG4gICAgICAgIC8vIEFkZCB0aGUgY29tcG9uZW50cyB0byB0aGUgc2NvcGUuXHJcbiAgICAgICAgdmFyIHN1Ym1pdEJ1dHRvbiA9IGFuZ3VsYXIuY29weShmb3JtaW9Db21wb25lbnRzLmNvbXBvbmVudHMuYnV0dG9uLnNldHRpbmdzKTtcclxuICAgICAgICBpZiAoISRzY29wZS5mb3JtKSB7XHJcbiAgICAgICAgICAkc2NvcGUuZm9ybSA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoISRzY29wZS5mb3JtLmNvbXBvbmVudHMpIHtcclxuICAgICAgICAgICRzY29wZS5mb3JtLmNvbXBvbmVudHMgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEkc2NvcGUuZm9ybS5kaXNwbGF5KSB7XHJcbiAgICAgICAgICAkc2NvcGUuZm9ybS5kaXNwbGF5ID0gJ2Zvcm0nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoISRzY29wZS5vcHRpb25zLm5vU3VibWl0ICYmICEkc2NvcGUuZm9ybS5jb21wb25lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgJHNjb3BlLmZvcm0uY29tcG9uZW50cy5wdXNoKHN1Ym1pdEJ1dHRvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICRzY29wZS5oaWRlQ291bnQgPSAyO1xyXG4gICAgICAgICRzY29wZS5mb3JtLnBhZ2UgPSAwO1xyXG4gICAgICAgICRzY29wZS5mb3JtaW8gPSAkc2NvcGUuc3JjID8gbmV3IEZvcm1pbygkc2NvcGUuc3JjKSA6IG51bGw7XHJcbiAgICAgICAgaWYgKCRzY29wZS51cmwpIHtcclxuICAgICAgICAgICRzY29wZS5mb3JtaW8gPSBuZXcgRm9ybWlvKCRzY29wZS51cmwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHNldE51bVBhZ2VzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBpZiAoISRzY29wZS5mb3JtKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICgkc2NvcGUuZm9ybS5kaXNwbGF5ICE9PSAnd2l6YXJkJykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmFyIG51bVBhZ2VzID0gMDtcclxuICAgICAgICAgICRzY29wZS5mb3JtLmNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbihjb21wb25lbnQpIHtcclxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC50eXBlID09PSAncGFuZWwnKSB7XHJcbiAgICAgICAgICAgICAgbnVtUGFnZXMrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgJHNjb3BlLmZvcm0ubnVtUGFnZXMgPSBudW1QYWdlcztcclxuXHJcbiAgICAgICAgICAvLyBBZGQgYSBwYWdlIGlmIG5vbmUgaXMgZm91bmQuXHJcbiAgICAgICAgICBpZiAobnVtUGFnZXMgPT09IDApIHtcclxuICAgICAgICAgICAgJHNjb3BlLm5ld1BhZ2UoKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHBhZ2UgZG9lc24ndCBleGNlZGUgdGhlIGVuZC5cclxuICAgICAgICAgIGlmICgobnVtUGFnZXMgPiAwKSAmJiAoJHNjb3BlLmZvcm0ucGFnZSA+PSBudW1QYWdlcykpIHtcclxuICAgICAgICAgICAgJHNjb3BlLmZvcm0ucGFnZSA9IG51bVBhZ2VzIC0gMTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBMb2FkIHRoZSBmb3JtLlxyXG4gICAgICAgIGlmICgkc2NvcGUuc3JjICYmICRzY29wZS5mb3JtaW8gJiYgJHNjb3BlLmZvcm1pby5mb3JtSWQpIHtcclxuICAgICAgICAgICRzY29wZS5mb3JtaW8ubG9hZEZvcm0oKS50aGVuKGZ1bmN0aW9uKGZvcm0pIHtcclxuICAgICAgICAgICAgJHNjb3BlLmZvcm0gPSBmb3JtO1xyXG4gICAgICAgICAgICBpZiAoISRzY29wZS5mb3JtLmRpc3BsYXkpIHtcclxuICAgICAgICAgICAgICAkc2NvcGUuZm9ybS5kaXNwbGF5ID0gJ2Zvcm0nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghJHNjb3BlLm9wdGlvbnMubm9TdWJtaXQgJiYgJHNjb3BlLmZvcm0uY29tcG9uZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAkc2NvcGUuZm9ybS5jb21wb25lbnRzLnB1c2goc3VibWl0QnV0dG9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAkc2NvcGUuc2hvd1BhZ2UoMCk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEVuc3VyZSB3ZSBhbHdheXMgaGF2ZSBhIHBhZ2Ugc2V0LlxyXG4gICAgICAgICRzY29wZS4kd2F0Y2goJ2Zvcm0ucGFnZScsIGZ1bmN0aW9uKHBhZ2UpIHtcclxuICAgICAgICAgIGlmIChwYWdlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgJHNjb3BlLnNob3dQYWdlKDApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAkc2NvcGUuJHdhdGNoKCdmb3JtLmRpc3BsYXknLCBmdW5jdGlvbihkaXNwbGF5KSB7XHJcbiAgICAgICAgICAkc2NvcGUuaGlkZUNvdW50ID0gKGRpc3BsYXkgPT09ICd3aXphcmQnKSA/IDEgOiAyO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGV5IGRvbid0IHJlbW92ZSBjb21wb25lbnRzIGJ5IGNhbmNlbGluZyB0aGUgZWRpdCBtb2RhbC5cclxuICAgICAgICAkc2NvcGUuJHdhdGNoKCdmb3JtLl9pZCcsIGZ1bmN0aW9uKF9pZCkge1xyXG4gICAgICAgICAgaWYgKCFfaWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgRm9ybWlvVXRpbHMuZWFjaENvbXBvbmVudCgkc2NvcGUuZm9ybS5jb21wb25lbnRzLCBmdW5jdGlvbihjb21wb25lbnQpIHtcclxuICAgICAgICAgICAgZGVsZXRlIGNvbXBvbmVudC5pc05ldztcclxuICAgICAgICAgIH0sIHRydWUpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhleSBjYW4gc3dpdGNoIGJhY2sgYW5kIGZvcnRoIGJldHdlZW4gd2l6YXJkIGFuZCBwYWdlcy5cclxuICAgICAgICAkc2NvcGUuJG9uKCdmb3JtRGlzcGxheScsIGZ1bmN0aW9uKGV2ZW50LCBkaXNwbGF5KSB7XHJcbiAgICAgICAgICAkc2NvcGUuZm9ybS5kaXNwbGF5ID0gZGlzcGxheTtcclxuICAgICAgICAgIHNldE51bVBhZ2VzKCk7XHJcbiAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgJHNjb3BlLnNob3dQYWdlKDApO1xyXG4gICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBmb3JtIHBhZ2VzLlxyXG4gICAgICAgICRzY29wZS5wYWdlcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgdmFyIHBhZ2VzID0gW107XHJcbiAgICAgICAgICAkc2NvcGUuZm9ybS5jb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24oY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQudHlwZSA9PT0gJ3BhbmVsJykge1xyXG4gICAgICAgICAgICAgIGlmIChjb21wb25lbnQudGl0bGUpIHtcclxuICAgICAgICAgICAgICAgIHBhZ2VzLnB1c2goY29tcG9uZW50LnRpdGxlKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwYWdlcy5wdXNoKCdQYWdlICcgKyAocGFnZXMubGVuZ3RoICsgMSkpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICByZXR1cm4gcGFnZXM7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgJHNjb3BlLmdldFBhZ2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHZhciBwYWdlTnVtID0gMDtcclxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHNjb3BlLmZvcm0uY29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gJHNjb3BlLmZvcm0uY29tcG9uZW50c1tpXTtcclxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC50eXBlID09PSAncGFuZWwnKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGkgPT09ICRzY29wZS5mb3JtLnBhZ2UpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBwYWdlTnVtKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBwYWdlTnVtO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIFNob3cgdGhlIGZvcm0gcGFnZS5cclxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtZGVwdGggKi9cclxuICAgICAgICAkc2NvcGUuc2hvd1BhZ2UgPSBmdW5jdGlvbihwYWdlKSB7XHJcbiAgICAgICAgICB2YXIgcGFnZU51bSA9IDA7XHJcbiAgICAgICAgICBpZiAoJHNjb3BlLmZvcm0gJiYgJHNjb3BlLmZvcm0uY29tcG9uZW50cykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8ICRzY29wZS5mb3JtLmNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gJHNjb3BlLmZvcm0uY29tcG9uZW50c1tpXTtcclxuICAgICAgICAgICAgICBpZiAoY29tcG9uZW50LnR5cGUgPT09ICdwYW5lbCcpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwYWdlTnVtID09PSBwYWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgIHBhZ2VOdW0gPSBpO1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBhZ2VOdW0rKztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgICRzY29wZS5mb3JtLnBhZ2UgPSBwYWdlTnVtO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBtYXgtZGVwdGggKi9cclxuXHJcbiAgICAgICAgJHNjb3BlLm5ld1BhZ2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHZhciBpbmRleCA9ICRzY29wZS5mb3JtLm51bVBhZ2VzO1xyXG4gICAgICAgICAgdmFyIHBhZ2VOdW0gPSBpbmRleCArIDE7XHJcbiAgICAgICAgICB2YXIgY29tcG9uZW50ID0ge1xyXG4gICAgICAgICAgICB0eXBlOiAncGFuZWwnLFxyXG4gICAgICAgICAgICB0aXRsZTogJ1BhZ2UgJyArIHBhZ2VOdW0sXHJcbiAgICAgICAgICAgIGlzTmV3OiB0cnVlLFxyXG4gICAgICAgICAgICBjb21wb25lbnRzOiBbXSxcclxuICAgICAgICAgICAgaW5wdXQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBrZXk6ICdwYWdlJyArIHBhZ2VOdW1cclxuICAgICAgICAgIH07XHJcbiAgICAgICAgICAkc2NvcGUuZm9ybS5udW1QYWdlcysrO1xyXG4gICAgICAgICAgJHNjb3BlLiRlbWl0KCduZXdQYWdlJywge1xyXG4gICAgICAgICAgICBpbmRleDogaW5kZXgsXHJcbiAgICAgICAgICAgIGNvbXBvbmVudDogY29tcG9uZW50XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgICRzY29wZS5mb3JtLmNvbXBvbmVudHMuc3BsaWNlKGluZGV4LCAwLCBjb21wb25lbnQpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIEVuc3VyZSB0aGUgbnVtYmVyIG9mIHBhZ2VzIGlzIGFsd2F5cyBjb3JyZWN0LlxyXG4gICAgICAgICRzY29wZS4kd2F0Y2goJ2Zvcm0uY29tcG9uZW50cy5sZW5ndGgnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHNldE51bVBhZ2VzKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICRzY29wZS5mb3JtQ29tcG9uZW50cyA9IF9jbG9uZURlZXAoZm9ybWlvQ29tcG9uZW50cy5jb21wb25lbnRzKTtcclxuICAgICAgICBfZWFjaCgkc2NvcGUuZm9ybUNvbXBvbmVudHMsIGZ1bmN0aW9uKGNvbXBvbmVudCwga2V5KSB7XHJcbiAgICAgICAgICBjb21wb25lbnQuc2V0dGluZ3MuaXNOZXcgPSB0cnVlO1xyXG4gICAgICAgICAgaWYgKGNvbXBvbmVudC5zZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eSgnYnVpbGRlcicpICYmICFjb21wb25lbnQuc2V0dGluZ3MuYnVpbGRlciB8fCBjb21wb25lbnQuZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgZGVsZXRlICRzY29wZS5mb3JtQ29tcG9uZW50c1trZXldO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAkc2NvcGUucGRmdHlwZXMgPSBbXHJcbiAgICAgICAgICAkc2NvcGUuZm9ybUNvbXBvbmVudHMudGV4dGZpZWxkLFxyXG4gICAgICAgICAgJHNjb3BlLmZvcm1Db21wb25lbnRzLm51bWJlcixcclxuICAgICAgICAgICRzY29wZS5mb3JtQ29tcG9uZW50cy5wYXNzd29yZCxcclxuICAgICAgICAgICRzY29wZS5mb3JtQ29tcG9uZW50cy5lbWFpbCxcclxuICAgICAgICAgICRzY29wZS5mb3JtQ29tcG9uZW50cy5waG9uZU51bWJlcixcclxuICAgICAgICAgICRzY29wZS5mb3JtQ29tcG9uZW50cy5jdXJyZW5jeSxcclxuICAgICAgICAgICRzY29wZS5mb3JtQ29tcG9uZW50cy5jaGVja2JveCxcclxuICAgICAgICAgICRzY29wZS5mb3JtQ29tcG9uZW50cy5zaWduYXR1cmUsXHJcbiAgICAgICAgICAkc2NvcGUuZm9ybUNvbXBvbmVudHMuc2VsZWN0LFxyXG4gICAgICAgICAgJHNjb3BlLmZvcm1Db21wb25lbnRzLnRleHRhcmVhLFxyXG4gICAgICAgICAgJHNjb3BlLmZvcm1Db21wb25lbnRzLmRhdGV0aW1lXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgJHNjb3BlLmZvcm1Db21wb25lbnRHcm91cHMgPSBfY2xvbmVEZWVwKF9vbWl0QnkoZm9ybWlvQ29tcG9uZW50cy5ncm91cHMsICdkaXNhYmxlZCcpKTtcclxuICAgICAgICAkc2NvcGUuZm9ybUNvbXBvbmVudHNCeUdyb3VwID0gX2dyb3VwQnkoJHNjb3BlLmZvcm1Db21wb25lbnRzLCBmdW5jdGlvbihjb21wb25lbnQpIHtcclxuICAgICAgICAgIHJldHVybiBjb21wb25lbnQuZ3JvdXA7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgcmVzb3VyY2UgZmllbGRzLlxyXG4gICAgICAgIHZhciByZXNvdXJjZUVuYWJsZWQgPSAhZm9ybWlvQ29tcG9uZW50cy5ncm91cHMucmVzb3VyY2UgfHwgIWZvcm1pb0NvbXBvbmVudHMuZ3JvdXBzLnJlc291cmNlLmRpc2FibGVkO1xyXG4gICAgICAgIGlmICgkc2NvcGUuZm9ybWlvICYmIHJlc291cmNlRW5hYmxlZCkge1xyXG4gICAgICAgICAgJHNjb3BlLmZvcm1Db21wb25lbnRzQnlHcm91cC5yZXNvdXJjZSA9IHt9O1xyXG4gICAgICAgICAgJHNjb3BlLmZvcm1Db21wb25lbnRHcm91cHMucmVzb3VyY2UgPSB7XHJcbiAgICAgICAgICAgIHRpdGxlOiAnRXhpc3RpbmcgUmVzb3VyY2UgRmllbGRzJyxcclxuICAgICAgICAgICAgcGFuZWxDbGFzczogJ3N1Ymdyb3VwLWFjY29yZGlvbi1jb250YWluZXInLFxyXG4gICAgICAgICAgICBzdWJncm91cHM6IHt9XHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICRzY29wZS5mb3JtaW8ubG9hZEZvcm1zKHtwYXJhbXM6IHt0eXBlOiAncmVzb3VyY2UnLCBsaW1pdDogMTAwfX0pLnRoZW4oZnVuY3Rpb24ocmVzb3VyY2VzKSB7XHJcbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBhbGwgcmVzb3VyY2VzLlxyXG4gICAgICAgICAgICBfZWFjaChyZXNvdXJjZXMsIGZ1bmN0aW9uKHJlc291cmNlKSB7XHJcbiAgICAgICAgICAgICAgdmFyIHJlc291cmNlS2V5ID0gcmVzb3VyY2UubmFtZTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQWRkIGEgbGVnZW5kIGZvciB0aGlzIHJlc291cmNlLlxyXG4gICAgICAgICAgICAgICRzY29wZS5mb3JtQ29tcG9uZW50c0J5R3JvdXAucmVzb3VyY2VbcmVzb3VyY2VLZXldID0gW107XHJcbiAgICAgICAgICAgICAgJHNjb3BlLmZvcm1Db21wb25lbnRHcm91cHMucmVzb3VyY2Uuc3ViZ3JvdXBzW3Jlc291cmNlS2V5XSA9IHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiByZXNvdXJjZS50aXRsZVxyXG4gICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBlYWNoIGNvbXBvbmVudC5cclxuICAgICAgICAgICAgICBGb3JtaW9VdGlscy5lYWNoQ29tcG9uZW50KHJlc291cmNlLmNvbXBvbmVudHMsIGZ1bmN0aW9uKGNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC50eXBlID09PSAnYnV0dG9uJykgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnROYW1lID0gY29tcG9uZW50LmxhYmVsO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjb21wb25lbnROYW1lICYmIGNvbXBvbmVudC5rZXkpIHtcclxuICAgICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZSA9IF91cHBlckZpcnN0KGNvbXBvbmVudC5rZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICRzY29wZS5mb3JtQ29tcG9uZW50c0J5R3JvdXAucmVzb3VyY2VbcmVzb3VyY2VLZXldLnB1c2goX21lcmdlKFxyXG4gICAgICAgICAgICAgICAgICBfY2xvbmVEZWVwKGZvcm1pb0NvbXBvbmVudHMuY29tcG9uZW50c1tjb21wb25lbnQudHlwZV0sIHRydWUpLFxyXG4gICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGNvbXBvbmVudE5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXA6ICdyZXNvdXJjZScsXHJcbiAgICAgICAgICAgICAgICAgICAgc3ViZ3JvdXA6IHJlc291cmNlS2V5LFxyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzOiBjb21wb25lbnRcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogY29tcG9uZW50LmxhYmVsLFxyXG4gICAgICAgICAgICAgICAgICAgICAga2V5OiBjb21wb25lbnQua2V5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgbG9ja0tleTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogcmVzb3VyY2UuX2lkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgaXNOZXc6IHRydWVcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICkpO1xyXG4gICAgICAgICAgICAgIH0sIHRydWUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgJHNjb3BlLiRlbWl0KCdmb3JtVXBkYXRlJywgJHNjb3BlLmZvcm0pO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIEFkZCBhIG5ldyBjb21wb25lbnQuXHJcbiAgICAgICAgJHNjb3BlLiRvbignZm9ybUJ1aWxkZXI6YWRkJywgdXBkYXRlKTtcclxuICAgICAgICAkc2NvcGUuJG9uKCdmb3JtQnVpbGRlcjp1cGRhdGUnLCB1cGRhdGUpO1xyXG4gICAgICAgICRzY29wZS4kb24oJ2Zvcm1CdWlsZGVyOnJlbW92ZScsIHVwZGF0ZSk7XHJcbiAgICAgICAgJHNjb3BlLiRvbignZm9ybUJ1aWxkZXI6ZWRpdCcsIHVwZGF0ZSk7XHJcblxyXG4gICAgICAgICRzY29wZS5zYXZlU2V0dGluZ3MgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIG5nRGlhbG9nLmNsb3NlQWxsKHRydWUpO1xyXG4gICAgICAgICAgJHNjb3BlLiRlbWl0KCdmb3JtVXBkYXRlJywgJHNjb3BlLmZvcm0pO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgICRzY29wZS5jYXBpdGFsaXplID0gX2NhcGl0YWxpemU7XHJcblxyXG4gICAgICAgIC8vIFNldCB0aGUgcm9vdCBsaXN0IGhlaWdodCB0byB0aGUgaGVpZ2h0IG9mIHRoZSBmb3JtYnVpbGRlciBmb3IgZWFzZSBvZiBmb3JtIGJ1aWxkaW5nLlxyXG4gICAgICAgIHZhciByb290bGlzdEVMID0gYW5ndWxhci5lbGVtZW50KCcucm9vdGxpc3QnKTtcclxuICAgICAgICB2YXIgZm9ybWJ1aWxkZXJFTCA9IGFuZ3VsYXIuZWxlbWVudCgnLmZvcm1idWlsZGVyJyk7XHJcblxyXG4gICAgICAgICRpbnRlcnZhbChmdW5jdGlvbiBzZXRSb290TGlzdEhlaWdodCgpIHtcclxuICAgICAgICAgIHZhciBsaXN0SGVpZ2h0ID0gcm9vdGxpc3RFTC5oZWlnaHQoJ2luaGVyaXQnKS5oZWlnaHQoKTtcclxuICAgICAgICAgIHZhciBidWlsZGVySGVpZ2h0ID0gZm9ybWJ1aWxkZXJFTC5oZWlnaHQoKTtcclxuICAgICAgICAgIGlmICgoYnVpbGRlckhlaWdodCAtIGxpc3RIZWlnaHQpID4gMTAwKSB7XHJcbiAgICAgICAgICAgIHJvb3RsaXN0RUwuaGVpZ2h0KGJ1aWxkZXJIZWlnaHQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sIDEwMDApO1xyXG5cclxuICAgICAgICAvLyBBZGQgdG8gc2NvcGUgc28gaXQgY2FuIGJlIHVzZWQgaW4gdGVtcGxhdGVzXHJcbiAgICAgICAgJHNjb3BlLmRuZERyYWdJZnJhbWVXb3JrYXJvdW5kID0gZG5kRHJhZ0lmcmFtZVdvcmthcm91bmQ7XHJcbiAgICAgICAgJHNjb3BlLnNob3dQYWdlKDApO1xyXG4gICAgICB9XHJcbiAgICBdLFxyXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQpIHtcclxuICAgICAgdmFyIHNjcm9sbFNpZGViYXIgPSBkZWJvdW5jZShmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyBEaXNhYmxlIGFsbCBidXR0b25zIHdpdGhpbiB0aGUgZm9ybS5cclxuICAgICAgICBhbmd1bGFyLmVsZW1lbnQoJy5mb3JtYnVpbGRlcicpLmZpbmQoJ2J1dHRvbicpLmF0dHIoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XHJcblxyXG4gICAgICAgIC8vIE1ha2UgdGhlIGxlZnQgY29sdW1uIGZvbGxvdyB0aGUgZm9ybS5cclxuICAgICAgICB2YXIgZm9ybUNvbXBvbmVudHMgPSBhbmd1bGFyLmVsZW1lbnQoJy5mb3JtY29tcG9uZW50cycpO1xyXG4gICAgICAgIHZhciBmb3JtQnVpbGRlciA9IGFuZ3VsYXIuZWxlbWVudCgnLmZvcm1idWlsZGVyJyk7XHJcbiAgICAgICAgaWYgKGZvcm1Db21wb25lbnRzLmxlbmd0aCAhPT0gMCAmJiBmb3JtQnVpbGRlci5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgIHZhciBtYXhTY3JvbGwgPSBmb3JtQnVpbGRlci5vdXRlckhlaWdodCgpID4gZm9ybUNvbXBvbmVudHMub3V0ZXJIZWlnaHQoKSA/IGZvcm1CdWlsZGVyLm91dGVySGVpZ2h0KCkgLSBmb3JtQ29tcG9uZW50cy5vdXRlckhlaWdodCgpIDogMDtcclxuICAgICAgICAgIC8vIDUwIHBpeGVscyBnaXZlcyBzcGFjZSBmb3IgdGhlIGZpeGVkIGhlYWRlci5cclxuICAgICAgICAgIHZhciBzY3JvbGwgPSBhbmd1bGFyLmVsZW1lbnQod2luZG93KS5zY3JvbGxUb3AoKSAtIGZvcm1Db21wb25lbnRzLnBhcmVudCgpLm9mZnNldCgpLnRvcCArIDUwO1xyXG4gICAgICAgICAgaWYgKHNjcm9sbCA8IDApIHtcclxuICAgICAgICAgICAgc2Nyb2xsID0gMDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChzY3JvbGwgPiBtYXhTY3JvbGwpIHtcclxuICAgICAgICAgICAgc2Nyb2xsID0gbWF4U2Nyb2xsO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZm9ybUNvbXBvbmVudHMuY3NzKCdtYXJnaW4tdG9wJywgc2Nyb2xsICsgJ3B4Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LCAxMDAsIGZhbHNlKTtcclxuICAgICAgd2luZG93Lm9uc2Nyb2xsID0gc2Nyb2xsU2lkZWJhcjtcclxuICAgICAgZWxlbWVudC5vbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcclxuICAgICAgICB3aW5kb3cub25zY3JvbGwgPSBudWxsO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9O1xyXG59XTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcclxuICogQ3JlYXRlIHRoZSBmb3JtLWJ1aWxkZXItY29tcG9uZW50IGRpcmVjdGl2ZS5cclxuICogRXh0ZW5kIHRoZSBmb3JtaW8tY29tcG9uZW50IGRpcmVjdGl2ZSBhbmQgY2hhbmdlIHRoZSB0ZW1wbGF0ZS5cclxuICovXHJcbm1vZHVsZS5leHBvcnRzID0gW1xyXG4gICdmb3JtaW9Db21wb25lbnREaXJlY3RpdmUnLFxyXG4gIGZ1bmN0aW9uKGZvcm1pb0NvbXBvbmVudERpcmVjdGl2ZSkge1xyXG4gICAgcmV0dXJuIGFuZ3VsYXIuZXh0ZW5kKHt9LCBmb3JtaW9Db21wb25lbnREaXJlY3RpdmVbMF0sIHtcclxuICAgICAgc2NvcGU6IGZhbHNlLFxyXG4gICAgICB0ZW1wbGF0ZVVybDogJ2Zvcm1pby9mb3JtYnVpbGRlci9jb21wb25lbnQuaHRtbCdcclxuICAgIH0pO1xyXG4gIH1cclxuXTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4ndXNlIHN0cmljdCc7XHJcbnZhciB1dGlscyA9IHJlcXVpcmUoJ2Zvcm1pb2pzL3V0aWxzJyk7XHJcbnZhciBfZ2V0ID0gcmVxdWlyZSgnbG9kYXNoL2dldCcpO1xyXG52YXIgX3JlamVjdCA9IHJlcXVpcmUoJ2xvZGFzaC9yZWplY3QnKTtcclxubW9kdWxlLmV4cG9ydHMgPSBbXHJcbiAgZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICBzY29wZTogdHJ1ZSxcclxuICAgICAgdGVtcGxhdGU6ICcnICtcclxuICAgICAgICAnPHVpYi1hY2NvcmRpb24+JyArXHJcbiAgICAgICAgICAnPGRpdiB1aWItYWNjb3JkaW9uLWdyb3VwIGhlYWRpbmc9XCJTaW1wbGVcIiBjbGFzcz1cInBhbmVsIHBhbmVsLWRlZmF1bHRcIiBpcy1vcGVuPVwic3RhdHVzLnNpbXBsZVwiPicgK1xyXG4gICAgICAgICAgICAnVGhpcyBjb21wb25lbnQgc2hvdWxkIERpc3BsYXk6JyArXHJcbiAgICAgICAgICAgICc8c2VsZWN0IGNsYXNzPVwiZm9ybS1jb250cm9sIGlucHV0LW1kXCIgbmctbW9kZWw9XCJjb21wb25lbnQuY29uZGl0aW9uYWwuc2hvd1wiPicgK1xyXG4gICAgICAgICAgICAnPG9wdGlvbiBuZy1yZXBlYXQ9XCJpdGVtIGluIF9ib29sZWFucyB0cmFjayBieSAkaW5kZXhcIiB2YWx1ZT1cInt7aXRlbX19XCI+e3tpdGVtLnRvU3RyaW5nKCl9fTwvb3B0aW9uPicgK1xyXG4gICAgICAgICAgICAnPC9zZWxlY3Q+JyArXHJcbiAgICAgICAgICAgICc8YnI+V2hlbiB0aGUgZm9ybSBjb21wb25lbnQ6JyArXHJcbiAgICAgICAgICAgICc8c2VsZWN0IGNsYXNzPVwiZm9ybS1jb250cm9sIGlucHV0LW1kXCIgbmctbW9kZWw9XCJjb21wb25lbnQuY29uZGl0aW9uYWwud2hlblwiPicgK1xyXG4gICAgICAgICAgICAnPG9wdGlvbiBuZy1yZXBlYXQ9XCJpdGVtIGluIF9jb21wb25lbnRzIHRyYWNrIGJ5ICRpbmRleFwiIHZhbHVlPVwie3tpdGVtLmtleX19XCI+e3tpdGVtICE9PSBcIlwiID8gaXRlbS5sYWJlbCArIFwiIChcIiArIGl0ZW0ua2V5ICsgXCIpXCIgOiBcIlwifX08L29wdGlvbj4nICtcclxuICAgICAgICAgICAgJzwvc2VsZWN0PicgK1xyXG4gICAgICAgICAgICAnPGJyPkhhcyB0aGUgdmFsdWU6JyArXHJcbiAgICAgICAgICAgICc8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbCBpbnB1dC1tZFwiIG5nLW1vZGVsPVwiY29tcG9uZW50LmNvbmRpdGlvbmFsLmVxXCI+JyArXHJcbiAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAnPGRpdiB1aWItYWNjb3JkaW9uLWdyb3VwIGhlYWRpbmc9XCJBZHZhbmNlZFwiIGNsYXNzPVwicGFuZWwgcGFuZWwtZGVmYXVsdFwiIGlzLW9wZW49XCJzdGF0dXMuYWR2YW5jZWRcIj4nICtcclxuICAgICAgICAgICAgJzx0ZXh0YXJlYSBjbGFzcz1cImZvcm0tY29udHJvbFwiIHJvd3M9XCI1XCIgaWQ9XCJjdXN0b21cIiBuYW1lPVwiY3VzdG9tXCIgbmctbW9kZWw9XCJjb21wb25lbnQuY3VzdG9tQ29uZGl0aW9uYWxcIiBwbGFjZWhvbGRlcj1cIi8qKiogRXhhbXBsZSBDb2RlICoqKi9cXG5zaG93ID0gKGRhdGFbXFwnbXlrZXlcXCddID4gMSk7XCI+PC90ZXh0YXJlYT4nICtcclxuICAgICAgICAgICAgJzxzbWFsbD4nICtcclxuICAgICAgICAgICAgJzxwPkVudGVyIGN1c3RvbSBjb25kaXRpb25hbCBjb2RlLjwvcD4nICtcclxuICAgICAgICAgICAgJzxwPllvdSBtdXN0IGFzc2lnbiB0aGUgPHN0cm9uZz5zaG93PC9zdHJvbmc+IHZhcmlhYmxlIGFzIGVpdGhlciA8c3Ryb25nPnRydWU8L3N0cm9uZz4gb3IgPHN0cm9uZz5mYWxzZTwvc3Ryb25nPi48L3A+JyArXHJcbiAgICAgICAgICAgICc8cD5UaGUgZ2xvYmFsIHZhcmlhYmxlIDxzdHJvbmc+ZGF0YTwvc3Ryb25nPiBpcyBwcm92aWRlZCwgYW5kIGFsbG93cyB5b3UgdG8gYWNjZXNzIHRoZSBkYXRhIG9mIGFueSBmb3JtIGNvbXBvbmVudCwgYnkgdXNpbmcgaXRzIEFQSSBrZXkuPC9wPicgK1xyXG4gICAgICAgICAgICAnPHA+PHN0cm9uZz5Ob3RlOiBBZHZhbmNlZCBDb25kaXRpb25hbCBsb2dpYyB3aWxsIG92ZXJyaWRlIHRoZSByZXN1bHRzIG9mIHRoZSBTaW1wbGUgQ29uZGl0aW9uYWwgbG9naWMuPC9zdHJvbmc+PC9wPicgK1xyXG4gICAgICAgICAgICAnPC9zbWFsbD4nICtcclxuICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICc8ZGl2IHVpYi1hY2NvcmRpb24tZ3JvdXAgaGVhZGluZz1cIkpTT04gQ29uZGl0aW9uYWxcIiBjbGFzcz1cInBhbmVsIHBhbmVsLWRlZmF1bHRcIiBpcy1vcGVuPVwic3RhdHVzLmpzb25cIj4nICtcclxuICAgICAgICAgICAgJzxzbWFsbD4nICtcclxuICAgICAgICAgICAgICAnPHA+RXhlY3V0ZSBjdXN0b20gdmFsaWRhdGlvbiBsb2dpYyB3aXRoIEpTT04gYW5kIDxhIGhyZWY9XCJodHRwOi8vanNvbmxvZ2ljLmNvbS9cIj5Kc29uTG9naWM8L2E+LjwvcD4nICtcclxuICAgICAgICAgICAgICAnPHA+U3VibWlzc2lvbiBkYXRhIGlzIGF2YWlsYWJsZSBhcyBKc29uTG9naWMgdmFyaWFibGVzLCB3aXRoIHRoZSBzYW1lIGFwaSBrZXkgYXMgeW91ciBjb21wb25lbnRzLjwvcD4nICtcclxuICAgICAgICAgICAgICAnPHA+PGEgaHJlZj1cImh0dHA6Ly9mb3JtaW8uZ2l0aHViLmlvL2Zvcm1pby5qcy9hcHAvZXhhbXBsZXMvY29uZGl0aW9ucy5odG1sXCIgdGFyZ2V0PVwiX2JsYW5rXCI+Q2xpY2sgaGVyZSBmb3IgYW4gZXhhbXBsZTwvYT48L3A+JyArXHJcbiAgICAgICAgICAgICc8L3NtYWxsPicgK1xyXG4gICAgICAgICAgICAnPHRleHRhcmVhIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgcm93cz1cIjVcIiBpZD1cImpzb25cIiBuYW1lPVwianNvblwiIGpzb24taW5wdXQgbmctbW9kZWw9XCJjb21wb25lbnQuY29uZGl0aW9uYWwuanNvblwiIHBsYWNlaG9sZGVyPVwieyAuLi4gfVwiPjwvdGV4dGFyZWE+JyArXHJcbiAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgJzwvdWliLWFjY29yZGlvbj4nLFxyXG4gICAgICBjb250cm9sbGVyOiBbXHJcbiAgICAgICAgJyRzY29wZScsXHJcbiAgICAgICAgZnVuY3Rpb24oXHJcbiAgICAgICAgICAkc2NvcGUpIHtcclxuICAgICAgICAgIC8vIERlZmF1bHQgdGhlIGN1cnJlbnQgY29tcG9uZW50cyBjb25kaXRpb25hbCBsb2dpYy5cclxuICAgICAgICAgICRzY29wZS5jb21wb25lbnQgPSAkc2NvcGUuY29tcG9uZW50IHx8IHt9O1xyXG4gICAgICAgICAgJHNjb3BlLmNvbXBvbmVudC5jb25kaXRpb25hbCA9ICRzY29wZS5jb21wb25lbnQuY29uZGl0aW9uYWwgfHwge307XHJcblxyXG4gICAgICAgICAgLy8gVGhlIGF2YWlsYWJsZSBsb2dpYyBmdW5jdGlvbnMuXHJcbiAgICAgICAgICAkc2NvcGUuX2Jvb2xlYW5zID0gWycnLCAndHJ1ZScsICdmYWxzZSddO1xyXG5cclxuICAgICAgICAgIC8vIEZpbHRlciB0aGUgbGlzdCBvZiBhdmFpbGFibGUgZm9ybSBjb21wb25lbnRzIGZvciBjb25kaXRpb25hbCBsb2dpYy5cclxuICAgICAgICAgICRzY29wZS5fY29tcG9uZW50cyA9IF9nZXQoJHNjb3BlLCAnZm9ybS5jb21wb25lbnRzJykgfHwgW107XHJcbiAgICAgICAgICAkc2NvcGUuX2NvbXBvbmVudHMgPSB1dGlscy5mbGF0dGVuQ29tcG9uZW50cygkc2NvcGUuX2NvbXBvbmVudHMpO1xyXG4gICAgICAgICAgLy8gUmVtb3ZlIG5vbi1pbnB1dC9idXR0b24gZmllbGRzIGJlY2F1c2UgdGhleSBkb24ndCBtYWtlIHNlbnNlLlxyXG4gICAgICAgICAgLy8gRkEtODkwIC0gRG9udCBhbGxvdyB0aGUgY3VycmVudCBjb21wb25lbnQgdG8gYmUgYSBjb25kaXRpb25hbCB0cmlnZ2VyLlxyXG4gICAgICAgICAgJHNjb3BlLl9jb21wb25lbnRzID0gX3JlamVjdCgkc2NvcGUuX2NvbXBvbmVudHMsIGZ1bmN0aW9uKGMpIHtcclxuICAgICAgICAgICAgcmV0dXJuICFjLmlucHV0IHx8IChjLnR5cGUgPT09ICdidXR0b24nKSB8fCAoYy5rZXkgPT09ICRzY29wZS5jb21wb25lbnQua2V5KSB8fCAoIWMubGFiZWwgJiYgIWMua2V5KTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIC8vIEFkZCBkZWZhdWx0IGl0ZW0gdG8gdGhlIGNvbXBvbmVudHMgbGlzdC5cclxuICAgICAgICAgICRzY29wZS5fY29tcG9uZW50cy51bnNoaWZ0KCcnKTtcclxuXHJcbiAgICAgICAgICAvLyBEZWZhdWx0IGFuZCB3YXRjaCB0aGUgc2hvdyBsb2dpYy5cclxuICAgICAgICAgICRzY29wZS5jb21wb25lbnQuY29uZGl0aW9uYWwuc2hvdyA9ICRzY29wZS5jb21wb25lbnQuY29uZGl0aW9uYWwuc2hvdyB8fCAnJztcclxuICAgICAgICAgIC8vIENvZXJjZSBzaG93IHZhciB0byBzdXBwb3J0ZWQgdmFsdWUuXHJcbiAgICAgICAgICB2YXIgX2Jvb2xlYW5NYXAgPSB7XHJcbiAgICAgICAgICAgICcnOiAnJyxcclxuICAgICAgICAgICAgJ3RydWUnOiAndHJ1ZScsXHJcbiAgICAgICAgICAgICdmYWxzZSc6ICdmYWxzZSdcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgICAkc2NvcGUuY29tcG9uZW50LmNvbmRpdGlvbmFsLnNob3cgPSBfYm9vbGVhbk1hcC5oYXNPd25Qcm9wZXJ0eSgkc2NvcGUuY29tcG9uZW50LmNvbmRpdGlvbmFsLnNob3cpXHJcbiAgICAgICAgICAgID8gX2Jvb2xlYW5NYXBbJHNjb3BlLmNvbXBvbmVudC5jb25kaXRpb25hbC5zaG93XVxyXG4gICAgICAgICAgICA6ICcnO1xyXG5cclxuICAgICAgICAgIC8vIERlZmF1bHQgYW5kIHdhdGNoIHRoZSB3aGVuIGxvZ2ljLlxyXG4gICAgICAgICAgJHNjb3BlLmNvbXBvbmVudC5jb25kaXRpb25hbC53aGVuID0gJHNjb3BlLmNvbXBvbmVudC5jb25kaXRpb25hbC53aGVuIHx8IG51bGw7XHJcblxyXG4gICAgICAgICAgLy8gRGVmYXVsdCBhbmQgd2F0Y2ggdGhlIHNlYXJjaCBsb2dpYy5cclxuICAgICAgICAgICRzY29wZS5jb21wb25lbnQuY29uZGl0aW9uYWwuZXEgPSAkc2NvcGUuY29tcG9uZW50LmNvbmRpdGlvbmFsLmVxIHx8ICcnO1xyXG5cclxuICAgICAgICAgIC8vIFRyYWNrIHRoZSBzdGF0dXMgb2YgdGhlIGFjY29yZGlvbiBwYW5lbHMgb3BlbiBzdGF0ZS5cclxuICAgICAgICAgICRzY29wZS5zdGF0dXMgPSB7XHJcbiAgICAgICAgICAgIHNpbXBsZTogISRzY29wZS5jb21wb25lbnQuY3VzdG9tQ29uZGl0aW9uYWwsXHJcbiAgICAgICAgICAgIGFkdmFuY2VkOiAhISRzY29wZS5jb21wb25lbnQuY3VzdG9tQ29uZGl0aW9uYWxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICBdXHJcbiAgICB9O1xyXG4gIH1cclxuXTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX2lzTnVtYmVyID0gcmVxdWlyZSgnbG9kYXNoL2lzTnVtYmVyJyk7XHJcbnZhciBfY2FtZWxDYXNlID0gcmVxdWlyZSgnbG9kYXNoL2NhbWVsQ2FzZScpO1xyXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ2xvZGFzaC9hc3NpZ24nKTtcclxubW9kdWxlLmV4cG9ydHMgPSBbXHJcbiAgJyRzY29wZScsXHJcbiAgJyRlbGVtZW50JyxcclxuICAnJHJvb3RTY29wZScsXHJcbiAgJ2Zvcm1pb0NvbXBvbmVudHMnLFxyXG4gICdGb3JtaW9VdGlscycsXHJcbiAgJ25nRGlhbG9nJyxcclxuICAnZG5kRHJhZ0lmcmFtZVdvcmthcm91bmQnLFxyXG4gICckdGltZW91dCcsXHJcbiAgJ0J1aWxkZXJVdGlscycsXHJcbiAgZnVuY3Rpb24oXHJcbiAgICAkc2NvcGUsXHJcbiAgICAkZWxlbWVudCxcclxuICAgICRyb290U2NvcGUsXHJcbiAgICBmb3JtaW9Db21wb25lbnRzLFxyXG4gICAgRm9ybWlvVXRpbHMsXHJcbiAgICBuZ0RpYWxvZyxcclxuICAgIGRuZERyYWdJZnJhbWVXb3JrYXJvdW5kLFxyXG4gICAgJHRpbWVvdXQsXHJcbiAgICBCdWlsZGVyVXRpbHNcclxuICApIHtcclxuICAgICRzY29wZS5idWlsZGVyID0gdHJ1ZTtcclxuICAgICRyb290U2NvcGUuYnVpbGRlciA9IHRydWU7XHJcbiAgICAkc2NvcGUuaGlkZUNvdW50ID0gKF9pc051bWJlcigkc2NvcGUuaGlkZURuZEJveENvdW50KSA/ICRzY29wZS5oaWRlRG5kQm94Q291bnQgOiAxKTtcclxuICAgICRzY29wZS4kd2F0Y2goJ2hpZGVEbmRCb3hDb3VudCcsIGZ1bmN0aW9uKGhpZGVDb3VudCkge1xyXG4gICAgICAkc2NvcGUuaGlkZUNvdW50ID0gaGlkZUNvdW50ID8gaGlkZUNvdW50IDogMTtcclxuICAgIH0pO1xyXG5cclxuICAgICRzY29wZS5mb3JtQ29tcG9uZW50cyA9IGZvcm1pb0NvbXBvbmVudHMuY29tcG9uZW50cztcclxuICAgIGlmICghJHNjb3BlLmNvbXBvbmVudCkge1xyXG4gICAgICAkc2NvcGUuY29tcG9uZW50ID0gJHNjb3BlLmZvcm07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29tcG9uZW50cyBkZXBlbmQgb24gdGhpcyBleGlzdGluZ1xyXG4gICAgJHNjb3BlLmRhdGEgPSB7fTtcclxuXHJcbiAgICAkc2NvcGUuZW1pdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcclxuICAgICAgYXJnc1swXSA9ICdmb3JtQnVpbGRlcjonICsgYXJnc1swXTtcclxuICAgICAgJHNjb3BlLiRlbWl0LmFwcGx5KCRzY29wZSwgYXJncyk7XHJcbiAgICB9O1xyXG5cclxuICAgICRzY29wZS4kb24oJ2lmcmFtZS1jb21wb25lbnRDbGljaycsIGZ1bmN0aW9uKGV2ZW50LCBkYXRhKSB7XHJcbiAgICAgIGFuZ3VsYXIuZm9yRWFjaCgkc2NvcGUuY29tcG9uZW50LmNvbXBvbmVudHMsIGZ1bmN0aW9uKGNvbXBvbmVudCkge1xyXG4gICAgICAgIGlmIChjb21wb25lbnQuaWQgPT09IGRhdGEuaWQpIHtcclxuICAgICAgICAgICRzY29wZS5lZGl0Q29tcG9uZW50KGNvbXBvbmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgJHNjb3BlLiRvbignaWZyYW1lLWNvbXBvbmVudFVwZGF0ZScsIGZ1bmN0aW9uKGV2ZW50LCBkYXRhKSB7XHJcbiAgICAgIGFuZ3VsYXIuZm9yRWFjaCgkc2NvcGUuY29tcG9uZW50LmNvbXBvbmVudHMsIGZ1bmN0aW9uKGNvbXBvbmVudCkge1xyXG4gICAgICAgIGlmIChjb21wb25lbnQuaWQgPT09IGRhdGEuaWQpIHtcclxuICAgICAgICAgIGNvbXBvbmVudC5vdmVybGF5ID0gZGF0YS5vdmVybGF5O1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAkc2NvcGUuJG9uKCdmYkRyYWdEcm9wJywgZnVuY3Rpb24oZXZlbnQsIGNvbXBvbmVudCkge1xyXG4gICAgICBjb21wb25lbnQuc2V0dGluZ3MuaWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNyk7XHJcbiAgICAgIGNvbXBvbmVudC5zZXR0aW5ncy5vdmVybGF5ID0ge1xyXG4gICAgICAgIHBhZ2U6ICcxJyxcclxuICAgICAgICB0b3A6IGNvbXBvbmVudC5mYkRyb3BZLFxyXG4gICAgICAgIGxlZnQ6IGNvbXBvbmVudC5mYkRyb3BYXHJcbiAgICAgIH07XHJcbiAgICAgICRzY29wZS5hZGRDb21wb25lbnQoY29tcG9uZW50LnNldHRpbmdzKTtcclxuICAgIH0pO1xyXG5cclxuICAgICRzY29wZS5hZGRDb21wb25lbnQgPSBmdW5jdGlvbihjb21wb25lbnQsIGluZGV4KSB7XHJcbiAgICAgIGlmIChpbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBpbmRleCA9IC0xO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIE9ubHkgZWRpdCBpbW1lZGlhdGVseSBmb3IgY29tcG9uZW50cyB0aGF0IGFyZSBub3QgcmVzb3VyY2UgY29tcHMuXHJcbiAgICAgIGlmIChjb21wb25lbnQuaXNOZXcgJiYgIWNvbXBvbmVudC5sb2NrQ29uZmlndXJhdGlvbiAmJiAoIWNvbXBvbmVudC5rZXkgfHwgKGNvbXBvbmVudC5rZXkuaW5kZXhPZignLicpID09PSAtMSkpKSB7XHJcbiAgICAgICAgJHNjb3BlLmVkaXRDb21wb25lbnQoY29tcG9uZW50KTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAvLyBFbnN1cmUgdGhlIGNvbXBvbmVudCBoYXMgYSBrZXkuXHJcbiAgICAgICAgY29tcG9uZW50LmtleSA9IGNvbXBvbmVudC5rZXkgfHwgY29tcG9uZW50LmxhYmVsIHx8ICdjb21wb25lbnQnO1xyXG5cclxuICAgICAgICBCdWlsZGVyVXRpbHMudW5pcXVpZnkoJHNjb3BlLmZvcm0sIGNvbXBvbmVudCk7XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgY29tcG9uZW50IHRvIG5vdCBiZSBmbGFnZ2VkIGFzIG5ldyBhbnltb3JlLlxyXG4gICAgICAgIEZvcm1pb1V0aWxzLmVhY2hDb21wb25lbnQoW2NvbXBvbmVudF0sIGZ1bmN0aW9uKGNoaWxkKSB7XHJcbiAgICAgICAgICBkZWxldGUgY2hpbGQuaXNOZXc7XHJcbiAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlZnJlc2ggYWxsIENLRWRpdG9yIGluc3RhbmNlc1xyXG4gICAgICAkc2NvcGUuJGJyb2FkY2FzdCgnY2tlZGl0b3IucmVmcmVzaCcpO1xyXG5cclxuICAgICAgZG5kRHJhZ0lmcmFtZVdvcmthcm91bmQuaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgICAkc2NvcGUuZW1pdCgnYWRkJyk7XHJcbiAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdpZnJhbWVNZXNzYWdlJywge25hbWU6ICdhZGRFbGVtZW50JywgZGF0YTogY29tcG9uZW50fSk7XHJcblxyXG4gICAgICAvLyBJZiB0aGlzIGlzIGEgcm9vdCBjb21wb25lbnQgYW5kIHRoZSBkaXNwbGF5IGlzIGEgd2l6YXJkLCB0aGVuIHdlIGtub3dcclxuICAgICAgLy8gdGhhdCB0aGV5IGRyb3BwZWQgdGhlIGNvbXBvbmVudCBvdXRzaWRlIG9mIHdoZXJlIGl0IGlzIHN1cHBvc2VkIHRvIGdvLi4uXHJcbiAgICAgIC8vIEluc3RlYWQgYXBwZW5kIG9yIHByZXBlbmQgdG8gdGhlIGNvbXBvbmVudHMgYXJyYXkuXHJcbiAgICAgIGlmICgkc2NvcGUuY29tcG9uZW50LmRpc3BsYXkgPT09ICd3aXphcmQnKSB7XHJcbiAgICAgICAgJHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHZhciBwYWdlSW5kZXggPSAoaW5kZXggPT09IDApID8gMCA6ICRzY29wZS5mb3JtLmNvbXBvbmVudHNbJHNjb3BlLmZvcm0ucGFnZV0uY29tcG9uZW50cy5sZW5ndGg7XHJcbiAgICAgICAgICAkc2NvcGUuZm9ybS5jb21wb25lbnRzWyRzY29wZS5mb3JtLnBhZ2VdLmNvbXBvbmVudHMuc3BsaWNlKHBhZ2VJbmRleCwgMCwgY29tcG9uZW50KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhleSBkb24ndCBldmVyIGFkZCBhIGNvbXBvbmVudCBvbiB0aGUgYm90dG9tIG9mIHRoZSBzdWJtaXQgYnV0dG9uLlxyXG4gICAgICB2YXIgbGFzdENvbXBvbmVudCA9ICRzY29wZS5jb21wb25lbnQuY29tcG9uZW50c1skc2NvcGUuY29tcG9uZW50LmNvbXBvbmVudHMubGVuZ3RoIC0gMV07XHJcbiAgICAgIGlmIChcclxuICAgICAgICAobGFzdENvbXBvbmVudCkgJiZcclxuICAgICAgICAobGFzdENvbXBvbmVudC50eXBlID09PSAnYnV0dG9uJykgJiZcclxuICAgICAgICAobGFzdENvbXBvbmVudC5hY3Rpb24gPT09ICdzdWJtaXQnKVxyXG4gICAgICApIHtcclxuICAgICAgICAvLyBUaGVyZSBpcyBvbmx5IG9uZSBlbGVtZW50IG9uIHRoZSBwYWdlLlxyXG4gICAgICAgIGlmICgkc2NvcGUuY29tcG9uZW50LmNvbXBvbmVudHMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICBpbmRleCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGluZGV4ID49ICRzY29wZS5jb21wb25lbnQuY29tcG9uZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgIGluZGV4IC09IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBZGQgdGhlIGNvbXBvbmVudCB0byB0aGUgY29tcG9uZW50cyBhcnJheS5cclxuICAgICAgJHNjb3BlLmNvbXBvbmVudC5jb21wb25lbnRzLnNwbGljZShpbmRleCwgMCwgY29tcG9uZW50KTtcclxuICAgICAgJHRpbWVvdXQoJHNjb3BlLiRhcHBseS5iaW5kKCRzY29wZSkpO1xyXG5cclxuICAgICAgLy8gUmV0dXJuIHRydWUgc2luY2UgdGhpcyB3aWxsIHRlbGwgdGhlIGRyYWctYW5kLWRyb3AgbGlzdCBjb21wb25lbnQgdG8gbm90IGluc2VydCBpbnRvIGl0cyBvd24gYXJyYXkuXHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBBbGxvdyBwcm90b3R5cGVkIHNjb3BlcyB0byB1cGRhdGUgdGhlIG9yaWdpbmFsIGNvbXBvbmVudC5cclxuICAgICRzY29wZS51cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbihuZXdDb21wb25lbnQsIGtleSkge1xyXG4gICAgICB2YXIgbGlzdCA9ICRzY29wZS5jb21wb25lbnQuY29tcG9uZW50cztcclxuICAgICAgaWYgKF8uZmluZEluZGV4KGxpc3QsIHtrZXk6IGtleX0pICE9PSAtMSkge1xyXG4gICAgICAgIGxpc3Quc3BsaWNlKF8uZmluZEluZGV4KGxpc3QsIHtrZXk6IGtleX0pLCAxLCBuZXdDb21wb25lbnQpO1xyXG4gICAgICAgICRzY29wZS5lbWl0KCd1cGRhdGUnLCBuZXdDb21wb25lbnQpO1xyXG4gICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdpZnJhbWVNZXNzYWdlJywge25hbWU6ICd1cGRhdGVFbGVtZW50JywgZGF0YTogbmV3Q29tcG9uZW50fSk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgLy9jb25zb2xlLndhcm4oJ25vdCBmb3VuZCcsIGtleSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIHJlbW92ZSA9IGZ1bmN0aW9uKGNvbXBvbmVudCkge1xyXG4gICAgICBpZiAoJHNjb3BlLmNvbXBvbmVudC5jb21wb25lbnRzLmluZGV4T2YoY29tcG9uZW50KSAhPT0gLTEpIHtcclxuICAgICAgICAkc2NvcGUuY29tcG9uZW50LmNvbXBvbmVudHMuc3BsaWNlKCRzY29wZS5jb21wb25lbnQuY29tcG9uZW50cy5pbmRleE9mKGNvbXBvbmVudCksIDEpO1xyXG4gICAgICAgICRzY29wZS5lbWl0KCdyZW1vdmUnLCBjb21wb25lbnQpO1xyXG4gICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdpZnJhbWVNZXNzYWdlJywge25hbWU6ICdyZW1vdmVFbGVtZW50JywgZGF0YTogY29tcG9uZW50fSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgJHNjb3BlLnNhdmVDb21wb25lbnQgPSBmdW5jdGlvbihjb21wb25lbnQpIHtcclxuICAgICAgJHNjb3BlLmVtaXQoJ3VwZGF0ZScsIGNvbXBvbmVudCk7XHJcbiAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdpZnJhbWVNZXNzYWdlJywge25hbWU6ICd1cGRhdGVFbGVtZW50JywgZGF0YTogY29tcG9uZW50fSk7XHJcbiAgICAgIG5nRGlhbG9nLmNsb3NlQWxsKHRydWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAkc2NvcGUucmVtb3ZlQ29tcG9uZW50ID0gZnVuY3Rpb24oY29tcG9uZW50LCBzaG91bGRDb25maXJtKSB7XHJcbiAgICAgIGlmIChzaG91bGRDb25maXJtKSB7XHJcbiAgICAgICAgLy8gU2hvdyBjb25maXJtIGRpYWxvZyBiZWZvcmUgcmVtb3ZpbmcgYSBjb21wb25lbnRcclxuICAgICAgICBuZ0RpYWxvZy5vcGVuKHtcclxuICAgICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY29uZmlybS1yZW1vdmUuaHRtbCcsXHJcbiAgICAgICAgICBzaG93Q2xvc2U6IGZhbHNlXHJcbiAgICAgICAgfSkuY2xvc2VQcm9taXNlLnRoZW4oZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgdmFyIGNhbmNlbGxlZCA9IGUudmFsdWUgPT09IGZhbHNlIHx8IGUudmFsdWUgPT09ICckY2xvc2VCdXR0b24nIHx8IGUudmFsdWUgPT09ICckZG9jdW1lbnQnIHx8IGUudmFsdWUgPT09ICckZXNjYXBlJztcclxuICAgICAgICAgIGlmICghY2FuY2VsbGVkKSB7XHJcbiAgICAgICAgICAgIHJlbW92ZShjb21wb25lbnQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHJlbW92ZShjb21wb25lbnQpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEVkaXQgYSBzcGVjaWZpYyBjb21wb25lbnQuXHJcbiAgICAkc2NvcGUuZWRpdENvbXBvbmVudCA9IGZ1bmN0aW9uKGNvbXBvbmVudCkge1xyXG4gICAgICAkc2NvcGUuZm9ybUNvbXBvbmVudCA9IGZvcm1pb0NvbXBvbmVudHMuY29tcG9uZW50c1tjb21wb25lbnQudHlwZV0gfHwgZm9ybWlvQ29tcG9uZW50cy5jb21wb25lbnRzLmN1c3RvbTtcclxuICAgICAgLy8gTm8gZWRpdCB2aWV3IGF2YWlsYWJsZVxyXG4gICAgICBpZiAoISRzY29wZS5mb3JtQ29tcG9uZW50Lmhhc093blByb3BlcnR5KCd2aWV3cycpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDcmVhdGUgY2hpbGQgaXNvbGF0ZSBzY29wZSBmb3IgZGlhbG9nXHJcbiAgICAgIHZhciBjaGlsZFNjb3BlID0gJHNjb3BlLiRuZXcoZmFsc2UpO1xyXG4gICAgICBjaGlsZFNjb3BlLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcclxuICAgICAgY2hpbGRTY29wZS5kYXRhID0ge307XHJcbiAgICAgIGlmIChjb21wb25lbnQua2V5KSB7XHJcbiAgICAgICAgY2hpbGRTY29wZS5kYXRhW2NvbXBvbmVudC5rZXldID0gY29tcG9uZW50Lm11bHRpcGxlID8gWycnXSA6ICcnO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgcHJldmlvdXNTZXR0aW5ncyA9IGFuZ3VsYXIuY29weShjb21wb25lbnQpO1xyXG5cclxuICAgICAgLy8gT3BlbiB0aGUgZGlhbG9nLlxyXG4gICAgICBuZ0RpYWxvZy5vcGVuKHtcclxuICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL3NldHRpbmdzLmh0bWwnLFxyXG4gICAgICAgIHNjb3BlOiBjaGlsZFNjb3BlLFxyXG4gICAgICAgIGNsYXNzTmFtZTogJ25nZGlhbG9nLXRoZW1lLWRlZmF1bHQgY29tcG9uZW50LXNldHRpbmdzJyxcclxuICAgICAgICBjb250cm9sbGVyOiBbJyRzY29wZScsICdGb3JtaW8nLCAnJGNvbnRyb2xsZXInLCBmdW5jdGlvbigkc2NvcGUsIEZvcm1pbywgJGNvbnRyb2xsZXIpIHtcclxuICAgICAgICAgICRzY29wZS5lZGl0b3JWaXNpYmxlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAvLyBBbGxvdyB0aGUgY29tcG9uZW50IHRvIGFkZCBjdXN0b20gbG9naWMgdG8gdGhlIGVkaXQgcGFnZS5cclxuICAgICAgICAgIGlmICgkc2NvcGUuZm9ybUNvbXBvbmVudCAmJiAkc2NvcGUuZm9ybUNvbXBvbmVudC5vbkVkaXQpIHtcclxuICAgICAgICAgICAgJGNvbnRyb2xsZXIoJHNjb3BlLmZvcm1Db21wb25lbnQub25FZGl0LCB7JHNjb3BlOiAkc2NvcGV9KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAkc2NvcGUuJHdhdGNoKCdjb21wb25lbnQubXVsdGlwbGUnLCBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICAkc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV0gPSB2YWx1ZSA/IFsnJ10gOiAnJztcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIHZhciBlZGl0b3JEZWJvdW5jZSA9IG51bGw7XHJcbiAgICAgICAgICAkc2NvcGUuJHdhdGNoQ29sbGVjdGlvbignY29tcG9uZW50Lnd5c2l3eWcnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgJHNjb3BlLmVkaXRvclZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKGVkaXRvckRlYm91bmNlKSB7XHJcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGVkaXRvckRlYm91bmNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlZGl0b3JEZWJvdW5jZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgJHNjb3BlLmVkaXRvclZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9LCAyMDApO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgLy8gV2F0Y2ggdGhlIHNldHRpbmdzIGxhYmVsIGFuZCBhdXRvIHNldCB0aGUga2V5IGZyb20gaXQuXHJcbiAgICAgICAgICB2YXIgaW52YWxpZFJlZ2V4ID0gL15bXkEtWmEtel0qfFteQS1aYS16MC05XFwtXSovZztcclxuICAgICAgICAgICRzY29wZS4kd2F0Y2goJ2NvbXBvbmVudC5sYWJlbCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoJHNjb3BlLmNvbXBvbmVudC5sYWJlbCAmJiAhJHNjb3BlLmNvbXBvbmVudC5sb2NrS2V5ICYmICRzY29wZS5jb21wb25lbnQuaXNOZXcpIHtcclxuICAgICAgICAgICAgICBpZiAoJHNjb3BlLmRhdGEuaGFzT3duUHJvcGVydHkoJHNjb3BlLmNvbXBvbmVudC5rZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAkc2NvcGUuY29tcG9uZW50LmtleSA9IF9jYW1lbENhc2UoJHNjb3BlLmNvbXBvbmVudC5sYWJlbC5yZXBsYWNlKGludmFsaWRSZWdleCwgJycpKTtcclxuICAgICAgICAgICAgICBCdWlsZGVyVXRpbHMudW5pcXVpZnkoJHNjb3BlLmZvcm0sICRzY29wZS5jb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSA9ICRzY29wZS5jb21wb25lbnQubXVsdGlwbGUgPyBbJyddIDogJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1dXHJcbiAgICAgIH0pLmNsb3NlUHJvbWlzZS50aGVuKGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICB2YXIgY2FuY2VsbGVkID0gZS52YWx1ZSA9PT0gZmFsc2UgfHwgZS52YWx1ZSA9PT0gJyRjbG9zZUJ1dHRvbicgfHwgZS52YWx1ZSA9PT0gJyRkb2N1bWVudCcgfHwgZS52YWx1ZSA9PT0gJyRlc2NhcGUnO1xyXG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHtcclxuICAgICAgICAgIGlmIChjb21wb25lbnQuaXNOZXcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZShjb21wb25lbnQpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJldmVydCB0byBvbGQgc2V0dGluZ3MsIGJ1dCB1c2UgdGhlIHNhbWUgb2JqZWN0IHJlZmVyZW5jZVxyXG4gICAgICAgICAgX2Fzc2lnbihjb21wb25lbnQsIHByZXZpb3VzU2V0dGluZ3MpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgRm9ybWlvVXRpbHMuZWFjaENvbXBvbmVudChbY29tcG9uZW50XSwgZnVuY3Rpb24oY2hpbGQpIHtcclxuICAgICAgICAgIGRlbGV0ZSBjaGlsZC5pc05ldztcclxuICAgICAgICB9LCB0cnVlKTtcclxuICAgICAgICAkc2NvcGUuJGJyb2FkY2FzdCgnaWZyYW1lTWVzc2FnZScsIHtuYW1lOiAndXBkYXRlRWxlbWVudCcsIGRhdGE6IGNvbXBvbmVudH0pO1xyXG4gICAgICAgICRzY29wZS5lbWl0KCdlZGl0JywgY29tcG9uZW50KTtcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIENsb25lIGZvcm0gY29tcG9uZW50XHJcbiAgICAkc2NvcGUuY2xvbmVDb21wb25lbnQgPSBmdW5jdGlvbihjb21wb25lbnQpIHtcclxuICAgICAgJHNjb3BlLmZvcm1FbGVtZW50ID0gYW5ndWxhci5jb3B5KGNvbXBvbmVudCk7XHJcbiAgICAgICRzY29wZS5mb3JtRWxlbWVudC5rZXkgPSBjb21wb25lbnQua2V5ICsgJycgKyAkc2NvcGUuZm9ybS5jb21wb25lbnRzLmxlbmd0aDtcclxuICAgICAgJHNjb3BlLmZvcm0uY29tcG9uZW50cy5wdXNoKCRzY29wZS5mb3JtRWxlbWVudCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEFkZCB0byBzY29wZSBzbyBpdCBjYW4gYmUgdXNlZCBpbiB0ZW1wbGF0ZXNcclxuICAgICRzY29wZS5kbmREcmFnSWZyYW1lV29ya2Fyb3VuZCA9IGRuZERyYWdJZnJhbWVXb3JrYXJvdW5kO1xyXG4gIH1cclxuXTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFtcclxuICAnZm9ybWlvRWxlbWVudERpcmVjdGl2ZScsXHJcbiAgZnVuY3Rpb24oZm9ybWlvRWxlbWVudERpcmVjdGl2ZSkge1xyXG4gICAgcmV0dXJuIGFuZ3VsYXIuZXh0ZW5kKHt9LCBmb3JtaW9FbGVtZW50RGlyZWN0aXZlWzBdLCB7XHJcbiAgICAgIHNjb3BlOiBmYWxzZSxcclxuICAgICAgY29udHJvbGxlcjogW1xyXG4gICAgICAgICckc2NvcGUnLFxyXG4gICAgICAgICdmb3JtaW9Db21wb25lbnRzJyxcclxuICAgICAgICBmdW5jdGlvbihcclxuICAgICAgICAgICRzY29wZSxcclxuICAgICAgICAgIGZvcm1pb0NvbXBvbmVudHNcclxuICAgICAgICApIHtcclxuICAgICAgICAgICRzY29wZS5idWlsZGVyID0gdHJ1ZTtcclxuICAgICAgICAgICRzY29wZS5mb3JtQ29tcG9uZW50ID0gZm9ybWlvQ29tcG9uZW50cy5jb21wb25lbnRzWyRzY29wZS5jb21wb25lbnQudHlwZV0gfHwgZm9ybWlvQ29tcG9uZW50cy5jb21wb25lbnRzLmN1c3RvbTtcclxuICAgICAgICAgIGlmICgkc2NvcGUuZm9ybUNvbXBvbmVudC5mYnRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgICRzY29wZS50ZW1wbGF0ZSA9ICRzY29wZS5mb3JtQ29tcG9uZW50LmZidGVtcGxhdGU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICBdXHJcbiAgICB9KTtcclxuICB9XHJcbl07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBbXHJcbiAgZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzY29wZToge1xyXG4gICAgICAgIGNvbXBvbmVudDogJz0nLFxyXG4gICAgICAgIGZvcm1pbzogJz0nLFxyXG4gICAgICAgIGZvcm06ICc9JyxcclxuICAgICAgICAvLyAjIG9mIGl0ZW1zIG5lZWRlZCBpbiB0aGUgbGlzdCBiZWZvcmUgaGlkaW5nIHRoZVxyXG4gICAgICAgIC8vIGRyYWcgYW5kIGRyb3AgcHJvbXB0IGRpdlxyXG4gICAgICAgIGhpZGVEbmRCb3hDb3VudDogJz0nLFxyXG4gICAgICAgIHJvb3RMaXN0OiAnPScsXHJcbiAgICAgICAgb3B0aW9uczogJz0nXHJcbiAgICAgIH0sXHJcbiAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgIHJlcGxhY2U6IHRydWUsXHJcbiAgICAgIGNvbnRyb2xsZXI6ICdmb3JtQnVpbGRlckRuZCcsXHJcbiAgICAgIHRlbXBsYXRlVXJsOiAnZm9ybWlvL2Zvcm1idWlsZGVyL2xpc3QuaHRtbCdcclxuICAgIH07XHJcbiAgfVxyXG5dO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxyXG4qIFRoaXMgZGlyZWN0aXZlIGNyZWF0ZXMgYSBmaWVsZCBmb3IgdHdlYWtpbmcgY29tcG9uZW50IG9wdGlvbnMuXHJcbiogVGhpcyBuZWVkcyBhdCBsZWFzdCBhIHByb3BlcnR5IGF0dHJpYnV0ZSBzcGVjaWZ5aW5nIHdoYXQgcHJvcGVydHlcclxuKiBvZiB0aGUgY29tcG9uZW50IHRvIGJpbmQgdG8uXHJcbipcclxuKiBJZiB0aGUgcHJvcGVydHkgaXMgZGVmaW5lZCBpbiBDT01NT05fT1BUSU9OUyBhYm92ZSwgaXQgd2lsbCBhdXRvbWF0aWNhbGx5XHJcbiogcG9wdWxhdGUgaXRzIGxhYmVsLCBwbGFjZWhvbGRlciwgaW5wdXQgdHlwZSwgYW5kIHRvb2x0aXAuIElmIG5vdCwgeW91IG1heSBzcGVjaWZ5XHJcbiogdGhvc2UgdmlhIGF0dHJpYnV0ZXMgKGV4Y2VwdCBmb3IgdG9vbHRpcCwgd2hpY2ggeW91IGNhbiBzcGVjaWZ5IHdpdGggdGhlIHRpdGxlIGF0dHJpYnV0ZSkuXHJcbiogVGhlIGdlbmVyYXRlZCBpbnB1dCB3aWxsIGFsc28gY2Fycnkgb3ZlciBhbnkgb3RoZXIgcHJvcGVydGllcyB5b3Ugc3BlY2lmeSBvbiB0aGlzIGRpcmVjdGl2ZS5cclxuKi9cclxubW9kdWxlLmV4cG9ydHMgPSBbJ0NPTU1PTl9PUFRJT05TJywgJyRmaWx0ZXInLCBmdW5jdGlvbihDT01NT05fT1BUSU9OUywgJGZpbHRlcikge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgcmVxdWlyZTogJ3Byb3BlcnR5JyxcclxuICAgIHByaW9yaXR5OiAyLFxyXG4gICAgcmVwbGFjZTogdHJ1ZSxcclxuICAgIHRlbXBsYXRlOiBmdW5jdGlvbihlbCwgYXR0cnMpIHtcclxuICAgICAgdmFyIGZvcm1pb1RyYW5zbGF0ZSA9ICRmaWx0ZXIoJ2Zvcm1pb1RyYW5zbGF0ZScpO1xyXG5cclxuICAgICAgdmFyIHByb3BlcnR5ID0gYXR0cnMucHJvcGVydHk7XHJcbiAgICAgIHZhciBsYWJlbCA9IGF0dHJzLmxhYmVsIHx8IChDT01NT05fT1BUSU9OU1twcm9wZXJ0eV0gJiYgQ09NTU9OX09QVElPTlNbcHJvcGVydHldLmxhYmVsKSB8fCAnJztcclxuICAgICAgdmFyIHBsYWNlaG9sZGVyID0gKENPTU1PTl9PUFRJT05TW3Byb3BlcnR5XSAmJiBDT01NT05fT1BUSU9OU1twcm9wZXJ0eV0ucGxhY2Vob2xkZXIpIHx8IG51bGw7XHJcbiAgICAgIHZhciB0eXBlID0gYXR0cnMudHlwZSB8fCAoQ09NTU9OX09QVElPTlNbcHJvcGVydHldICYmIENPTU1PTl9PUFRJT05TW3Byb3BlcnR5XS50eXBlKSB8fCAndGV4dCc7XHJcbiAgICAgIHZhciB0b29sdGlwID0gKENPTU1PTl9PUFRJT05TW3Byb3BlcnR5XSAmJiBDT01NT05fT1BUSU9OU1twcm9wZXJ0eV0udG9vbHRpcCkgfHwgJyc7XHJcblxyXG4gICAgICB2YXIgaW5wdXQgPSB0eXBlID09PSAndGV4dGFyZWEnID8gYW5ndWxhci5lbGVtZW50KCc8dGV4dGFyZWE+PC90ZXh0YXJlYT4nKSA6IGFuZ3VsYXIuZWxlbWVudCgnPGlucHV0PicpO1xyXG4gICAgICB2YXIgaW5wdXRBdHRycyA9IHtcclxuICAgICAgICBpZDogcHJvcGVydHksXHJcbiAgICAgICAgbmFtZTogcHJvcGVydHksXHJcbiAgICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgICAnbmctbW9kZWwnOiAnY29tcG9uZW50LicgKyBwcm9wZXJ0eSxcclxuICAgICAgICBwbGFjZWhvbGRlcjogZm9ybWlvVHJhbnNsYXRlKHBsYWNlaG9sZGVyKVxyXG4gICAgICB9O1xyXG4gICAgICAvLyBQYXNzIHRocm91Z2ggYXR0cmlidXRlcyBmcm9tIHRoZSBkaXJlY3RpdmUgdG8gdGhlIGlucHV0IGVsZW1lbnRcclxuICAgICAgYW5ndWxhci5mb3JFYWNoKGF0dHJzLiRhdHRyLCBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICBpbnB1dEF0dHJzW2tleV0gPSBhdHRyc1thdHRycy4kbm9ybWFsaXplKGtleSldO1xyXG4gICAgICAgIC8vIEFsbG93IHNwZWNpZnlpbmcgdG9vbHRpcCB2aWEgdGl0bGUgYXR0clxyXG4gICAgICAgIGlmIChrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ3RpdGxlJykge1xyXG4gICAgICAgICAgdG9vbHRpcCA9IGF0dHJzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIEFkZCBtaW4vbWF4IHZhbHVlIGZsb29yIHZhbHVlcyBmb3IgdmFsaWRhdGlvbi5cclxuICAgICAgaWYgKHByb3BlcnR5ID09PSAndmFsaWRhdGUubWluTGVuZ3RoJyB8fCBwcm9wZXJ0eSA9PT0gJ3ZhbGlkYXRlLm1heExlbmd0aCcpIHtcclxuICAgICAgICBpbnB1dEF0dHJzLm1pbiA9IDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlucHV0LmF0dHIoaW5wdXRBdHRycyk7XHJcblxyXG4gICAgICAvLyBDaGVja2JveGVzIGhhdmUgYSBzbGlnaHRseSBkaWZmZXJlbnQgbGF5b3V0XHJcbiAgICAgIGlmIChpbnB1dEF0dHJzLnR5cGUgJiYgaW5wdXRBdHRycy50eXBlLnRvTG93ZXJDYXNlKCkgPT09ICdjaGVja2JveCcpIHtcclxuICAgICAgICByZXR1cm4gJzxkaXYgY2xhc3M9XCJjaGVja2JveFwiPicgK1xyXG4gICAgICAgICAgICAgICAgJzxsYWJlbCBmb3I9XCInICsgcHJvcGVydHkgKyAnXCIgZm9ybS1idWlsZGVyLXRvb2x0aXA9XCInICsgZm9ybWlvVHJhbnNsYXRlKHRvb2x0aXApICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAgICAgaW5wdXQucHJvcCgnb3V0ZXJIVE1MJykgK1xyXG4gICAgICAgICAgICAgICAgJyAnICsgZm9ybWlvVHJhbnNsYXRlKGxhYmVsKSArICc8L2xhYmVsPicgK1xyXG4gICAgICAgICAgICAgICc8L2Rpdj4nO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpbnB1dC5hZGRDbGFzcygnZm9ybS1jb250cm9sJyk7XHJcbiAgICAgIHJldHVybiAnPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj4nICtcclxuICAgICAgICAgICAgICAgICc8bGFiZWwgZm9yPVwiJyArIHByb3BlcnR5ICsgJ1wiIGZvcm0tYnVpbGRlci10b29sdGlwPVwiJyArIGZvcm1pb1RyYW5zbGF0ZSh0b29sdGlwKSArICdcIj4nICsgZm9ybWlvVHJhbnNsYXRlKGxhYmVsKSArICc8L2xhYmVsPicgK1xyXG4gICAgICAgICAgICAgICAgaW5wdXQucHJvcCgnb3V0ZXJIVE1MJykgK1xyXG4gICAgICAgICAgICAgICc8L2Rpdj4nO1xyXG4gICAgfVxyXG4gIH07XHJcbn1dO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxyXG4qIEEgZGlyZWN0aXZlIGZvciBlZGl0aW5nIGEgY29tcG9uZW50J3MgY3VzdG9tIHZhbGlkYXRpb24uXHJcbiovXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICByZXBsYWNlOiB0cnVlLFxyXG4gICAgdGVtcGxhdGU6ICcnICtcclxuICAgICAgJzxkaXY+JyArXHJcbiAgICAgICc8dWliLWFjY29yZGlvbj4nICtcclxuICAgICAgJyAgPGRpdiB1aWItYWNjb3JkaW9uLWdyb3VwIGhlYWRpbmc9XCJDdXN0b20gVmFsaWRhdGlvblwiIGNsYXNzPVwicGFuZWwgcGFuZWwtZGVmYXVsdFwiPicgK1xyXG4gICAgICAnICAgIDx0ZXh0YXJlYSBjbGFzcz1cImZvcm0tY29udHJvbFwiIHJvd3M9XCI1XCIgaWQ9XCJjdXN0b21cIiBuYW1lPVwiY3VzdG9tXCIgbmctbW9kZWw9XCJjb21wb25lbnQudmFsaWRhdGUuY3VzdG9tXCIgcGxhY2Vob2xkZXI9XCIvKioqIEV4YW1wbGUgQ29kZSAqKiovXFxudmFsaWQgPSAoaW5wdXQgPT09IDMpID8gdHJ1ZSA6IFxcJ011c3QgYmUgM1xcJztcIj57eyBjb21wb25lbnQudmFsaWRhdGUuY3VzdG9tIH19PC90ZXh0YXJlYT4nICtcclxuICAgICAgJyAgICA8c21hbGw+JyArXHJcbiAgICAgICcgICAgICA8cD5FbnRlciBjdXN0b20gdmFsaWRhdGlvbiBjb2RlLjwvcD4nICtcclxuICAgICAgJyAgICAgIDxwPllvdSBtdXN0IGFzc2lnbiB0aGUgPHN0cm9uZz52YWxpZDwvc3Ryb25nPiB2YXJpYWJsZSBhcyBlaXRoZXIgPHN0cm9uZz50cnVlPC9zdHJvbmc+IG9yIGFuIGVycm9yIG1lc3NhZ2UgaWYgdmFsaWRhdGlvbiBmYWlscy48L3A+JyArXHJcbiAgICAgICcgICAgICA8cD5UaGUgZ2xvYmFsIHZhcmlhYmxlcyA8c3Ryb25nPmlucHV0PC9zdHJvbmc+LCA8c3Ryb25nPmNvbXBvbmVudDwvc3Ryb25nPiwgYW5kIDxzdHJvbmc+dmFsaWQ8L3N0cm9uZz4gYXJlIHByb3ZpZGVkLjwvcD4nICtcclxuICAgICAgJyAgICA8L3NtYWxsPicgK1xyXG4gICAgICAnICAgIDxkaXYgY2xhc3M9XCJ3ZWxsXCI+JyArXHJcbiAgICAgICcgICAgICA8ZGl2IGNsYXNzPVwiY2hlY2tib3hcIj4nICtcclxuICAgICAgJyAgICAgICAgPGxhYmVsPicgK1xyXG4gICAgICAnICAgICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBpZD1cInByaXZhdGVcIiBuYW1lPVwicHJpdmF0ZVwiIG5nLW1vZGVsPVwiY29tcG9uZW50LnZhbGlkYXRlLmN1c3RvbVByaXZhdGVcIiBuZy1jaGVja2VkPVwiY29tcG9uZW50LnZhbGlkYXRlLmN1c3RvbVByaXZhdGVcIj4gPHN0cm9uZz5TZWNyZXQgVmFsaWRhdGlvbjwvc3Ryb25nPicgK1xyXG4gICAgICAnICAgICAgICA8L2xhYmVsPicgK1xyXG4gICAgICAnICAgICAgPC9kaXY+JyArXHJcbiAgICAgICcgICAgICA8cD5DaGVjayB0aGlzIGlmIHlvdSB3aXNoIHRvIHBlcmZvcm0gdGhlIHZhbGlkYXRpb24gT05MWSBvbiB0aGUgc2VydmVyIHNpZGUuIFRoaXMga2VlcHMgeW91ciB2YWxpZGF0aW9uIGxvZ2ljIHByaXZhdGUgYW5kIHNlY3JldC48L3A+JyArXHJcbiAgICAgICcgICAgPC9kaXY+JyArXHJcbiAgICAgICcgIDwvZGl2PicgK1xyXG4gICAgICAnICA8ZGl2IHVpYi1hY2NvcmRpb24tZ3JvdXAgaGVhZGluZz1cIkpTT04gVmFsaWRhdGlvblwiIGNsYXNzPVwicGFuZWwgcGFuZWwtZGVmYXVsdFwiPicgK1xyXG4gICAgICAnICAgIDxzbWFsbD4nICtcclxuICAgICAgJyAgICAgIDxwPkV4ZWN1dGUgY3VzdG9tIHZhbGlkYXRpb24gbG9naWMgd2l0aCBKU09OIGFuZCA8YSBocmVmPVwiaHR0cDovL2pzb25sb2dpYy5jb20vXCI+SnNvbkxvZ2ljPC9hPi48L3A+JyArXHJcbiAgICAgICcgICAgICA8cD5TdWJtaXNzaW9uIGRhdGEgaXMgYXZhaWxhYmxlIGFzIEpzb25Mb2dpYyB2YXJpYWJsZXMsIHdpdGggdGhlIHNhbWUgYXBpIGtleSBhcyB5b3VyIGNvbXBvbmVudHMuPC9wPicgK1xyXG4gICAgICAnICAgICAgPHA+PGEgaHJlZj1cImh0dHA6Ly9mb3JtaW8uZ2l0aHViLmlvL2Zvcm1pby5qcy9hcHAvZXhhbXBsZXMvY29uZGl0aW9ucy5odG1sXCIgdGFyZ2V0PVwiX2JsYW5rXCI+Q2xpY2sgaGVyZSBmb3IgYW4gZXhhbXBsZTwvYT48L3A+JyArXHJcbiAgICAgICcgICAgPC9zbWFsbD4nICtcclxuICAgICAgJyAgICA8dGV4dGFyZWEgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiByb3dzPVwiNVwiIGlkPVwianNvblwiIG5hbWU9XCJqc29uXCIganNvbi1pbnB1dCBuZy1tb2RlbD1cImNvbXBvbmVudC52YWxpZGF0ZS5qc29uXCIgcGxhY2Vob2xkZXI9XFwneyAuLi4gfVxcJz48L3RleHRhcmVhPicgK1xyXG4gICAgICAnICA8L2Rpdj4nICtcclxuICAgICAgJzwvdWliLWFjY29yZGlvbj4nICtcclxuICAgICAgJzwvZGl2PidcclxuICB9O1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxyXG4qIEEgZGlyZWN0aXZlIGZvciBhIGZpZWxkIHRvIGVkaXQgYSBjb21wb25lbnQncyBrZXkuXHJcbiovXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICByZXBsYWNlOiB0cnVlLFxyXG4gICAgdGVtcGxhdGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gJzxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCIgbmctY2xhc3M9XCJ7XFwnaGFzLXdhcm5pbmdcXCc6IHNob3VsZFdhcm5BYm91dEVtYmVkZGluZygpfVwiPicgK1xyXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJhbGVydCBhbGVydC13YXJuaW5nXCIgcm9sZT1cImFsZXJ0XCIgbmctaWY9XCIhY29tcG9uZW50LmlzTmV3XCI+JyArXHJcbiAgICAgICAgICAgICAgICAnQ2hhbmdpbmcgdGhlIEFQSSBrZXkgd2lsbCBjYXVzZSB5b3UgdG8gbG9zZSBleGlzdGluZyBzdWJtaXNzaW9uIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29tcG9uZW50LicgK1xyXG4gICAgICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgJzxsYWJlbCBmb3I9XCJrZXlcIiBjbGFzcz1cImNvbnRyb2wtbGFiZWxcIiBmb3JtLWJ1aWxkZXItdG9vbHRpcD1cIlRoZSBuYW1lIG9mIHRoaXMgZmllbGQgaW4gdGhlIEFQSSBlbmRwb2ludC5cIj5Qcm9wZXJ0eSBOYW1lPC9sYWJlbD4nICtcclxuICAgICAgICAgICAgICAgICc8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwia2V5XCIgbmFtZT1cImtleVwiIG5nLW1vZGVsPVwiY29tcG9uZW50LmtleVwiIHZhbGlkLWFwaS1rZXkgdmFsdWU9XCJ7eyBjb21wb25lbnQua2V5IH19XCIgJyArXHJcbiAgICAgICAgICAgICAgICAnbmctZGlzYWJsZWQ9XCJjb21wb25lbnQuc291cmNlXCIgbmctYmx1cj1cIm9uQmx1cigpXCI+JyArXHJcbiAgICAgICAgICAgICAgICAnPHAgbmctaWY9XCJzaG91bGRXYXJuQWJvdXRFbWJlZGRpbmcoKVwiIGNsYXNzPVwiaGVscC1ibG9ja1wiPjxzcGFuIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1leGNsYW1hdGlvbi1zaWduXCI+PC9zcGFuPiAnICtcclxuICAgICAgICAgICAgICAgICAgJ1VzaW5nIGEgZG90IGluIHlvdXIgUHJvcGVydHkgTmFtZSB3aWxsIGxpbmsgdGhpcyBmaWVsZCB0byBhIGZpZWxkIGZyb20gYSBSZXNvdXJjZS4gRG9pbmcgdGhpcyBtYW51YWxseSBpcyBub3QgcmVjb21tZW5kZWQgYmVjYXVzZSB5b3Ugd2lsbCBleHBlcmllbmNlIHVuZXhwZWN0ZWQgYmVoYXZpb3IgaWYgdGhlIFJlc291cmNlIGZpZWxkIGlzIG5vdCBmb3VuZC4gSWYgeW91IHdpc2ggdG8gZW1iZWQgYSBSZXNvdXJjZSBmaWVsZCBpbiB5b3VyIGZvcm0sIHVzZSBhIGNvbXBvbmVudCBmcm9tIHRoZSBjb3JyZXNwb25kaW5nIFJlc291cmNlIENvbXBvbmVudHMgY2F0ZWdvcnkgb24gdGhlIGxlZnQuJyArXHJcbiAgICAgICAgICAgICAgICAnPC9wPicgK1xyXG4gICAgICAgICAgICAgICc8L2Rpdj4nO1xyXG4gICAgfSxcclxuICAgIGNvbnRyb2xsZXI6IFsnJHNjb3BlJywgJ0J1aWxkZXJVdGlscycsIGZ1bmN0aW9uKCRzY29wZSwgQnVpbGRlclV0aWxzKSB7XHJcbiAgICAgIEJ1aWxkZXJVdGlscy51bmlxdWlmeSgkc2NvcGUuZm9ybSwgJHNjb3BlLmNvbXBvbmVudCk7XHJcblxyXG4gICAgICAkc2NvcGUub25CbHVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgJHNjb3BlLmNvbXBvbmVudC5sb2NrS2V5ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gSWYgdGhleSB0cnkgdG8gaW5wdXQgYW4gZW1wdHkga2V5LCByZWZpbGwgaXQgd2l0aCBkZWZhdWx0IGFuZCBsZXQgdW5pcXVpZnkgbWFrZSBpdCB1bmlxdWUuXHJcbiAgICAgICAgaWYgKCEkc2NvcGUuY29tcG9uZW50LmtleSAmJiAkc2NvcGUuZm9ybUNvbXBvbmVudHNbJHNjb3BlLmNvbXBvbmVudC50eXBlXS5zZXR0aW5ncy5rZXkpIHtcclxuICAgICAgICAgICRzY29wZS5jb21wb25lbnQua2V5ID0gJHNjb3BlLmZvcm1Db21wb25lbnRzWyRzY29wZS5jb21wb25lbnQudHlwZV0uc2V0dGluZ3Mua2V5O1xyXG4gICAgICAgICAgJHNjb3BlLmNvbXBvbmVudC5sb2NrS2V5ID0gZmFsc2U7IC8vIEFsc28gdW5sb2NrIGtleVxyXG4gICAgICAgICAgQnVpbGRlclV0aWxzLnVuaXF1aWZ5KCRzY29wZS5mb3JtLCAkc2NvcGUuY29tcG9uZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAkc2NvcGUuc2hvdWxkV2FybkFib3V0RW1iZWRkaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCEkc2NvcGUuY29tcG9uZW50IHx8ICEkc2NvcGUuY29tcG9uZW50LmtleSkge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gISRzY29wZS5jb21wb25lbnQuc291cmNlICYmICRzY29wZS5jb21wb25lbnQua2V5LmluZGV4T2YoJy4nKSAhPT0gLTE7XHJcbiAgICAgIH07XHJcbiAgICB9XVxyXG4gIH07XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXHJcbiogQSBkaXJlY3RpdmUgZm9yIGEgZmllbGQgdG8gZWRpdCBhIGNvbXBvbmVudCdzIHRhZ3MuXHJcbiovXHJcbnZhciBfbWFwID0gcmVxdWlyZSgnbG9kYXNoL21hcCcpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgcmVwbGFjZTogdHJ1ZSxcclxuICAgIHRlbXBsYXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuICcnICtcclxuICAgICAgICAnPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj4nICtcclxuICAgICAgICAnICA8bGFiZWwgY2xhc3M9XCJjb250cm9sLWxhYmVsXCIgZm9ybS1idWlsZGVyLXRvb2x0aXA9XCJUYWcgdGhlIGZpZWxkIGZvciB1c2UgaW4gY3VzdG9tIGxvZ2ljLlwiPkZpZWxkIFRhZ3M8L2xhYmVsPicgK1xyXG4gICAgICAgICcgIDx0YWdzLWlucHV0IG5nLW1vZGVsPVwidGFnc1wiIG9uLXRhZy1hZGRlZD1cImFkZFRhZygkdGFnKVwiIG9uLXRhZy1yZW1vdmVkPVwicmVtb3ZlVGFnKCR0YWcpXCI+PC90YWdzLWlucHV0PicgK1xyXG4gICAgICAgICc8L2Rpdj4nO1xyXG4gICAgfSxcclxuICAgIGNvbnRyb2xsZXI6IFsnJHNjb3BlJywgZnVuY3Rpb24oJHNjb3BlKSB7XHJcbiAgICAgICRzY29wZS5jb21wb25lbnQudGFncyA9ICRzY29wZS5jb21wb25lbnQudGFncyB8fCBbXTtcclxuICAgICAgJHNjb3BlLnRhZ3MgPSBfbWFwKCRzY29wZS5jb21wb25lbnQudGFncywgZnVuY3Rpb24odGFnKSB7XHJcbiAgICAgICAgcmV0dXJuIHt0ZXh0OiB0YWd9O1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgICRzY29wZS5hZGRUYWcgPSBmdW5jdGlvbih0YWcpIHtcclxuICAgICAgICBpZiAoISRzY29wZS5jb21wb25lbnQpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEkc2NvcGUuY29tcG9uZW50LnRhZ3MpIHtcclxuICAgICAgICAgICRzY29wZS5jb21wb25lbnQudGFncyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAkc2NvcGUuY29tcG9uZW50LnRhZ3MucHVzaCh0YWcudGV4dCk7XHJcbiAgICAgIH07XHJcbiAgICAgICRzY29wZS5yZW1vdmVUYWcgPSBmdW5jdGlvbih0YWcpIHtcclxuICAgICAgICBpZiAoJHNjb3BlLmNvbXBvbmVudC50YWdzICYmICRzY29wZS5jb21wb25lbnQudGFncy5sZW5ndGgpIHtcclxuICAgICAgICAgIHZhciB0YWdJbmRleCA9ICRzY29wZS5jb21wb25lbnQudGFncy5pbmRleE9mKHRhZy50ZXh0KTtcclxuICAgICAgICAgIGlmICh0YWdJbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgJHNjb3BlLmNvbXBvbmVudC50YWdzLnNwbGljZSh0YWdJbmRleCwgMSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfV1cclxuICB9O1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gW1xyXG4gIGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc2NvcGU6IHtcclxuICAgICAgICBjb21wb25lbnQ6ICc9JyxcclxuICAgICAgICBmb3JtaW86ICc9JyxcclxuICAgICAgICBmb3JtOiAnPScsXHJcbiAgICAgICAgLy8gIyBvZiBpdGVtcyBuZWVkZWQgaW4gdGhlIGxpc3QgYmVmb3JlIGhpZGluZyB0aGVcclxuICAgICAgICAvLyBkcmFnIGFuZCBkcm9wIHByb21wdCBkaXZcclxuICAgICAgICBoaWRlRG5kQm94Q291bnQ6ICc9JyxcclxuICAgICAgICBvcHRpb25zOiAnPSdcclxuICAgICAgfSxcclxuICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgcmVwbGFjZTogdHJ1ZSxcclxuICAgICAgY29udHJvbGxlcjogJ2Zvcm1CdWlsZGVyRG5kJyxcclxuICAgICAgdGVtcGxhdGVVcmw6ICdmb3JtaW8vZm9ybWJ1aWxkZXIvcm93Lmh0bWwnXHJcbiAgICB9O1xyXG4gIH1cclxuXTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcclxuICogQSBkaXJlY3RpdmUgZm9yIGEgdGFibGUgYnVpbGRlclxyXG4gKi9cclxudmFyIF9tZXJnZSA9IHJlcXVpcmUoJ2xvZGFzaC9tZXJnZScpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgcmVwbGFjZTogdHJ1ZSxcclxuICAgIHRlbXBsYXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuICc8ZGl2IGNsYXNzPVwiZm9ybS1idWlsZGVyLXRhYmxlXCI+JyArXHJcbiAgICAgICAgJyAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj4nICtcclxuICAgICAgICAnICAgIDxsYWJlbCBmb3I9XCJsYWJlbFwiPk51bWJlciBvZiBSb3dzPC9sYWJlbD4nICtcclxuICAgICAgICAnICAgIDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBpZD1cIm51bVJvd3NcIiBuYW1lPVwibnVtUm93c1wiIHBsYWNlaG9sZGVyPVwiTnVtYmVyIG9mIFJvd3NcIiBuZy1tb2RlbD1cImNvbXBvbmVudC5udW1Sb3dzXCI+JyArXHJcbiAgICAgICAgJyAgPC9kaXY+JyArXHJcbiAgICAgICAgJyAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj4nICtcclxuICAgICAgICAnICAgIDxsYWJlbCBmb3I9XCJsYWJlbFwiPk51bWJlciBvZiBDb2x1bW5zPC9sYWJlbD4nICtcclxuICAgICAgICAnICAgIDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBpZD1cIm51bUNvbHNcIiBuYW1lPVwibnVtQ29sc1wiIHBsYWNlaG9sZGVyPVwiTnVtYmVyIG9mIENvbHVtbnNcIiBuZy1tb2RlbD1cImNvbXBvbmVudC5udW1Db2xzXCI+JyArXHJcbiAgICAgICAgJyAgPC9kaXY+JyArXHJcbiAgICAgICAgJzwvZGl2Pic7XHJcbiAgICB9LFxyXG4gICAgY29udHJvbGxlcjogW1xyXG4gICAgICAnJHNjb3BlJyxcclxuICAgICAgZnVuY3Rpb24oJHNjb3BlKSB7XHJcbiAgICAgICAgJHNjb3BlLmJ1aWxkZXIgPSB0cnVlO1xyXG4gICAgICAgIHZhciBjaGFuZ2VUYWJsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgLyplc2xpbnQtZGlzYWJsZSBtYXgtZGVwdGggKi9cclxuICAgICAgICAgIGlmICgkc2NvcGUuY29tcG9uZW50Lm51bVJvd3MgJiYgJHNjb3BlLmNvbXBvbmVudC5udW1Db2xzKSB7XHJcbiAgICAgICAgICAgIHZhciB0bXBUYWJsZSA9IFtdO1xyXG4gICAgICAgICAgICAkc2NvcGUuY29tcG9uZW50LnJvd3Muc3BsaWNlKCRzY29wZS5jb21wb25lbnQubnVtUm93cyk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8ICRzY29wZS5jb21wb25lbnQubnVtUm93czsgcm93KyspIHtcclxuICAgICAgICAgICAgICBpZiAoJHNjb3BlLmNvbXBvbmVudC5yb3dzW3Jvd10pIHtcclxuICAgICAgICAgICAgICAgICRzY29wZS5jb21wb25lbnQucm93c1tyb3ddLnNwbGljZSgkc2NvcGUuY29tcG9uZW50Lm51bUNvbHMpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCAkc2NvcGUuY29tcG9uZW50Lm51bUNvbHM7IGNvbCsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRtcFRhYmxlW3Jvd10pIHtcclxuICAgICAgICAgICAgICAgICAgdG1wVGFibGVbcm93XSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdG1wVGFibGVbcm93XVtjb2xdID0ge2NvbXBvbmVudHM6W119O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAkc2NvcGUuY29tcG9uZW50LnJvd3MgPSBfbWVyZ2UodG1wVGFibGUsICRzY29wZS5jb21wb25lbnQucm93cyk7XHJcbiAgICAgICAgICAgIC8qZXNsaW50LWVuYWJsZSBtYXgtZGVwdGggKi9cclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAkc2NvcGUuJHdhdGNoKCdjb21wb25lbnQubnVtUm93cycsIGNoYW5nZVRhYmxlKTtcclxuICAgICAgICAkc2NvcGUuJHdhdGNoKCdjb21wb25lbnQubnVtQ29scycsIGNoYW5nZVRhYmxlKTtcclxuICAgICAgfVxyXG4gICAgXVxyXG4gIH07XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXHJcbiogSW52b2tlcyBCb290c3RyYXAncyBwb3BvdmVyIGpxdWVyeSBwbHVnaW4gb24gYW4gZWxlbWVudFxyXG4qIFRvb2x0aXAgdGV4dCBjYW4gYmUgcHJvdmlkZWQgdmlhIHRpdGxlIGF0dHJpYnV0ZSBvclxyXG4qIGFzIHRoZSB2YWx1ZSBmb3IgdGhpcyBkaXJlY3RpdmUuXHJcbiovXHJcbm1vZHVsZS5leHBvcnRzID0gWyckZmlsdGVyJywgZnVuY3Rpb24oJGZpbHRlcikge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXN0cmljdDogJ0EnLFxyXG4gICAgcmVwbGFjZTogZmFsc2UsXHJcbiAgICBsaW5rOiBmdW5jdGlvbigkc2NvcGUsIGVsLCBhdHRycykge1xyXG4gICAgICB2YXIgZm9ybWlvVHJhbnNsYXRlID0gJGZpbHRlcignZm9ybWlvVHJhbnNsYXRlJyk7XHJcblxyXG4gICAgICBpZiAoYXR0cnMuZm9ybUJ1aWxkZXJUb29sdGlwIHx8IGF0dHJzLnRpdGxlKSB7XHJcbiAgICAgICAgdmFyIHRvb2x0aXAgPSBhbmd1bGFyLmVsZW1lbnQoJzxpIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1xdWVzdGlvbi1zaWduIHRleHQtbXV0ZWRcIj48L2k+Jyk7XHJcbiAgICAgICAgdG9vbHRpcC5wb3BvdmVyKHtcclxuICAgICAgICAgIGh0bWw6IHRydWUsXHJcbiAgICAgICAgICB0cmlnZ2VyOiAnbWFudWFsJyxcclxuICAgICAgICAgIHBsYWNlbWVudDogJ3JpZ2h0JyxcclxuICAgICAgICAgIGNvbnRlbnQ6IGZvcm1pb1RyYW5zbGF0ZShhdHRycy50aXRsZSB8fCBhdHRycy5mb3JtQnVpbGRlclRvb2x0aXApXHJcbiAgICAgICAgfSkub24oJ21vdXNlZW50ZXInLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHZhciAkc2VsZiA9IGFuZ3VsYXIuZWxlbWVudCh0aGlzKTtcclxuICAgICAgICAgICRzZWxmLnBvcG92ZXIoJ3Nob3cnKTtcclxuICAgICAgICAgICRzZWxmLnNpYmxpbmdzKCcucG9wb3ZlcicpLm9uKCdtb3VzZWxlYXZlJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICRzZWxmLnBvcG92ZXIoJ2hpZGUnKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pLm9uKCdtb3VzZWxlYXZlJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICB2YXIgJHNlbGYgPSBhbmd1bGFyLmVsZW1lbnQodGhpcyk7XHJcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoIWFuZ3VsYXIuZWxlbWVudCgnLnBvcG92ZXI6aG92ZXInKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAkc2VsZi5wb3BvdmVyKCdoaWRlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0sIDEwMCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZWwuYXBwZW5kKCcgJykuYXBwZW5kKHRvb2x0aXApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxufV07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcmVzdHJpY3Q6ICdBJyxcclxuICAgIHJlcXVpcmU6ICduZ01vZGVsJyxcclxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtLCBhdHRyLCBjdHJsKSB7XHJcbiAgICAgIGN0cmwuJHBhcnNlcnMucHVzaChmdW5jdGlvbihpbnB1dCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICB2YXIgb2JqID0gSlNPTi5wYXJzZShpbnB1dCk7XHJcbiAgICAgICAgICBjdHJsLiRzZXRWYWxpZGl0eSgnanNvbklucHV0JywgdHJ1ZSk7XHJcbiAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgY3RybC4kc2V0VmFsaWRpdHkoJ2pzb25JbnB1dCcsIGZhbHNlKTtcclxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgY3RybC4kZm9ybWF0dGVycy5wdXNoKGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgY3RybC4kc2V0VmFsaWRpdHkoJ2pzb25JbnB1dCcsIGZhbHNlKTtcclxuICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHZhciBzdHIgPSBhbmd1bGFyLnRvSnNvbihkYXRhLCB0cnVlKTtcclxuICAgICAgICAgIGN0cmwuJHNldFZhbGlkaXR5KCdqc29uSW5wdXQnLCB0cnVlKTtcclxuICAgICAgICAgIHJldHVybiBzdHI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICBjdHJsLiRzZXRWYWxpZGl0eSgnanNvbklucHV0JywgZmFsc2UpO1xyXG4gICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxyXG4qIFByZXZlbnRzIHVzZXIgaW5wdXR0aW5nIGludmFsaWQgYXBpIGtleSBjaGFyYWN0ZXJzLlxyXG4qIFZhbGlkIGNoYXJhY3RlcnMgZm9yIGFuIGFwaSBrZXkgYXJlIGFscGhhbnVtZXJpYyBhbmQgaHlwaGVuc1xyXG4qL1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXF1aXJlOiAnbmdNb2RlbCcsXHJcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIG5nTW9kZWwpIHtcclxuICAgICAgdmFyIGludmFsaWRSZWdleCA9IC9eW15BLVphLXpdK3xbXkEtWmEtejAtOVxcLVxcLl0rL2c7XHJcbiAgICAgIG5nTW9kZWwuJHBhcnNlcnMucHVzaChmdW5jdGlvbihpbnB1dFZhbHVlKSB7XHJcbiAgICAgICAgdmFyIHRyYW5zZm9ybWVkSW5wdXQgPSBpbnB1dFZhbHVlLnJlcGxhY2UoaW52YWxpZFJlZ2V4LCAnJyk7XHJcbiAgICAgICAgaWYgKHRyYW5zZm9ybWVkSW5wdXQgIT09IGlucHV0VmFsdWUpIHtcclxuICAgICAgICAgIG5nTW9kZWwuJHNldFZpZXdWYWx1ZSh0cmFuc2Zvcm1lZElucHV0KTtcclxuICAgICAgICAgIG5nTW9kZWwuJHJlbmRlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRJbnB1dDtcclxuICAgICB9KTtcclxuICAgIH1cclxuICB9O1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxyXG4qIEEgZGlyZWN0aXZlIHRoYXQgcHJvdmlkZXMgYSBVSSB0byBhZGQge3ZhbHVlLCBsYWJlbH0gb2JqZWN0cyB0byBhbiBhcnJheS5cclxuKi9cclxudmFyIF9tYXAgPSByZXF1aXJlKCdsb2Rhc2gvbWFwJyk7XHJcbnZhciBfY2FtZWxDYXNlID0gcmVxdWlyZSgnbG9kYXNoL2NhbWVsQ2FzZScpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICBzY29wZToge1xyXG4gICAgICBkYXRhOiAnPScsXHJcbiAgICAgIGxhYmVsOiAnQCcsXHJcbiAgICAgIHRvb2x0aXBUZXh0OiAnQCcsXHJcbiAgICAgIHZhbHVlTGFiZWw6ICdAJyxcclxuICAgICAgbGFiZWxMYWJlbDogJ0AnLFxyXG4gICAgICB2YWx1ZVByb3BlcnR5OiAnQCcsXHJcbiAgICAgIGxhYmVsUHJvcGVydHk6ICdAJ1xyXG4gICAgfSxcclxuICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+JyArXHJcbiAgICAgICAgICAgICAgICAnPGxhYmVsIGZvcm0tYnVpbGRlci10b29sdGlwPVwie3sgdG9vbHRpcFRleHQgfMKgZm9ybWlvVHJhbnNsYXRlIH19XCI+e3sgbGFiZWwgfMKgZm9ybWlvVHJhbnNsYXRlIH19PC9sYWJlbD4nICtcclxuICAgICAgICAgICAgICAgICc8dGFibGUgY2xhc3M9XCJ0YWJsZSB0YWJsZS1jb25kZW5zZWRcIj4nICtcclxuICAgICAgICAgICAgICAgICAgJzx0aGVhZD4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPHRyPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgJzx0aCBjbGFzcz1cImNvbC14cy02XCI+e3sgbGFiZWxMYWJlbCB8wqBmb3JtaW9UcmFuc2xhdGUgfX08L3RoPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgJzx0aCBjbGFzcz1cImNvbC14cy00XCI+e3sgdmFsdWVMYWJlbCB8wqBmb3JtaW9UcmFuc2xhdGUgfX08L3RoPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgJzx0aCBjbGFzcz1cImNvbC14cy0yXCI+PC90aD4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPC90cj4nICtcclxuICAgICAgICAgICAgICAgICAgJzwvdGhlYWQ+JyArXHJcbiAgICAgICAgICAgICAgICAgICc8dGJvZHk+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzx0ciBuZy1yZXBlYXQ9XCJ2IGluIGRhdGEgdHJhY2sgYnkgJGluZGV4XCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAnPHRkIGNsYXNzPVwiY29sLXhzLTZcIj48aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIG5nLW1vZGVsPVwidltsYWJlbFByb3BlcnR5XVwiIHBsYWNlaG9sZGVyPVwie3sgbGFiZWxMYWJlbCB8wqBmb3JtaW9UcmFuc2xhdGUgfX1cIi8+PC90ZD4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICc8dGQgY2xhc3M9XCJjb2wteHMtNFwiPjxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgbmctbW9kZWw9XCJ2W3ZhbHVlUHJvcGVydHldXCIgcGxhY2Vob2xkZXI9XCJ7eyB2YWx1ZUxhYmVsIHzCoGZvcm1pb1RyYW5zbGF0ZSB9fVwiLz48L3RkPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgJzx0ZCBjbGFzcz1cImNvbC14cy0yXCI+PGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLWRhbmdlciBidG4teHNcIiBuZy1jbGljaz1cInJlbW92ZVZhbHVlKCRpbmRleClcIiB0YWJpbmRleD1cIi0xXCI+PHNwYW4gY2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLXJlbW92ZS1jaXJjbGVcIj48L3NwYW4+PC9idXR0b24+PC90ZD4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPC90cj4nICtcclxuICAgICAgICAgICAgICAgICAgJzwvdGJvZHk+JyArXHJcbiAgICAgICAgICAgICAgICAnPC90YWJsZT4nICtcclxuICAgICAgICAgICAgICAgICc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0blwiIG5nLWNsaWNrPVwiYWRkVmFsdWUoKVwiPnt7IFxcJ0FkZCBWYWx1ZVxcJyB8wqBmb3JtaW9UcmFuc2xhdGUgfX08L2J1dHRvbj4nICtcclxuICAgICAgICAgICAgICAnPC9kaXY+JyxcclxuICAgIHJlcGxhY2U6IHRydWUsXHJcbiAgICBsaW5rOiBmdW5jdGlvbigkc2NvcGUsIGVsLCBhdHRycykge1xyXG4gICAgICAkc2NvcGUudmFsdWVQcm9wZXJ0eSA9ICRzY29wZS52YWx1ZVByb3BlcnR5IHx8ICd2YWx1ZSc7XHJcbiAgICAgICRzY29wZS5sYWJlbFByb3BlcnR5ID0gJHNjb3BlLmxhYmVsUHJvcGVydHkgfHwgJ2xhYmVsJztcclxuICAgICAgJHNjb3BlLnZhbHVlTGFiZWwgPSAkc2NvcGUudmFsdWVMYWJlbCB8fCAnVmFsdWUnO1xyXG4gICAgICAkc2NvcGUubGFiZWxMYWJlbCA9ICRzY29wZS5sYWJlbExhYmVsIHx8ICdMYWJlbCc7XHJcbiAgICAgICRzY29wZS5kYXRhID0gJHNjb3BlLmRhdGEgfHwgW107XHJcblxyXG4gICAgICAkc2NvcGUuYWRkVmFsdWUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgb2JqID0ge307XHJcbiAgICAgICAgb2JqWyRzY29wZS52YWx1ZVByb3BlcnR5XSA9ICcnO1xyXG4gICAgICAgIG9ialskc2NvcGUubGFiZWxQcm9wZXJ0eV0gPSAnJztcclxuICAgICAgICAkc2NvcGUuZGF0YS5wdXNoKG9iaik7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAkc2NvcGUucmVtb3ZlVmFsdWUgPSBmdW5jdGlvbihpbmRleCkge1xyXG4gICAgICAgICRzY29wZS5kYXRhLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBpZiAoJHNjb3BlLmRhdGEubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgJHNjb3BlLmFkZFZhbHVlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghYXR0cnMubm9BdXRvY29tcGxldGVWYWx1ZSkge1xyXG4gICAgICAgICRzY29wZS4kd2F0Y2goJ2RhdGEnLCBmdW5jdGlvbihuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcclxuICAgICAgICAgIC8vIElnbm9yZSBhcnJheSBhZGRpdGlvbi9kZWxldGlvbiBjaGFuZ2VzXHJcbiAgICAgICAgICBpZiAobmV3VmFsdWUubGVuZ3RoICE9PSBvbGRWYWx1ZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIF9tYXAobmV3VmFsdWUsIGZ1bmN0aW9uKGVudHJ5LCBpKSB7XHJcbiAgICAgICAgICAgIGlmIChlbnRyeVskc2NvcGUubGFiZWxQcm9wZXJ0eV0gIT09IG9sZFZhbHVlW2ldWyRzY29wZS5sYWJlbFByb3BlcnR5XSkgey8vIGxhYmVsIGNoYW5nZWRcclxuICAgICAgICAgICAgICBpZiAoZW50cnlbJHNjb3BlLnZhbHVlUHJvcGVydHldID09PSAnJyB8fCBlbnRyeVskc2NvcGUudmFsdWVQcm9wZXJ0eV0gPT09IF9jYW1lbENhc2Uob2xkVmFsdWVbaV1bJHNjb3BlLmxhYmVsUHJvcGVydHldKSkge1xyXG4gICAgICAgICAgICAgICAgZW50cnlbJHNjb3BlLnZhbHVlUHJvcGVydHldID0gX2NhbWVsQ2FzZShlbnRyeVskc2NvcGUubGFiZWxQcm9wZXJ0eV0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gWydGb3JtaW9VdGlscycsIGZ1bmN0aW9uKEZvcm1pb1V0aWxzKSB7XHJcbiAgdmFyIHN1ZmZpeFJlZ2V4ID0gLyhcXGQrKSQvO1xyXG5cclxuICAvKipcclxuICAgKiBNZW1vaXplIHRoZSBnaXZlbiBmb3JtIGNvbXBvbmVudHMgaW4gYSBtYXAsIHVzaW5nIHRoZSBjb21wb25lbnQga2V5cy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvbXBvbmVudHNcclxuICAgKiAgIEFuIGFycmF5IG9mIHRoZSBmb3JtIGNvbXBvbmVudHMuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XHJcbiAgICogICBUaGUgaW5wdXQgY29tcG9uZW50IHdlJ3JlIHRyeWluZyB0byB1bmlxdWlmeS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAgICogICBUaGUgbWVtb2l6ZWQgZm9ybSBjb21wb25lbnRzLlxyXG4gICAqL1xyXG4gIHZhciBmaW5kRXhpc3RpbmdDb21wb25lbnRzID0gZnVuY3Rpb24oY29tcG9uZW50cywgaW5wdXQpIHtcclxuICAgIC8vIFByZWJ1aWxkIGEgbGlzdCBvZiBleGlzdGluZyBjb21wb25lbnRzLlxyXG4gICAgdmFyIGV4aXN0aW5nQ29tcG9uZW50cyA9IHt9O1xyXG4gICAgRm9ybWlvVXRpbHMuZWFjaENvbXBvbmVudChjb21wb25lbnRzLCBmdW5jdGlvbihjb21wb25lbnQpIHtcclxuICAgICAgLy8gSWYgdGhlcmVzIG5vIGtleSwgd2UgY2FudCBjb21wYXJlIGNvbXBvbmVudHMuXHJcbiAgICAgIGlmICghY29tcG9uZW50LmtleSkgcmV0dXJuO1xyXG5cclxuICAgICAgLy8gQSBjb21wb25lbnQgaXMgcHJlLWV4aXN0aW5nIGlmIHRoZSBrZXkgaXMgdW5pcXVlLCBvciB0aGUga2V5IGlzIGEgZHVwbGljYXRlIGFuZCBpdHMgbm90IGZsYWdnZWQgYXMgdGhlIG5ldyBjb21wb25lbnQuXHJcbiAgICAgIGlmIChcclxuICAgICAgICAoY29tcG9uZW50LmtleSAhPT0gaW5wdXQua2V5KSB8fFxyXG4gICAgICAgICgoY29tcG9uZW50LmtleSA9PT0gaW5wdXQua2V5KSAmJiAoISFjb21wb25lbnQuaXNOZXcgIT09ICEhaW5wdXQuaXNOZXcpKVxyXG4gICAgICApIHtcclxuICAgICAgICBleGlzdGluZ0NvbXBvbmVudHNbY29tcG9uZW50LmtleV0gPSBjb21wb25lbnQ7XHJcbiAgICAgIH1cclxuICAgIH0sIHRydWUpO1xyXG5cclxuICAgIHJldHVybiBleGlzdGluZ0NvbXBvbmVudHM7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lIGlmIHRoZSBnaXZlbiBjb21wb25lbnQga2V5IGFscmVhZHkgZXhpc3RzIGluIHRoZSBtZW1vaXphdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtZW1vaXphdGlvblxyXG4gICAqICAgVGhlIGZvcm0gY29tcG9uZW50cyBtYXAuXHJcbiAgICogQHBhcmFtIGNvbXBvbmVudFxyXG4gICAqICAgVGhlIGNvbXBvbmVudCB0byB1bmlxdWlmeS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqICAgV2hldGhlciBvciBub3QgdGhlIGtleSBleGlzdHMuXHJcbiAgICovXHJcbiAgdmFyIGtleUV4aXN0cyA9IGZ1bmN0aW9uKG1lbW9pemF0aW9uLCBrZXkpIHtcclxuICAgIGlmIChtZW1vaXphdGlvbi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEl0ZXJhdGUgdGhlIGdpdmVuIGtleSB0byBtYWtlIGl0IHVuaXF1ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcclxuICAgKiAgIE1vZGlmeSB0aGUgY29tcG9uZW50IGtleSB0byBiZSB1bmlxdWUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gICAqICAgVGhlIG5ldyBjb21wb25lbnQga2V5LlxyXG4gICAqL1xyXG4gIHZhciBpdGVyYXRlS2V5ID0gZnVuY3Rpb24oa2V5KSB7XHJcbiAgICBpZiAoIWtleS5tYXRjaChzdWZmaXhSZWdleCkpIHtcclxuICAgICAgcmV0dXJuIGtleSArICcyJztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ga2V5LnJlcGxhY2Uoc3VmZml4UmVnZXgsIGZ1bmN0aW9uKHN1ZmZpeCkge1xyXG4gICAgICByZXR1cm4gTnVtYmVyKHN1ZmZpeCkgKyAxO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQXBwZW5kcyBhIG51bWJlciB0byBhIGNvbXBvbmVudC5rZXkgdG8ga2VlcCBpdCB1bmlxdWVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmb3JtXHJcbiAgICogICBUaGUgY29tcG9uZW50cyBwYXJlbnQgZm9ybS5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gY29tcG9uZW50XHJcbiAgICogICBUaGUgY29tcG9uZW50IHRvIHVuaXF1aWZ5XHJcbiAgICovXHJcbiAgdmFyIHVuaXF1aWZ5ID0gZnVuY3Rpb24oZm9ybSwgY29tcG9uZW50KSB7XHJcbiAgICB2YXIgaXNOZXcgPSBjb21wb25lbnQuaXNOZXcgfHwgZmFsc2U7XHJcblxyXG4gICAgLy8gUmVjdXJzZSBpbnRvIGFsbCBjaGlsZCBjb21wb25lbnRzLlxyXG4gICAgRm9ybWlvVXRpbHMuZWFjaENvbXBvbmVudChbY29tcG9uZW50XSwgZnVuY3Rpb24oY29tcG9uZW50KSB7XHJcbiAgICAgIC8vIEZvcmNlIHRoZSBjb21wb25lbnQgaXNOZXcgdG8gYmUgdGhlIHNhbWUgYXMgdGhlIHBhcmVudC5cclxuICAgICAgY29tcG9uZW50LmlzTmV3ID0gaXNOZXc7XHJcblxyXG4gICAgICAvLyBTa2lwIGtleSB1bmlxdWlmaWNhdGlvbiBpZiB0aGlzIGNvbXBvbmVudCBkb2Vzbid0IGhhdmUgYSBrZXkuXHJcbiAgICAgIGlmICghY29tcG9uZW50LmtleSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIG1lbW9pemF0aW9uID0gZmluZEV4aXN0aW5nQ29tcG9uZW50cyhmb3JtLmNvbXBvbmVudHMsIGNvbXBvbmVudCk7XHJcbiAgICAgIHdoaWxlIChrZXlFeGlzdHMobWVtb2l6YXRpb24sIGNvbXBvbmVudC5rZXkpKSB7XHJcbiAgICAgICAgY29tcG9uZW50LmtleSA9IGl0ZXJhdGVLZXkoY29tcG9uZW50LmtleSk7XHJcbiAgICAgIH1cclxuICAgIH0sIHRydWUpO1xyXG5cclxuICAgIHJldHVybiBjb21wb25lbnQ7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHVuaXF1aWZ5OiB1bmlxdWlmeVxyXG4gIH07XHJcbn1dO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8vIENyZWF0ZSBhbiBBbmd1bGFySlMgc2VydmljZSBjYWxsZWQgZGVib3VuY2VcclxubW9kdWxlLmV4cG9ydHMgPSBbJyR0aW1lb3V0JywnJHEnLCBmdW5jdGlvbigkdGltZW91dCwgJHEpIHtcclxuICAvLyBUaGUgc2VydmljZSBpcyBhY3R1YWxseSB0aGlzIGZ1bmN0aW9uLCB3aGljaCB3ZSBjYWxsIHdpdGggdGhlIGZ1bmNcclxuICAvLyB0aGF0IHNob3VsZCBiZSBkZWJvdW5jZWQgYW5kIGhvdyBsb25nIHRvIHdhaXQgaW4gYmV0d2VlbiBjYWxsc1xyXG4gIHJldHVybiBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcclxuICAgIHZhciB0aW1lb3V0O1xyXG4gICAgLy8gQ3JlYXRlIGEgZGVmZXJyZWQgb2JqZWN0IHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aGVuIHdlIG5lZWQgdG9cclxuICAgIC8vIGFjdHVhbGx5IGNhbGwgdGhlIGZ1bmNcclxuICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcywgYXJncyA9IGFyZ3VtZW50cztcclxuICAgICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcclxuICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKSk7XHJcbiAgICAgICAgICBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcclxuICAgICAgaWYgKCB0aW1lb3V0ICkge1xyXG4gICAgICAgICR0aW1lb3V0LmNhbmNlbCh0aW1lb3V0KTtcclxuICAgICAgfVxyXG4gICAgICB0aW1lb3V0ID0gJHRpbWVvdXQobGF0ZXIsIHdhaXQpO1xyXG4gICAgICBpZiAoY2FsbE5vdykge1xyXG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUoZnVuYy5hcHBseShjb250ZXh0LGFyZ3MpKTtcclxuICAgICAgICBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbiAgICB9O1xyXG4gIH07XHJcbn1dO1xyXG4iXX0=
